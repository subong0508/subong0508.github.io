<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 23 Jun 2021 17:38:07 +0900</pubDate>
    <lastBuildDate>Wed, 23 Jun 2021 17:38:07 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Hive Basic Commands</title>
        <description>&lt;h2 id=&quot;create-database-table&quot;&gt;1. Create Database, Table&lt;/h2&gt;

&lt;p&gt;하이브에서 데이터베이스를 만든다는 것은 실제 데이터를 저장하는 것이 아니라 테이블의 스키마를 설정하는 것이다. 해당 정보는 metastore에 저장된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE DATABASE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE DATABASE IF NOT EXISTS&lt;/code&gt;를 활용하여 데이터베이스를 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ignored&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;exists&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;또는 comment, properties 같은 정보를 설정하면서 데이터베이스를 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;comment&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;exists&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'this is d2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;exists&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'creator'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'jaeeun'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'date'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'2021-06-23'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;확인&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;describe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extended&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;USE {database}&lt;/code&gt;를 통해 데이터베이스에 접근하여 테이블을 생성하거나 조작할 수 있다.&lt;/p&gt;

&lt;p&gt;하이브에는 &lt;strong&gt;internal, external&lt;/strong&gt; 두 종류의 테이블이 존재한다. 전자의 경우 하이브가 테이블의 유일한 소유자가 되는 반면 후자에는 하이브가 metastore만 소유하고 실제 데이터는 HDFS가 관리한다. 따라서 DROP을 사용했을 때 external table은 metastore(table definition)만 사라지고 internal table은 metastore, 실제 데이터가 모두 사라진다. 기본값은 internal table이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE EXTERNAL TABLE&lt;/code&gt;을 통해 테이블을 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;img src=&quot;/img/hive/7.png&quot; alt=&quot;img&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 데이터를 저장하고 싶다면&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;exists&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delimited&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;','&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;':'&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;lines&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;stored&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;와 같은 쿼리를 사용하면 된다.&lt;/p&gt;

&lt;p&gt;테이블은 기본적으로 /user/hive/warehouse 디렉토리에 저장되는데, 이를 바꾸고 싶다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;location '{dir}'&lt;/code&gt;을 뒤에 붙여준다.&lt;/p&gt;

&lt;h2 id=&quot;load-data&quot;&gt;2. Load Data&lt;/h2&gt;

&lt;p&gt;이렇게 테이블 포맷을 설정해준 다음, &lt;code class=&quot;highlighter-rouge&quot;&gt;load data inpath&lt;/code&gt;를 사용하여 테이블에 데이터를 로딩한다. 만약 파일이 HDFS가 아닌 로컬에 존재한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;load data local inpath&lt;/code&gt;를 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inpath&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/home/ubuntu/table1.txt'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;into table&lt;/code&gt;은 테이블에 데이터가 존재한다면 append 하는 방식으로 동작한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;overwrite table&lt;/code&gt;은 테이블에 있는 기존 데이터를 지우고 새롭게 데이터를 쓴다.&lt;/p&gt;

&lt;h2 id=&quot;insert-statement&quot;&gt;3. Insert Statement&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt; &lt;img src=&quot;/img/hive/9.png&quot; alt=&quot;img&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 테이블을 만들었다고 가정하자.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stored&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp_tab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;결과는 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;img src=&quot;/img/hive/10.png&quot; alt=&quot;img&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;overwrite&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp_tab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 쿼리를 사용하면 모든 데이터를 지우고 새로 데이터를 삽입한다.&lt;/p&gt;

&lt;h3 id=&quot;multi-insert&quot;&gt;3-1. Multi Insert&lt;/h3&gt;

&lt;p&gt;개발자를 위한 테이블과 매니저를 위한 테이블이 따로 존재하는 상황을 생각해보자.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp_tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;developer_tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Developer'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emp_tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;manager_tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Mgr'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;alter-table&quot;&gt;4. Alter Table&lt;/h2&gt;

&lt;p&gt;테이블의 스키마를 변경하기 위해 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;컬럼&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;추가&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;columns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col5&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;컬럼&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;순서&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;변경&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;change&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;after&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;변경&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rename&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;컬럼&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;replace&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;columns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;변경&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tblproperties&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'auto.perge'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'true'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;확인&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;formatted&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;파일&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;포맷&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;변경&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fileformat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;sorting&quot;&gt;5. Sorting&lt;/h2&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SORT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DISTRIBUTE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CLUSTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;cluster&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ORDER BY&lt;/code&gt;: 데이터를 fully sort 하기 위해 &lt;strong&gt;single reducer&lt;/strong&gt;를 사용한다. 따라서 데이터 크기가 매우 클 때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;LIMIT&lt;/code&gt;을 사용해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SORT BY&lt;/code&gt;: 여러 개의 reducer를 사용한다. 일반적으로 full sort가 되지 않는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DISTRIBUTE BY&lt;/code&gt;: 겹치지 않는 데이터로 나눈다. 정렬을 하지 않는다. 정렬을 하고 싶다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;distribute by col2 sort by col2&lt;/code&gt;와 같이 쿼리를 작성해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CLUSTER BY&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;DISTRIBUTE BY&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SORT BY&lt;/code&gt;의 combination이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 23 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/hive/2021/06/23/Hive-Sec02.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/hive/2021/06/23/Hive-Sec02.html</guid>
        
        <category>Hive</category>
        
        
        <category>Hive</category>
        
      </item>
    
      <item>
        <title>Imbalanced Data Classification</title>
        <description>&lt;p&gt;이번 포스팅에서는 Imbalanced data classification을 위한 여러 방법들을 알아볼 것이다. 예시로는 bankruptcy detection, fraud detection 등이 있다. 이러한 경우에는 Positive 비율이 1%도 안되고, 대부분의 머신러닝 모델은 Negative로 예측해버린다. 그렇게 예측해도 정확도 99%가 보장되기 때문이다. 이 문제를 해결하기 위한 여러 방법들을 소개하고자 한다.&lt;/p&gt;

&lt;h1 id=&quot;machine-learning-techniques&quot;&gt;Machine Learning Techniques&lt;/h1&gt;

&lt;h1 id=&quot;deep-learning-techniques&quot;&gt;Deep Learning Techniques&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;

</description>
        <pubDate>Wed, 23 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/machine%20learning/2021/06/23/Imbalanced-Classification.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/machine%20learning/2021/06/23/Imbalanced-Classification.html</guid>
        
        <category>statistics</category>
        
        <category>machine-learning</category>
        
        <category>data-imbalance</category>
        
        <category>imbalanced-data</category>
        
        
        <category>Machine Learning</category>
        
      </item>
    
      <item>
        <title>Hive Basic</title>
        <description>&lt;h1 id=&quot;introduction-to-hive&quot;&gt;0. Introduction to Hive&lt;/h1&gt;

&lt;h2 id=&quot;what-hive-is&quot;&gt;What Hive is?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;하이브란 HDFS에 저장된 데이터를 SQL과 비슷한 쿼리를 통해 처리할 수 있게 하는 쿼리 툴이다.&lt;/li&gt;
  &lt;li&gt;SQL은 DBMS에 저장된 데이터를 다루고, 하이브는 HDFS에 저장된 데이터를 다룬다.&lt;/li&gt;
  &lt;li&gt;테이블로 저장된 구조화된 데이터를 처리한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Batch processing&lt;/strong&gt;에 적합하다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MapReduce와 HDFS를 연결하는 렌즈에 해당한다.&lt;/strong&gt; 하이브 쿼리는 내부적으로 MapReduce 프로그램으로 변환된다.&lt;/li&gt;
  &lt;li&gt;Parquet, sequence file, ORC file, text file 등 여러 파일 포맷을 지원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;what-hive-is-not&quot;&gt;What Hive is Not?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;하이브는 데이터베이스가 아니다.&lt;/strong&gt; HDFS에 저장된 데이터를 tabular manner로 처리할 뿐이다.&lt;/li&gt;
  &lt;li&gt;OLTP를 위한 툴이 아니다. Row level insert, update, delete를 지원하지 않는다. 최근 버전은
지원하기 시작했지만 그렇게 효과적이지 않고 지정된 파일 포맷에만 가능하다.&lt;/li&gt;
  &lt;li&gt;Latency가 커 실시간 처리에는 적합하지 않다. 쿼리를 MapReduce 프로그램으로 바꿔야 하기 때문이다.&lt;/li&gt;
  &lt;li&gt;이미지, 비디오와 같은 비정형 데이터는 지원하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;motivation-of-hive&quot;&gt;1. Motivation of Hive&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;하이브는 MapReduce 프로그래밍의 복잡함을 줄이기 위해 개발되었다. Java 개발자가 아닌 사람도 데이터를 분석할 수 있게끔 해준다.&lt;/li&gt;
  &lt;li&gt;SQL 지식을 사용해서 하이브 쿼리를 작성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;hive-vs-sql&quot;&gt;2. Hive VS SQL&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;하이브는 SQL과 달리 데이터베이스가 아니다. 물리적 데이터를 저장하는 것은 HDFS이다.&lt;/li&gt;
  &lt;li&gt;Write-Once, Read-Many concept로 만들어진 프로그램이다. (SQL은 Write-Many, Read-Many)&lt;/li&gt;
  &lt;li&gt;하이브는 OLAP 시스템에 적합하고 SQL은 OLTP 시스템에 적합하다.&lt;/li&gt;
  &lt;li&gt;하이브는 SQL에 비해 scalable 하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;trailer&quot;&gt;2. Trailer&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt; &lt;img src=&quot;https://user-images.githubusercontent.com/46374850/122852831-3c71d380-d34c-11eb-9ece-6cbc046edd3a.png&quot; alt=&quot;hive&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위는 하이브가 작동하는 방식을 그림으로 나타낸 것이다. Create table 문을 이용하여 HDFS 파일을
테이블 데이터로 인식한다. &lt;font color=&quot;red&quot;&gt;이를 Loading 과정이라고 하는데, 실제 데이터는 변하지 않고 하이브가 그렇게 인식할 뿐이다.&lt;/font&gt; Loading이 끝나면 쿼리를 실행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;img src=&quot;/img/hive/2.png&quot; width=&quot;600&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;installation&quot;&gt;3. Installation&lt;/h1&gt;

&lt;p&gt;나는 &lt;a href=&quot;https://github.com/YBIGTA/EngineeringTeam/wiki/01.-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1-%EB%B0%8F--Python-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95&quot;&gt;링크1&lt;/a&gt;, &lt;a href=&quot;https://github.com/YBIGTA/EngineeringTeam/wiki/02.-PySpark-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95&quot;&gt;링크2&lt;/a&gt;를 참고하여 가상 머신에 하둡, 하이브를 설정했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/hive/3.png&quot; alt=&quot;하이브&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 22 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/hive/2021/06/22/Hive.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/hive/2021/06/22/Hive.html</guid>
        
        <category>Hive</category>
        
        
        <category>Hive</category>
        
      </item>
    
      <item>
        <title>Graph Theory with Python</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;서로소 집합&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시간복잡도: $O(V + M \log_{2}{V})$&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# 원소가 속한 집합 찾기
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합 merge
def union(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a &amp;lt; b:
        parent[b] = a
    else:
        parent[a] = b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;사이클 판별&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;for i in range(num_edges):
    a, b = map(int, input().split())
    if find_parent(parent, a) == find_parent(parent, b):
        cycle = True
        print(&quot;Cycle&quot;)
    else:
        union(parent, a, b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;minimum-spanning-tree&quot;&gt;크루스칼 알고리즘: Minimum Spanning Tree&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시간복잡도: $O(E \log {E})$&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;res = 0
edges.sort()
for e in edges:
    cost, a, b = e
    # not cycle
    if find_parent(parent, a) != find_parent(parent, b):
        union(parent, a, b)
        res += cost
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;위상 정렬&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시간복잡도: $O(V + E)$&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def topological_sort():
    result = []
    q = deque()

    # 진입차수가 0인 노드들 큐에 삽입
    for i in range(1, v+1):
        if indegree[i] == 0:
            q.append(i)

    while q:
        now = q.popleft()
        result.append(now)
        for i in graph[now]:
            indegree[i] -= 1
            # 진입차수가 0이 된다면
            if indegree[i] == 0:
                q.append(i)
    
    return result
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data%20structure/2021/02/28/GraphTheory.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data%20structure/2021/02/28/GraphTheory.html</guid>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        <category>graph</category>
        
        <category>shortest-path</category>
        
        
        <category>Data structure</category>
        
      </item>
    
      <item>
        <title>Shortest Path with Python</title>
        <description>&lt;p&gt;오늘은 파이썬을 이용해 weighted graph(가중치가 있는 그래프)에서 최단 경로를 찾는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;가중치가 없는 그래프라면 &lt;strong&gt;BFS&lt;/strong&gt;를 통해 최단 경로를 손쉽게 구할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;다익스트라 알고리즘&lt;/h1&gt;

&lt;p&gt;다익스트라 알고리즘은 한 노드에서 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘입니다.
다익스트라는 기본적으로 그리디 알고리즘의 한 종류로, 방문하지 않은 노드 중 가장 가까운 노드를 통해 갈 수 있는 경로를 개선합니다.&lt;/p&gt;

&lt;p&gt;다익스트라 알고리즘을 사용할 때는 시간복잡도를 개선하기 위해 힙 자료구조를 사용하고, 시간 복잡도는 $O(E \log {V})$가 됩니다.&lt;/p&gt;

&lt;p&gt;파이썬으로 간단하게 구현하면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq


# weighted graph
graph = [
    [0, 10, 20],
    [2, 0, 3],
    [10, 4, 0]
]
INF = int(1e9)


def dijkstra(start, graph):
    distance = [INF for _ in range(len(graph))]
    distance[start] = 0
    q = []
    heapq.heappush(q, (0, start)) # 거리, 노드
    while q:
        dist, now = heapq.heappop(q)
        # 이미 처리된 노드
        if distance[now] &amp;lt; dist:
            continue
        for i in range(len(graph)):
            if dist+graph[now][i] &amp;lt; distance[i]:
                distance[i] = dist+graph[now][i]
                heapq.heappush(q, (distance[i], i))
    return distance


print(dijkstra(0, graph)) # 0 10 13
print(dijkstra(1, graph)) # 2 0 3
print(dijkstra(2, graph)) # 6 4 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;플로이드 워셜 알고리즘&lt;/h1&gt;

&lt;p&gt;다음은 모든 지점에서 다른 모든 지점으로 가는 최단 경로를 구해주는 플로이드 워셜 알고리즘에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;플로이드 워셜 알고리즘의 시간복잡도는 $O(V^{3})$이라, 일반적인 코딩 테스트 환경에서는 정점의 수가 1000개 이하인 경우만 가능합니다.&lt;/p&gt;

&lt;p&gt;파이썬으로 구현한 코드는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# weighted graph
INF = int(1e9)
graph = [
    [0, 4, INF, 6],
    [3, 0, 7, INF],
    [5, INF, 0, 4],
    [INF, INF, 2, 0]
]
n = len(graph)

for k in range(n):
    for i in range(n):
        for j in range(n):
            graph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j])

print(*graph, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data%20structure/2021/02/27/ShortestPath.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data%20structure/2021/02/27/ShortestPath.html</guid>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        <category>graph</category>
        
        <category>shortest-path</category>
        
        
        <category>Data structure</category>
        
      </item>
    
      <item>
        <title>DFS, BFS with Python</title>
        <description>&lt;h1 id=&quot;dfs--&quot;&gt;DFS(깊이 우선 탐색)&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Depth-First Search&lt;/strong&gt;의 약자로, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;그래프는 노드(Node)/정점(Vertex)과 간선(Edge)로 구성되는데 그래프를 표현하는 방법으로는 &lt;strong&gt;인접 행렬, 인접 리스트&lt;/strong&gt;가 있다.
인접 행렬은 NxN 행렬을 만들어서 i번째 노드에서 j번째 노드로 갈 수 있다면 1을 표시, 갈 수 없다면 0을 표시하는 것이 일반적이다.
인접 리스트의 i번째 원소는 i번째 노드에서 갈 수 있는 노드들을 담고 있다.&lt;/p&gt;

&lt;p&gt;DFS를 파이썬으로 나타낸 코드는 다음과 같다. 시간복잡도는 인접 리스트로 나타냈을 때 $O(V + E)$에 해당한다. (인접 행렬은 $O(V^{2})$)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# 인접 리스트
graph = [
    [1, 2],
    [0, 3],
    [0],
    [3]
]
# 방문 여부
visited = [False] * len(graph)
stack = []


def dfs(i, visited, stack):
    stack.append(i)
    visited[i] = True
    for j in graph[i]:
        if not visited[j]:
            dfs(j, visited, stack)


dfs(0, visited, stack)
print(*stack) # 0 1 3 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;bfs--&quot;&gt;BFS(너비 우선 탐색)&lt;/h1&gt;

&lt;p&gt;BFS를 수행할 때는 선입선출의 특성을 띠는 큐 자료구조를 사용한다. BFS의 중요한 특징은 한 노드에서 다른 노드로 가는 최단거리를 항상 구한다는 것이다.&lt;/p&gt;

&lt;p&gt;BFS를 파이썬으로 나타낸 코드는 다음과 같다. 시간복잡도는 인접 리스트로 나타냈을 때 $O(V + E)$에 해당한다. (인접 행렬은 $O(V^{2})$)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque


# 인접 리스트
graph = [
    [1, 2],
    [0, 3],
    [0],
    [3]
]
# 방문 여부
visited = [False] * len(graph)
stack = []


def bfs(start, visited, stack):
    q = deque([start])
    while q:
        now = q.popleft()
        visited[now] = True
        stack.append(now)
        for j in graph[now]:
            if not visited[j]:
                q.append(j)
    

bfs(0, visited, stack)
print(*stack) # 0 1 2 3
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 13 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data%20structure/2021/02/13/DFS,-BFS.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data%20structure/2021/02/13/DFS,-BFS.html</guid>
        
        <category>graph</category>
        
        <category>dfs</category>
        
        <category>bfs</category>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        
        <category>Data structure</category>
        
      </item>
    
      <item>
        <title>Heap with Python</title>
        <description>&lt;p&gt;힙이란 우선순위큐(Priority Queue)를 이진 트리로 구현한 자료구조 입니다.
힙의 삽입, 삭제 연산은 $O(\log n)$의 시간복잡도를 가집니다.&lt;/p&gt;

&lt;p&gt;힙은 파이썬 내장모듈인 &lt;code class=&quot;highlighter-rouge&quot;&gt;heapq&lt;/code&gt;를 이용해서 손쉽게 구현할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

arr = [4, 5, 6, 7, 9, 8, 3, 1, 2]
heapq.heapify(arr)

print(heapq.nsmallest(3, arr)) # 1 2 3
print(heapq.nlargest(3, arr)) # 7 8 9

while arr:
    print(heapq.heappop(arr)) # 1 2 3 4 5 6 7 8 9

data = [5, 4, 6, 3]
for d in data:
    heapq.heappush(arr, d)
    print(arr[0]) # 5 4 4 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;파이썬의 &lt;code class=&quot;highlighter-rouge&quot;&gt;heapq&lt;/code&gt; 모듈은 최소힙만 지원하므로 최대힙을 구현하기 위해서는 각각의 값들에 -를 붙여서 넣어주고, &lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt; 연산을 수행할 때 다시 -1을 곱해주는 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;또한 &lt;strong&gt;Key &amp;amp; Value&lt;/strong&gt; 페어를 통해 힙을 구현할 수도 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;keys = [1, 2, 3]
values = ['hello', 'python', 'world']
data = list(zip(keys, values))
h = []
for k, v in data:
    # key, value 순서대로 넣어줌
    heapq.heappush(h, (k, v))

while h:
    k, v = heapq.heappop(h)
    print(&quot;Key: %d, Value: %s&quot; % (k, v)) # Key: 1, Value: hello / Key: 2, Value: python / Key: 3, Value: world /
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 06 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data%20structure/2021/02/06/Heap.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data%20structure/2021/02/06/Heap.html</guid>
        
        <category>sorting</category>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        
        <category>Data structure</category>
        
      </item>
    
      <item>
        <title>정렬 with Python</title>
        <description>&lt;p&gt;이번 포스팅에서는 여러 정렬 기법에 대해 알아보고 파이썬으로 간단하게 구현해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;selection-sort&quot;&gt;선택 정렬(Selection Sort)&lt;/h2&gt;

&lt;p&gt;선택 정렬은 한마디로 &lt;strong&gt;Priority Queue with Unsorted Array&lt;/strong&gt;라고 할 수 있습니다.
우선순위 큐가 하나 있다고 가정해봅시다. 데이터를 삽입할 때는 항상 끝에 삽입하고,
&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt; 연산을 오름차순/내림차순으로 수행합니다. 또한 시간복잡도는 $O(n^2)$ 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_idx = i
    for j in range(i+1, len(array)):
        if array[j] &amp;lt; array[min_idx]:
            min_idx = j
    # swap
    array[min_idx], array[i] = array[i], array[min_idx]

print(array)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;insertion-sort&quot;&gt;삽입 정렬(Insertion Sort)&lt;/h2&gt;

&lt;p&gt;삽입 정렬은 선택 정렬과 반대로 &lt;strong&gt;Sorted Array&lt;/strong&gt;로 구현된 우선순위 큐입니다. 최악의 경우 시간복잡도는 선택 정렬과 동일하게 $O(n^2)$이지만 이미 정렬된 경우에는 $O(n)$에 가까울 정도로 빠릅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)-1):
    j = i+1
    while j &amp;gt;= 1 and array[j] &amp;lt; array[j-1]:
        # swap
        array[j-1], array[j] = array[j], array[j-1]
        j -= 1

print(array)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;heap-sort&quot;&gt;힙 정렬(Heap Sort)&lt;/h2&gt;

&lt;p&gt;힙 정렬은 이름과 같이 힙을 이용하여 정렬하는 방법입니다. 시간복잡도는 $O(n\log n)$에 해당합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def heap_sort(arr):
    q = []
    for a in arr:
        heapq.heappush(q, a)
    arr = []
    while q:
        arr.append(heapq.heappop(q))
    return arr

print(heap_sort(array))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;quick-sort&quot;&gt;퀵 솔트(Quick Sort)&lt;/h2&gt;

&lt;p&gt;퀵 솔트란 하나의 피봇을 정해서 피봇보다 작은 값들 - 피봇 - 피봇보다 큰 값들 순으로 오도록 하는 알고리즘입니다. 퀵 솔트의 구현에서는 대부분 재귀함수를 사용합니다. 시간 복잡도는 보통 $O(n \log n)$이지만 최악의 경우엔 $O(n^2)$이 되기도 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    if len(array) &amp;lt;= 1:
        return array

    pivot = array[0]
    array = array[1:]

    left_partition = [x for x in array if x &amp;lt;= pivot]
    right_partition = [x for x in array if x &amp;gt; pivot]

    return quick_sort(left_partition) + [pivot] + quick_sort(right_partition)

print(quick_sort(array))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;merge-sort&quot;&gt;합병 정렬(Merge Sort)&lt;/h2&gt;

&lt;p&gt;마지막으로 살펴볼 정렬 기법은 합병 정렬입니다. 합병 정렬은 어떤 경우에도 $O(n \log n)$의 성능을 보장하지만 대부분의 경우에 퀵 정렬보다 느리다고 합니다. 또한 합병 정렬은 &lt;strong&gt;Divide and Conquer&lt;/strong&gt;의 대표적인 알고리즘 중 하나입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def merge(lst1, lst2):
    n1, n2 = len(lst1), len(lst2)
    i = j = 0
    lst = []
    while i &amp;lt; n1 and j &amp;lt; n2:
        if lst1[i] &amp;lt; lst2[j]:
            lst.append(lst1[i])
            i += 1
        else:
            lst.append(lst2[j])
            j += 1

    while i &amp;lt; n1:
        lst.append(lst1[i])
        i += 1
    
    while j &amp;lt; n2:
        lst.append(lst2[j])
        j += 1

    return lst

def merge_sort(arr):
    if len(arr) &amp;lt;= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

print(merge_sort(array))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 02 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data%20structure/2021/02/02/Sorting.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data%20structure/2021/02/02/Sorting.html</guid>
        
        <category>sorting</category>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        
        <category>Data structure</category>
        
      </item>
    
      <item>
        <title>Itertools 정리</title>
        <description>&lt;p&gt;내장 라이브러리인 &lt;code class=&quot;highlighter-rouge&quot;&gt;itertools&lt;/code&gt;를 이용해서 조합, 순열, 중복순열, Cartesian Product 등을 손쉽게 구현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations, permutations, combinations_with_replacement, product

data = '123'
l = combinations(data, 2)
for e in l:
    print(*e) # 12 13 23

l = permutations(data, 2)
for e in l:
    print(*e) # 12 13 21 23 31 32

l = combinations_with_replacement(data, 2)
for e in l:
    print(*e) # 11 12 13 22 23 33

l = product(data, repeat=2)
for e in l:
    print(*e) # 11 12 13 21 22 23 31 32 33
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/python/2021/01/30/Itertools.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/python/2021/01/30/Itertools.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>스택, 큐 with Python</title>
        <description>&lt;p&gt;이번 포스팅에서는 스택, 큐에 대한 개념을 알아보고 파이썬으로 간단하게 구현해보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;스택&lt;/h1&gt;

&lt;p&gt;스택은 &lt;strong&gt;LIFO&lt;/strong&gt;(후입선출)의 특성을 가진 자료구조입니다. 시간복잡도는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;삽입: $O(1)$&lt;/li&gt;
  &lt;li&gt;삭제: $O(1)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파이썬에서는 다른 라이브러리를 쓸 필요없이 기본 자료형인 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;를 활용하여 삽입 및 삭제 연산을 수행할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;arr = [1, 2, 3, 4, 5]
stack = []

# 삽입
for a in arr:
    stack.append(a)
print(stack)

# 삭제
while stack:
    print(stack.pop())
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;큐&lt;/h1&gt;

&lt;p&gt;큐는 기본적으로 &lt;strong&gt;FIFO&lt;/strong&gt;(선입선출)의 특성을 띄는 자료구조입니다. 시간복잡도는 앞서 설명한 스택과 동일합니다.&lt;/p&gt;

&lt;p&gt;주의해야할 점은 스택과 다르게 파이썬의 기본 자료구조인 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;를 사용해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop(0)&lt;/code&gt;을 통해 삭제연산을 수행하면 시간복잡도가 $O(n)$이 된다는 것입니다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;를 쓰기보다는 파이썬에서는 내장 모듈인 &lt;code class=&quot;highlighter-rouge&quot;&gt;collections&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;deque&lt;/code&gt;을 쓰면 간단하게 구현할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

q = deque()

# 삽입
arr = [1, 2, 3, 4, 5]
for a in arr:
    q.append(a)

# peek
print(q[0])

# pop
# popleft 말고 pop을 쓰면 선입선출
while q:
    print(q.popleft())
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data%20structure/2021/01/28/Stack,-Queue.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data%20structure/2021/01/28/Stack,-Queue.html</guid>
        
        <category>stack</category>
        
        <category>queue</category>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        
        <category>Data structure</category>
        
      </item>
    
  </channel>
</rss>
