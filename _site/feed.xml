<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 01 Mar 2021 01:28:26 +0900</pubDate>
    <lastBuildDate>Mon, 01 Mar 2021 01:28:26 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Graph Theory with Python</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;서로소 집합&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# 원소가 속한 집합 찾기
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합 merge
def union(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a &amp;lt; b:
        parent[b] = a
    else:
        parent[a] = b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;사이클 판별&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;for i in range(num_edges):
    a, b = map(int, input().split())
    if find_parent(parent, a) == find_parent(parent, b):
        cycle = True
        print(&quot;Cycle&quot;)
    else:
        union(parent, a, b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;minimum-spanning-tree&quot;&gt;크루스칼 알고리즘: Minimum Spanning Tree&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시간 복잡도: $O(E \log {E})$&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;res = 0
edges.sort()
for e in edges:
    cost, a, b = e
    # not cycle
    if find_parent(parent, a) != find_parent(parent, b):
        union(parent, a, b)
        res += cost
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;위상 정렬&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시간 복잡도: $O(V + E)$&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def topological_sort():
    result = []
    q = deque()

    # 진입차수가 0인 노드들 큐에 삽입
    for i in range(1, v+1):
        if indegree[i] == 0:
            q.append(i)

    while q:
        now = q.popleft()
        result.append(now)
        for i in graph[now]:
            indegree[i] -= 1
            # 진입차수가 0이 된다면
            if indegree[i] == 0:
                q.append(i)
    
    return result
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data-structure/2021/02/28/GraphTheory.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data-structure/2021/02/28/GraphTheory.html</guid>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        <category>graph</category>
        
        <category>shortest-path</category>
        
        
        <category>Data-Structure</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 사이클 게임</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem20040&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20040&quot;&gt;백준 20040번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
parent = [i for i in range(n)]


def find_parent(x):
    if parent[x] != x:
        parent[x] = find_parent(parent[x])
    return parent[x]

def union(a, b):
    a = find_parent(a)
    b = find_parent(b)
    if a &amp;lt; b:
        parent[b] = a 
    else:
        parent[a] = b


res = 0
for i in range(1, m+1):
    a, b = map(int, input().split())
    if find_parent(a) == find_parent(b):
        if res == 0:
            res = i
    else:
        union(a, b)

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/28/BOJ-20040.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/28/BOJ-20040.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 우주신과의 교감</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1774&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1774&quot;&gt;백준 1774번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import math

n, m = map(int, input().split())
parent = [i for i in range(n+1)]
vertex = [(-1, -1)]
for i in range(1, n+1):
    x, y = map(int, input().split())
    vertex.append((x, y))

edges = set()
for _ in range(m):
    x, y = map(int, input().split())
    x, y = min(x, y), max(x, y)
    edges.add((x, y, 0))
    
for i in range(1, n+1):
    for j in range(i+1, n+1):
        if (i, j, 0) in edges:
            continue
        x1, y1 = vertex[i]
        x2, y2 = vertex[j]
        d = math.sqrt((x1-x2) ** 2 + (y1-y2) ** 2)
        edges.add((i, j, d))


def find_parent(x):
    if parent[x] != x:
        parent[x] = find_parent(parent[x])
    return parent[x]

def union(a, b):
    a = find_parent(a)
    b = find_parent(b)
    parent[a] = b


edges = sorted(edges, key=lambda x: x[2])
res = 0
for i, j, c in edges:
    if find_parent(i) != find_parent(j):
        union(i, j)
        res += c

print(&quot;%.2f&quot; % res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/28/BOJ-1774.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/28/BOJ-1774.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 집합의 표현</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1717&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1717&quot;&gt;백준 1717번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
parent = [i for i in range(n+1)]


def find_parent(x):
    if parent[x] != x:
        parent[x] = find_parent(parent[x])
    return parent[x]

def union(a, b):
    a = find_parent(a)
    b = find_parent(b)
    if a &amp;lt; b:
        parent[b] = a
    else:
        parent[a] = b

if __name__=='__main__':
    import sys

    # 이렇게 설정해줘야 RecursionError가 나지 않는다.
    sys.setrecursionlimit(100000)

    res = []
    for _ in range(m):
        t, a, b = map(int, input().split())
        if t == 0:
            union(a, b)
        else:
            if find_parent(a) == find_parent(b):
                res.append(&quot;YES&quot;)
            else:
                res.append(&quot;NO&quot;)

    print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/28/BOJ-1717.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/28/BOJ-1717.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 최소 스패닝 트리</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1197&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1197&quot;&gt;백준 1197번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;v, e = map(int, input().split())
parent = [i for i in range(v+1)]
edges = []
for _ in range(e):
    a, b, c = map(int, input().split())
    edges.append((a, b, c))
edges.sort(key=lambda x: x[2])


def find_parent(x):
    if parent[x] != x:
        parent[x] = find_parent(parent[x])
    return parent[x]

def union(a, b):
    a = find_parent(a)
    b = find_parent(b)
    parent[b] = a


res = 0
for a, b, c in edges:
    if find_parent(a) != find_parent(b):
        union(a, b)
        res += c

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/28/BOJ-1197.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/28/BOJ-1197.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>Shortest Path with Python</title>
        <description>&lt;p&gt;오늘은 파이썬을 이용해 weighted graph(가중치가 있는 그래프)에서 최단 경로를 찾는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;가중치가 없는 그래프라면 &lt;strong&gt;BFS&lt;/strong&gt;를 통해 최단 경로를 손쉽게 구할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;다익스트라 알고리즘&lt;/h1&gt;

&lt;p&gt;다익스트라 알고리즘은 한 노드에서 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘입니다.
다익스트라는 기본적으로 그리디 알고리즘의 한 종류로, 방문하지 않은 노드 중 가장 가까운 노드를 통해 갈 수 있는 경로를 개선합니다.&lt;/p&gt;

&lt;p&gt;다익스트라 알고리즘을 사용할 때는 시간복잡도를 개선하기 위해 힙 자료구조를 사용하고, 시간 복잡도는 $O(E \log {V})$가 됩니다.&lt;/p&gt;

&lt;p&gt;파이썬으로 간단하게 구현하면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq


# weighted graph
graph = [
    [0, 10, 20],
    [2, 0, 3],
    [10, 4, 0]
]
INF = int(1e9)


def dijkstra(start, graph):
    distance = [INF for _ in range(len(graph))]
    distance[start] = 0
    q = []
    heapq.heappush(q, (0, start)) # 거리, 노드
    while q:
        dist, now = heapq.heappop(q)
        # 이미 처리된 노드
        if distance[now] &amp;lt; dist:
            continue
        for i in range(len(graph)):
            if dist+graph[now][i] &amp;lt; distance[i]:
                distance[i] = dist+graph[now][i]
                heapq.heappush(q, (distance[i], i))
    return distance


print(dijkstra(0, graph)) # 0 10 13
print(dijkstra(1, graph)) # 2 0 3
print(dijkstra(2, graph)) # 6 4 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;플로이드 워셜 알고리즘&lt;/h1&gt;

&lt;p&gt;다음은 모든 지점에서 다른 모든 지점으로 가는 최단 경로를 구해주는 플로이드 워셜 알고리즘에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;플로이드 워셜 알고리즘의 시간복잡도는 $O(V^{3})$이라, 일반적인 코딩 테스트 환경에서는 정점의 수가 1000개 이하인 경우만 가능합니다.&lt;/p&gt;

&lt;p&gt;파이썬으로 구현한 코드는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# weighted graph
INF = int(1e9)
graph = [
    [0, 4, INF, 6],
    [3, 0, 7, INF],
    [5, INF, 0, 4],
    [INF, INF, 2, 0]
]
n = len(graph)

for k in range(n):
    for i in range(n):
        for j in range(n):
            graph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j])

print(*graph, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data-structure/2021/02/27/ShortestPath.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data-structure/2021/02/27/ShortestPath.html</guid>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        <category>graph</category>
        
        <category>shortest-path</category>
        
        
        <category>Data-Structure</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 문자열 압축</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons60057&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/60057&quot;&gt;프로그래머스 60057번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def compress(s, n):
    i = 0
    lst = []
    while i &amp;lt; len(s):
        lst.append(s[i:i+n])
        i += n
    string = ''
    prev = lst[0]
    cnt = 1
    for i in range(1, len(lst)):
        if lst[i] != prev:
            string += prev if cnt == 1 else (str(cnt)+prev)
            prev = lst[i]
            cnt = 1
        else:
            cnt += 1
        # 맨마지막인 경우에
        if i == len(lst)-1:
            string += prev if cnt == 1 else (str(cnt)+prev)
    return len(string)

def solution(s):
    answer = len(s)
    for i in range(1, len(s)):
        tmp = compress(s, i)
        if tmp &amp;lt; answer:
            answer = tmp
    return answer
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/27/PR-60057.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/27/PR-60057.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 뱀</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem3190&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/3190&quot;&gt;백준 3190번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
k = int(input())
apples = set()
for _ in range(k):
    x, y = map(int, input().split())
    apples.add((x, y))
m = int(input())
times = []
for _ in range(m):
    t, lr = input().split()
    times.append((int(t), lr))


def rotate(d, lr):
    # 왼쪽으로 90도 회전
    if lr == 'L':
        return (d - 1) % 4
    # 오른쪽으로 90도 회전
    else:
        return (d + 1) % 4


# 동/서/남/북: [dx, dy]
direcs = {0: [0, 1], 1: [1, 0], 2: [0, -1], 3: [-1, 0]}

res = 0
x = y = 1 # 현재 위치
d = 0 # 현재는 동쪽을 보고 있다
tail = (1, 1)
body = [tail]

while True:
    res += 1
    dx, dy = direcs[d] 
    nx, ny = x+dx, y+dy
    # 벽에 부딪힘
    if nx &amp;lt; 1 or nx &amp;gt; n or ny &amp;lt; 1 or ny &amp;gt; n:
        break
    # 자기 몸에 부딪힘
    if (nx, ny) in body:
        break
    if (nx, ny) in apples:
        body.append((nx, ny))
        apples.remove((nx, ny))
    else:
        body.append((nx, ny))
        body = body[1:] # 꼬리제거
    x, y = nx, ny
    if times and times[0][0] == res:
        d = rotate(d, times[0][1])
        times = times[1:]

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/27/BOJ-3190.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/27/BOJ-3190.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 최단경로</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1753&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1753&quot;&gt;백준 1753번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

v, e = map(int, input().split())
k = int(input())
INF = int(1e9)
edges = {}
for _ in range(e):
    u, v_, w = map(int, input().split())
    edges[(u, v_)] = min(edges.get((u, v_), INF), w)

graph = [[] for _ in range(v+1)]
for u, v_ in edges:
    w = edges[(u, v_)]
    graph[u].append((v_, w))


def dijkstra(start):
    q = []
    distance = [INF for _ in range(v+1)]
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:
        dist, now = heapq.heappop(q)
        if distance[now] &amp;lt; dist:
            continue
        for i, c in graph[now]:
            cost = dist + c
            if cost &amp;lt; distance[i]:
                distance[i] = cost
                heapq.heappush(q, (cost, i))
    return distance


res = dijkstra(k)
for i in range(1, v+1):
    if res[i] == INF:
        print(&quot;INF&quot;)
    else:
        print(res[i])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;adjacency matrix로 풀면 메모리 초과가 나고, adjacency list로 풀어야 한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/27/BOJ-1753.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/27/BOJ-1753.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 특정한 최단경로</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1504&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1504&quot;&gt;백준 1504번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

n, e = map(int, input().split())
INF = int(1e9)
graph = [[] for _ in range(n+1)]
for _ in range(e):
    a, b, c = map(int, input().split())
    graph[a].append((b, c))
    graph[b].append((a, c))
v1, v2 = map(int, input().split())

def dijkstra(start, graph):
    distance = [INF for _ in range(n+1)]
    q = []
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:
        dist, now = heapq.heappop(q)
        if distance[now] &amp;lt; dist:
            continue
        for v, c in graph[now]:
            cost = dist + c
            if cost &amp;lt; distance[v]:
                distance[v] = cost
                heapq.heappush(q, (cost, v))
    return distance

# 1 -&amp;gt; v1 -&amp;gt; v2 -&amp;gt; n
res1 = dijkstra(1, graph)[v1]+dijkstra(v1, graph)[v2]+dijkstra(v2, graph)[n]
# 1 -&amp;gt; v2 -&amp;gt; v1 -&amp;gt; n
res2 = dijkstra(1, graph)[v2]+dijkstra(v2, graph)[v1]+dijkstra(v1, graph)[n]
res = min(res1, res2)
if res &amp;gt;= INF:
    print(-1)
else:
    print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/27/BOJ-1504.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/27/BOJ-1504.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
