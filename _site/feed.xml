<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 30 Jan 2021 20:43:29 +0900</pubDate>
    <lastBuildDate>Sat, 30 Jan 2021 20:43:29 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Itertools 정리</title>
        <description>&lt;p&gt;내장 라이브러리인 &lt;code class=&quot;highlighter-rouge&quot;&gt;itertools&lt;/code&gt;를 이용해서 조합, 순열, 중복순열, Cartesian Product 등을 손쉽게 구현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations, permutations, combinations_with_replacement, product

data = '123'
l = combinations(data, 2)
for e in l:
    print(*e) # 12 13 23

l = permutations(data, 2)
for e in l:
    print(*e) # 12 13 21 23 31 32

l = combinations_with_replacement(data, 2)
for e in l:
    print(*e) # 11 12 13 22 23 33

l = product(data, repeat=2)
for e in l:
    print(*e) # 11 12 13 21 22 23 31 32 33
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/python/2021/01/30/Itertools.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/python/2021/01/30/Itertools.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - N-Queen</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem9663&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9663&quot;&gt;백준 9663번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
cnt = 0


def nqueen(arr):
    global cnt
    # 새로운 행 번호
    row = len(arr)
    if row == n:
        cnt += 1
        return

    for i in range(n):
        # 이미 있는 열
        if i in arr:
            continue
        flag = True
        # j번째 행, j번째 행에 해당하는 열 번호는 item
        for j, item in enumerate(arr):
            # 대각선
            if abs(i-item) == abs(row-j):
                flag = False
                break
        if flag:
            arr.append(i)
            nqueen(arr)
            arr.pop()
        

nqueen([])

print(cnt)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-9663.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-9663.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - N과 M(1)(2)(3)</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem15649&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15649&quot;&gt;백준 15649번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = [i for i in range(1, n+1)]
answer = []


def combinations(arr, s):
    global answer
    if len(s) == m:
        # shallow copy
        answer.append(s[:])
        return

    for e in arr:
        if e not in s:
            s.append(e)
            combinations(arr, s)
            s.pop()


combinations(arr, [])

for a in answer:
    print(*a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전형적인 백트랙킹 문제라고 하는데 백트랙킹이 뭔지 몰라서 찾아보니 완전탐색처럼 모든 경우를 탐색하지만 중간 중간에 조건에 맞지 않는 케이스를 가지치기하여 탐색시간을 줄이는 기법이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem15650&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15650&quot;&gt;백준 15650번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = [i for i in range(1, n+1)]
answer = []


def combinations(arr, s):
    global answer
    if len(s) == m:
        # shallow copy
        answer.append(s[:])
        return

    for e in arr:
        if len(s) == 0 or (s and e &amp;gt; s[-1]):
            s.append(e)
            combinations(arr, s)
            s.pop()


combinations(arr, [])

for a in answer:
    print(*a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1)과 거의 유사하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;len(s) == 0 or (s and e &amp;gt; s[-1])&lt;/code&gt;의 조건을 추가해서 오름차순이라는 조건과 중복이 없다는 조건을 만족할 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem15651&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15651&quot;&gt;백준 15651번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = [i for i in range(1, n+1)]
answer = []


def combinations(arr, s):
    global answer
    if len(s) == m:
        # shallow copy
        answer.append(s[:])
        return

    for e in arr:
        s.append(e)
        combinations(arr, s)
        s.pop()


combinations(arr, [])

for a in answer:
    print(*a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 조건도 넣어주지 않으면 중복수열을 구할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-15649.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-15649.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 스타트와 링크</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14889&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14889&quot;&gt;백준 14889번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

n = int(input())
arr = [[0] * (n+1)]
for _ in range(n):
    arr.append([0] + list(map(int, input().split())))
whole = set(range(1,  n+1))
comb = list(combinations(whole, n//2))
# 중복되는 경우 제외
comb = comb[:len(comb)//2]

res = int(1e9)
for start_ in comb:
    start = set(start_)
    link = whole - start
    val1 = 0
    val2 = 0
    # 스타트 팀원들에 대해서
    for m in start:
        # Sii는 항상 0이므로 상관 없음
        for e in start:
            val1 += arr[m][e]
    # 링크 팀원들에 대해서
    for m in link:
        for e in link:
            val2 += arr[m][e]
    res = min(res, abs(val1-val2))

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;combinations&lt;/code&gt;를 통해 팀을 두개로 가른 다음 모든 경우에 대해 완전 탐색을 하면 된다.&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-14889.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-14889.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 카펫</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42842&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42842&quot;&gt;프로그래머스 42842번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def is_right(n, m , brown, yellow):
    # n: 세로, m: 가로
    brown_ = 2*m+2*(n-2)
    yellow_ = n*m-brown_
    return brown_ == brown and yellow_ == yellow

def solution(brown, yellow):
    # a: 세로, b: 가로
    total = brown+yellow
    arr = []
    answer = []
    # arr: total의 약수 페어를 모아놓은 배열
    for i in range(1, total//2):
        if total % i == 0:
            a, b = i, total // i
            arr.append((min(a, b), max(a, b)))
    for a, b in arr:
        if a*b == brown+yellow and is_right(a, b, brown, yellow):
            answer.extend([b, a])
            break
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에는 이중 for loop으로 코드를 짰는데 시간복잡도에서 걸리는 것을 보고 시간복잡도를 $O(n)$으로 짰다. 이 문제의 핵심은 &lt;code class=&quot;highlighter-rouge&quot;&gt;brown+yellow&lt;/code&gt;의 약수를 $O(n)$으로 짜는 알고리즘인듯하다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/PR-42842.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/PR-42842.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 기능개발</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42586&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42586&quot;&gt;프로그래머스 42586번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;문제 설명&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.&lt;/p&gt;

&lt;p&gt;먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;제한 사항&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.&lt;/li&gt;
  &lt;li&gt;작업 진도는 100 미만의 자연수입니다.&lt;/li&gt;
  &lt;li&gt;작업 속도는 100 이하의 자연수입니다.&lt;/li&gt;
  &lt;li&gt;배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;입출력 예&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;progresses&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;speeds&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;return&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[93, 30, 55]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[1, 30, 5]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[2, 1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[95, 90, 99, 99, 80, 99]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[1, 1, 1, 1, 1, 1]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[1, 3, 2]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예시설명&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;입출력 예 #1
첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.
두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.
세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.&lt;/p&gt;

&lt;p&gt;따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.&lt;/p&gt;

&lt;p&gt;입출력 예 #2
모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.&lt;/p&gt;

&lt;p&gt;따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

def solution(progresses, speeds):
    # popleft: O(1)를 위해 deque로 바꿔준다.
    progresses = deque(progresses)
    speeds = deque(speeds)
    answer = []
    while progresses:
        while progresses[0] &amp;lt; 100:
            progresses = deque(map(lambda x, y:  x+y, progresses,
                              speeds))
        cnt = 0
        # 배포가 가능한 것들을 차례대로 배포
        while progresses and progresses[0] &amp;gt;= 100:
            progresses.popleft()
            speeds.popleft()
            cnt += 1
        answer.append(cnt)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;큐 구조를 이용해서 풀 수 있는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/PR-42586.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/PR-42586.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 주식가격</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42584languagepython3&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42584?language=python3&quot;&gt;프로그래머스 42584번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;문제 설명&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;제한 사항&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.&lt;/li&gt;
  &lt;li&gt;prices의 길이는 2 이상 100,000 이하입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;입출력 예&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;prices&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;return&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[1, 2, 3, 2, 3]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[4, 3, 1, 1, 0]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;입출력 예 설명&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.&lt;/li&gt;
  &lt;li&gt;2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.&lt;/li&gt;
  &lt;li&gt;3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.&lt;/li&gt;
  &lt;li&gt;4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.&lt;/li&gt;
  &lt;li&gt;5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(틀린 풀이)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

def solution(prices):
    answer = [0] * len(prices)
    for i in range(len(prices)-1):
        prices_ = deque(prices[i:])
        p = prices[i]
        cnt = 0
        while prices_ and prices_[0] &amp;gt;= p:
            cnt += 1
            prices_.popleft()
        # 남아있는 경우
        if prices_:
            answer[i] = cnt
        # 끝까지 안떨어진 경우
        else:
            answer[i] = cnt-1
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 풀었더니 시간 복잡도가 $O(n^2)$이 되어서 효율성 테스트에서 틀려버리고 말았다.&lt;/p&gt;

&lt;p&gt;그래서 &lt;a href=&quot;https://gurumee92.tistory.com/170&quot;&gt;링크&lt;/a&gt;의 풀이법을 참조했다.&lt;/p&gt;

&lt;p&gt;(맞는 풀이)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(prices):
    answer = [0] * len(prices)
    stack = []
    # i: 현재 시간
    for i in range(len(prices)):
        while stack and prices[i] &amp;lt; prices[stack[-1]]:
            top = stack.pop()
            answer[top] = i-top
        stack.append(i)
    while stack:
        top = stack.pop()
        answer[top] = len(prices)-1-top
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 문제의 핵심은 스택을 사용해서 스택에 주식이 안 떨어진 &lt;strong&gt;시간&lt;/strong&gt;을 저장하는 것이다. 주식이 떨어졌을 때는 스택에서 계속 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt; 연산을 수행하면서 마지막 시간을 체크해야한다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/PR-42584.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/PR-42584.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 오목</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2615&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2615&quot;&gt;백준 2615번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

board = []
for _ in range(19):
    board.append(list(map(int, input().split())))

dxs = [-1, 0, 1, 1]
dys = [1, 1, 0, 1]


def bfs_main(x, y):
    return bfs(x, y, 0), bfs(x, y, 1), bfs(x, y, 2), bfs(x, y, 3)


def bfs(x, y, d):
    q = deque()
    q.append((x, y))
    cnt = 0
    while q:
        x_, y_ = q.popleft()
        cnt += 1
        nx, ny = x_+dxs[d], y_+dys[d]
        if 0 &amp;lt;= nx &amp;lt; 19 and 0 &amp;lt;= ny &amp;lt; 19 and board[nx][ny] == board[x][y]:
            q.append((nx, ny))
    # 6목을 체크해봐야 한다.
    if cnt == 5:
        nx = x-dxs[d]
        ny = y-dys[d]
        if 0 &amp;lt;= nx &amp;lt; 19 and 0 &amp;lt;= ny &amp;lt; 19 and board[x][y] == board[nx][ny]:
            cnt += 1
    return cnt


found = False
for i in range(19):
    for j in range(19):
        if not found:
            if board[i][j] == 1 and 5 in bfs_main(i, j):
                found = True
                print(1)
                print(i+1, j+1)
            elif board[i][j] == 2 and 5 in bfs_main(i, j):
                found = True
                print(2)
                print(i+1, j+1)
if not found:
    print(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;문제 자체는 어렵지 않으나 6목을 체크해야하는 걸 못봐서 많이 헤맸다.. &lt;strong&gt;dfs/bfs&lt;/strong&gt;를 사용해서 풀 수 있는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/BOJ-2615.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/BOJ-2615.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 전공책</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem16508&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16508&quot;&gt;백준 16508번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

t = input()
n = int(input())
books = []
for _ in range(n):
    a, b = input().split()
    books.append((int(a), b))


def is_possible(books):
    # 책들의 문자 카운트를 저장해놓음
    d = {}
    for _, b in books:
        for ch in b:
            d[ch] = d.get(ch, 0)+1

    cnt = 0
    for ch in t:
        if d.get(ch, 0) &amp;gt; 0:
            cnt += 1
            d[ch] -= 1
    return cnt == len(t)

res = 1e9
for i in range(1, n+1):
    comb = combinations(books, i)
    for c in comb:
        if is_possible(c):
            tmp = sum([p for p, _ in c])
            res = min(res, tmp)
            
if res == 1e9:
    print(-1)
else:
    print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;가능한 모든 경우의 수를 탐색해야하므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;combinations&lt;/code&gt; 함수를 이용했다.
이렇게 풀 수 있는 이유는 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;이 16이하이므로 시간초과에 걸리지 않기 때문이다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/BOJ-16508.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/BOJ-16508.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver4 - 퇴사</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14501&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14501&quot;&gt;백준 14501번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
t = []
p = []
for _ in range(n):
    a, b = map(int, input().split())
    t.append(a)
    p.append(b)
res = 0


def get_max(i, cur):
    global res
    if i &amp;gt;= n:
        res = max(res, cur)
        return

    # i번째 일을 할 수 있는 경우
    if i+t[i] &amp;lt;= n:
        get_max(i+t[i], cur+p[i])
    # 안하고 건너뛰는 경우
    get_max(i+1, cur)


get_max(0, 0)
print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재귀 함수를 이용한 완전탐색으로 해결할 수 있었다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/BOJ-14501.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/BOJ-14501.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
