<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 24 Feb 2021 01:29:17 +0900</pubDate>
    <lastBuildDate>Wed, 24 Feb 2021 01:29:17 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>프로그래머스 Lv3 - 자물쇠와 열쇠</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons60059&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/60059&quot;&gt;프로그래머스 60059번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import numpy as np

def rotate(m, key):
    key_ = [[0] * m for _ in range(m)]
    for i in range(m):
        for j in range(m):
            key_[j][m-i-1] = key[i][j]
    return key_

def solution(key, lock):
    answer = False
    n = len(lock)
    m = len(key)
    keys = []
    for i in range(4):
        keys.append(key)
        key = rotate(m, key)
        
    xs = []
    ys = []
    for i in range(n):
        for j in range(n):
            if lock[i][j] == 0:
                xs.append(i)
                ys.append(j)
    if not xs:
        return True
    
    x1, x2 = min(xs), max(xs)
    y1, y2 = min(ys), max(ys)

    lock = np.array(lock)[x1:x2+1, y1:y2+1]
    l1, l2 = lock.shape[0], lock.shape[1]
    
    keys_ = []
    for key in keys:
        key_arr = np.array(key)
        for i in range(key_arr.shape[0]-l1+1):
            for j in range(key_arr.shape[1]-l2+1):
                keys_.append(key_arr[i:i+l1, j:j+l2])
    
    for k in keys_:
        if k.shape != lock.shape:
            continue
        if (k == 1-lock).all():
            return True
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;행렬 연산을 쉽게 하려고 &lt;code class=&quot;highlighter-rouge&quot;&gt;numpy&lt;/code&gt; 라이브러리를 사용했다.&lt;/p&gt;
</description>
        <pubDate>Wed, 24 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/24/PR-60059.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/24/PR-60059.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 구슬탈출 2</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem13460&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13460&quot;&gt;백준 13460번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
board = []
for _ in range(n):
    board.append([ch for ch in input()])
# 공들의 위치
balls = [-1] * 2
for i in range(n):
    for j in range(m):
        if board[i][j] == 'R':
            balls[0] = [i, j]
        elif board[i][j] == 'B':
            balls[1] = [i, j]

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def move(x, y, d, board):
    while True:
        nx, ny = x+dx[d], y+dy[d]
        if board[nx][ny] != '.':
            break
        x, y = nx, ny
    if board[nx][ny] == 'O':
        x, y = nx, ny
    return x, y


def move_balls(balls, board, d):
    # 위로 이동, y좌표가 같다면 x좌표가 작은 것부터 이동
    flag1 = d == 0 and balls[0][1] == balls[1][1] and balls[0][0] &amp;gt; balls[1][0]
    # 아래로 이동, y좌표가 같다면 x좌표가 큰 것부터 이동
    flag2 = d == 1 and balls[0][1] == balls[1][1] and balls[0][0] &amp;lt; balls[1][0]
    # 왼쪽으로 이동, x좌표가 같다면 y좌표가 작은 것부터 이동
    flag3 = d == 2 and balls[0][0] == balls[1][0] and balls[0][1] &amp;gt; balls[1][1]
    # 오른쪽으로 이동, x좌표가 같다면 y좌표가 큰 것부터 이동
    flag4 = d == 3 and balls[0][0] == balls[1][0] and balls[0][1] &amp;lt; balls[1][1]
    if flag1 or flag2 or flag3 or flag4:
        bx, by = move(*balls[1], d, board)
        board[balls[1][0]][balls[1][1]] = '.' # 빈칸이 되고
        board[bx][by] = 'B' if board[bx][by] != 'O' else 'O'
        rx, ry  = move(*balls[0], d, board)
        board[balls[0][0]][balls[0][1]] = '.' # 빈칸이 되고
        board[rx][ry] = 'R' if board[rx][ry] != 'O' else 'O'
    else:
        rx, ry = move(*balls[0], d, board)
        board[balls[0][0]][balls[0][1]] = '.' # 빈칸이 되고
        board[rx][ry] = 'R' if board[rx][ry] != 'O' else 'O'
        bx, by = move(*balls[1], d, board)
        board[balls[1][0]][balls[1][1]] = '.' # 빈칸이 되고
        board[bx][by] = 'B' if board[bx][by] != 'O' else 'O'
    balls_ = [[rx, ry], [bx, by]]
    return balls_


cnt = 11


def solution(now, balls, board):
    global cnt
    if now &amp;gt;= cnt:
        return
    rx, ry = balls[0]
    bx, by = balls[1]
    if board[rx][ry] == 'O': # 성공
        cnt = min(cnt, now)
    elif board[bx][by] != 'O': # 파란 구슬이 안 빠졌을 때
        for i in range(4):
            balls_ = move_balls(balls, board, i)
            # 빨간 구슬, 파란 구슬이 다를 때만
            if balls_[0] != balls_[1]:
                solution(now+1, balls_, board)
            # 다시 돌려놓기
            x, y = balls_[0]
            board[x][y] = '.' if board[x][y] != 'O' else 'O'
            x, y = balls_[1]
            board[x][y] = '.' if board[x][y] != 'O' else 'O'
            board[rx][ry] = 'R'
            board[bx][by] = 'B'


solution(0, balls, board)

if cnt == 11:
    print(-1)
else:
    print(cnt)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 23 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/23/BOJ-13460.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/23/BOJ-13460.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold3 - 청소년 상어</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem19236&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19236&quot;&gt;백준 19236번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from copy import deepcopy

graph = [[-1] * 4 for _ in range(4)]
for i in range(4):
    tmp = list(map(int, input().split()))
    for j in range(0, 8, 2):
        graph[i][j // 2] = [tmp[j], tmp[j+1]]

moves = {1: [-1, 0], 2: [-1, -1], 3: [0, -1], 4: [1, -1],
         5: [1, 0], 6: [1, 1], 7: [0, 1], 8: [-1, 1]}
shark = [0, 0]
res = 0

def check_fish(x, y, d, shark):
    nx, ny = x+moves[d][0], y+moves[d][1]
    if nx &amp;lt; 0 or nx &amp;gt;= 4 or ny &amp;lt; 0 or ny &amp;gt;= 4 or [nx, ny] == shark:
        return [-1, -1]
    else:
        return [nx, ny]

def move_fish(graph, shark):
    order = {}
    for i in range(4):
        for j in range(4):
            if [i, j] != shark and graph[i][j][0] != 0:
                # 번호: 좌표
                order[graph[i][j][0]] = (i, j)
    order = sorted(order.items(), key=lambda x: x[0])
    order = dict(order)
    for o in order.keys():
        x, y = order[o]
        while True:
            nx, ny = check_fish(x, y, graph[x][y][1], shark)
            if nx != -1 and ny != -1:
                break
            # rotate
            graph[x][y][1] += 1
            if graph[x][y][1] &amp;gt; 8:
                graph[x][y][1] -= 8
        # 다른 물고기가 있는 칸이라면
        if graph[nx][ny][0] != 0:
            # swap
            order[graph[x][y][0]], order[graph[nx][ny][0]] = (nx, ny), (x, y)
            graph[x][y], graph[nx][ny] = graph[nx][ny], graph[x][y]
        else: # 비어있는 칸이라면
            order[graph[x][y][0]] = (nx, ny)
            graph[nx][ny] = graph[x][y]
            graph[x][y] = [0, 0]

def move_shark(now, graph, shark): # 지금까지 먹은 물고기수, 그래프, 상어 좌표
    global res
    move_fish(graph, shark)
    x, y = shark
    # 물고기 개수, 방향
    num, d = graph[x][y]
    dx, dy = moves[d]
    # 잡아 먹힘
    graph[x][y] = [0, 0]
    results = []
    for i in range(1, 4):
        nx, ny = x+dx*i, y+dy*i
        if 0 &amp;lt;= nx &amp;lt; 4 and 0 &amp;lt;= ny &amp;lt; 4 and graph[nx][ny][0] != 0:
            results.append((nx, ny))
    if results:
        for nx, ny in results:
            move_shark(now+num, deepcopy(graph), [nx, ny])
    else: # 더 이상 갈 곳이 없으므로 종료
        res = max(res, now+num)

move_shark(0, graph, shark)

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;구현이 굉장히 빡센 문제.. 연습이 많이 필요할 것 같다.&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/21/BOJ-19236.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/21/BOJ-19236.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 2048(Easy)</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem12100&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/12100&quot;&gt;백준 12100번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from copy import deepcopy
from collections import deque

n = int(input())
board = []
for _ in range(n):
    board.append(list(map(int, input().split())))


def go_up(board):
    for j in range(n):
        col = [board[i][j] for i in range(n) if board[i][j] &amp;gt; 0]
        i = 0
        new_col = deque()
        while i &amp;lt; len(col)-1:
            if col[i] == col[i+1]:
                new_col.append(col[i]+col[i+1])
                i += 2
            else:
                new_col.append(col[i])
                i += 1
        if i == len(col)-1:
            new_col.append(col[i])
        new_col = list(new_col) + [0] * (n-len(new_col))
        for i in range(n):
            board[i][j] = new_col[i]
        

def go_down(board):
    for j in range(n):
        col = [board[i][j] for i in range(n) if board[i][j] &amp;gt; 0]
        i = len(col)-1
        new_col = deque()
        while i &amp;gt; 0:
            if col[i] == col[i-1]:
                    new_col.appendleft(col[i]+col[i-1])
                    i -= 2
            else:
                new_col.appendleft(col[i])
                i -= 1
        if i == 0:
            new_col.appendleft(col[i])
        new_col = [0] * (n-len(new_col)) + list(new_col)
        for i in range(n):
            board[i][j] = new_col[i]


def go_right(board):
    for i in range(n):
        row = [x for x in board[i] if x &amp;gt; 0]
        j = len(row)-1
        new_row = deque()
        while j &amp;gt; 0:
            if row[j] == row[j-1]:
                new_row.appendleft(row[j]+row[j-1])
                j -= 2
            else:
                new_row.appendleft(row[j])
                j -= 1
        if j == 0:
            new_row.appendleft(row[j])
        new_row = [0] * (n-len(new_row)) + list(new_row)
        for j in range(n):
            board[i][j] = new_row[j]


def go_left(board):
    for i in range(n):
        row = [x for x in board[i] if x &amp;gt; 0]
        j = 0
        new_row = deque()
        while j &amp;lt; len(row)-1:
            if row[j] == row[j+1]:
                new_row.append(row[j]+row[j+1])
                j += 2
            else:
                new_row.append(row[j])
                j += 1
        if j == len(row)-1:
            new_row.append(row[j])
        new_row = list(new_row) + [0] * (n-len(new_row))
        for j in range(n):
            board[i][j] = new_row[j]

res = 0

def go(cnt, board):
    global res
    if cnt == 5:
        for i in range(n):
            for j in range(n):
                res = max(res, board[i][j])
        return
    for i in range(4):
        board_ = deepcopy(board)
        if i == 0:
            go_up(board_)
            go(cnt+1, board_)
        elif i == 1:
            go_down(board_)
            go(cnt+1, board_)
        elif i == 2:
            go_right(board_)
            go(cnt+1, board_)
        elif i == 3:
            go_left(board_)
            go(cnt+1, board_)

go(0, board)

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0인 것들은 제외하고 새로운 행/열을 만든 다음에 합쳐주는게 관건이었다. 그 와중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;deque&lt;/code&gt;를 적절히 사용해야 순서가 안바뀌고 제대로 된다. 구현은 언제 풀어도 어렵다ㅠ&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/21/BOJ-12100.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/21/BOJ-12100.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold3 - 독특한 계산기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem19591&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19591&quot;&gt;백준 19591번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

x = input()
n = len(x)
pr = {'+': 0, '-': 0, '*': 1, '/': 1}
nums = []
ops = []

i = 0
while i &amp;lt; n:
    j = i
    while j &amp;lt; n and (j == 0 or x[j] not in pr.keys()):
        j += 1
    nums.append(int(x[i:j]))
    if j &amp;lt; n:
        ops.append(x[j])
    i = j + 1

nums = deque(nums)
ops = deque(ops)

def calc(op, n1, n2):
    if op == '+':
        res = n1 + n2
    elif op == '-':
        res = n1 - n2
    elif op == '*':
        res = n1 * n2
    else:
        res = int(n1 / n2)
    return res

while ops:
    if len(ops) == 1:
        op = ops.popleft()
        n1, n2 = nums.popleft(), nums.popleft()
        nums.appendleft(calc(op, n1, n2))
    else:
        op1 = ops.popleft()
        op2 = ops.pop()
        if pr[op1] &amp;gt; pr[op2] or (pr[op1] == pr[op2] and calc(op1, nums[0], nums[1]) &amp;gt;= calc(op2, nums[-2], nums[-1])):
            n1, n2 = nums.popleft(), nums.popleft()
            nums.appendleft(calc(op1, n1, n2))
            ops.append(op2)
        else:
            n2, n1 = nums.pop(), nums.pop()
            nums.append(calc(op2, n1, n2))
            ops.appendleft(op1)

print(nums[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;별로 어려운 문제는 아니었는데 문제를 잘못이해해서 $\log (N)$으로 풀어야 하는 줄 알고 헤맸다.&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/20/BOJ-19591.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/20/BOJ-19591.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - ⚾</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem17281&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17281&quot;&gt;백준 17281번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이(시간초과)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import permutations

n = int(input())
players = list(range(1, 10))
order = permutations(players, len(players))
order = [o for o in order if o[3] == 1]
results = []
for _ in range(n):
    results.append([-1] + list(map(int, input().split())))

def baseball(c, results):
    score = 0
    idx = 0
    inning = 0
    while inning &amp;lt; n:
        # 홈, 1루, 2루, 3루
        cur = [0, 0, 0, 0]
        num_out = 0
        while num_out &amp;lt; 3:
            # 현재 점수
            now = results[inning][c[idx]]
            if now == 0:
                num_out += 1
            else:
                cur[0] += 1
                # 선수들의 이동을 저장하는 배열
                add = [0, 0, 0, 0]
                for i in range(4):
                    if i + now &amp;gt;= 4:
                        score += cur[i]
                    else:
                        add[i + now] += cur[i]
                    add[i] -= cur[i]
                for i in range(4):
                    cur[i] += add[i]
            idx = (idx + 1) % 9
        inning += 1
    return score

score = 0
for o in order:
    score = max(score, baseball(o, results))

print(score)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;분명히 맞는 알고리즘인데 왜 시간초과가 나지 하고 살펴보니 파이썬으로 풀면 시간초과가 날 수 밖에 없는 문제였다. 배열을 쓰지말고 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;를 사용해야 시간초과에 안걸린다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import permutations

n = int(input())
players = list(range(1, 10))
order = permutations(players, len(players))
order = [o for o in order if o[3] == 1]
results = []
for _ in range(n):
    results.append([-1] + list(map(int, input().split())))

def baseball(c, results):
    score = 0
    idx = 0
    inning = 0
    while inning &amp;lt; n:
        # 홈, 1루, 2루, 3루
        b0, b1, b2, b3 = 0, 0, 0, 0
        num_out = 0
        while num_out &amp;lt; 3:
            # 현재 점수
            now = results[inning][c[idx]]
            if now == 0:
                num_out += 1
            else:
                b0 += 1
                if now == 1:
                    score += b3
                    b0, b1, b2, b3 = 0, b0, b1, b2
                elif now == 2:
                    score += (b2 + b3)
                    b0, b1, b2, b3 = 0, 0, b0, b1
                elif now == 3:
                    score += (b1 + b2 + b3)
                    b0, b1, b2, b3 = 0, 0, 0, b0
                elif now == 4:
                    score += (b0 + b1 + b2 + b3)
                    b0 = b1 = b2 = b3 = 0
            idx = (idx + 1) % 9
        inning += 1
    return score

score = 0
for o in order:
    score = max(score, baseball(o, results))

print(score)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 20 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/20/BOJ-17281.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/20/BOJ-17281.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 프렌즈4블록</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons17679&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/17679&quot;&gt;프로그래머스 17679번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def erase(m, n, board):
    s = set()
    for i in range(m-1):
        for j in range(n-1):
            # 이미 빈 상태
            if board[i][j] == 0:
                continue
            if board[i][j] == board[i+1][j] == board[i][j+1] == board[i+1][j+1]:
                s |= {(i, j), (i+1, j), (i, j+1), (i+1, j+1)}
    for i, j in s:
        board[i][j] = 0
    return len(s)

def go_down(m, n, board):
    for j in range(n):
        for i in range(m-1, -1, -1):
            if board[i][j] != 0:
                continue
            k = i
            while k &amp;gt;= 0 and board[k][j] == 0:
                k -= 1
            if k &amp;gt;= 0:
                board[i][j], board[k][j] = board[k][j], board[i][j]

def solution(m, n, board):
    board = [list(b) for b in board]
    answer = 0
    while True:
        tmp = erase(m, n, board)
        # 새로 지울게 없다면
        if tmp == 0:
            break
        answer += tmp
        go_down(m, n, board)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;애니팡..&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/PR-17679.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/PR-17679.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 인내의 도미노 장인 호석</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem20165&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20165&quot;&gt;백준 20165번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m, r = map(int, input().split())
domino = [list(map(int, input().split())) for _ in range(n)]
domino_origin = [[-1] * m for _ in range(n)]
for i in range(n):
    for j in range(m):
        domino_origin[i][j] = domino[i][j]
attack = []
defence = []
for i in range(2*r):
    if i % 2 == 0:
        x, y, d = input().split()
        attack.append((int(x)-1, int(y)-1, d))
    else:
        x, y = map(int, input().split())
        defence.append((x-1, y-1))
        
direcs = {&quot;E&quot;: [0, 1], &quot;W&quot;: [0, -1], &quot;S&quot;: [1, 0], &quot;N&quot;: [-1, 0]}

def hit(x, y, d):
    global cnt
    if x &amp;lt; 0 or x &amp;gt;= n or y &amp;lt; 0 or y &amp;gt;= m:
        return
    k = domino[x][y]
    dx, dy = direcs[d]
    for i in range(1, k):
        nx, ny = x+i*dx, y+i*dy
        hit(nx, ny, d)
    # 도미노 쓰러뜨리기
    if domino[x][y] != 0:
        cnt += 1
        domino[x][y] = 0

def up(x, y):
    if x &amp;lt; 0 or x &amp;gt;= n or y &amp;lt; 0 or y &amp;gt;= m:
        return
    domino[x][y] = domino_origin[x][y]

cnt = 0
for i in range(r):
    hit(*attack[i])
    up(*defence[i])

for i in range(n):
    domino[i] = ['S' if e != 0 else 'F' for e in domino[i]]

print(cnt)
for i in range(n):
    print(*domino[i])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/BOJ-20165.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/BOJ-20165.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 미세먼지 안녕!</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem17144&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17144&quot;&gt;백준 17144번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;r, c, t = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(r)]
c1 = -1
for i in range(r):
    if graph[i][0] == -1:
        c1 = i
        break
c2 = c1+1

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dust():
    q = []
    for i in range(r):
        for j in range(c):
            if graph[i][j] &amp;gt; 0:
                q.append((i, j))
    infected = dict()
    deleted = dict()
    for x, y in q:
        cnt = 0
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; r and 0 &amp;lt;= ny &amp;lt; c and graph[nx][ny] != -1:
                cnt += 1
                infected[(nx, ny)] = infected.get((nx, ny), 0) + graph[x][y] // 5
        deleted[(x, y)] = cnt * (graph[x][y] // 5)
    for x, y in infected:
        graph[x][y] += infected[(x, y)]
    for x, y in deleted:
        graph[x][y] -= deleted[(x, y)]

def clean(xc, up):
    # 공기청정기 위/아래
    if up:
        ds = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    else:
        ds = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    x, y = xc, 1
    i = 0
    s = set()
    while True:
        nx, ny = x+ds[i][0], y+ds[i][1]
        if nx == xc and y == 0:
            break
        # 가장자리라면
        if nx &amp;lt; 0 or nx &amp;gt;= r or ny &amp;lt; 0 or ny &amp;gt;= c:
            i += 1
        else:
            s.add((nx, ny, graph[x][y]))
            x, y = nx, ny
    graph[xc][1] = 0
    for x, y, val in s:
        graph[x][y] = val

for _ in range(t):
    dust()
    clean(c1, True)
    clean(c2, False)

res = 0
for i in range(r):
    for j in range(c):
        if graph[i][j] &amp;gt; 0:
            res += graph[i][j]

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;쉬울 것 같았는데 생각보다 구현이 빡셌다.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/BOJ-17144.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/BOJ-17144.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 치킨 배달</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem15686&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15686&quot;&gt;백준 15686번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

n, m = map(int, input().split())
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))
chickens = [(i, j) for j in range(n) for i in range(n) if graph[i][j] == 2]
houses = [(i, j) for j in range(n) for i in range(n) if graph[i][j] == 1]

def cal_dist(h: tuple, c: tuple):
    return abs(h[0]-c[0])+abs(h[1]-c[1])

def cal_min_dist(h: tuple, cs: list):
    min_dist = int(1e9)
    for c in cs:
        min_dist = min(min_dist, cal_dist(h, c))
    return min_dist

res = int(1e9)
combs = combinations(chickens, m)
for comb in combs:
    tmp = 0
    cs = list(comb)
    for h in houses:
        tmp += cal_min_dist(h, cs)
    res = min(res, tmp)

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/BOJ-15686.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/BOJ-15686.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
