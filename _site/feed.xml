<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 04 Feb 2021 00:37:33 +0900</pubDate>
    <lastBuildDate>Thu, 04 Feb 2021 00:37:33 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>프로그래머스 Lv1 - 실패율</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42889&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42889&quot;&gt;프로그래머스 42889번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(N, stages):
    d = {i: 0 for i in range(1, N+1)}
    stages.sort()
    prev = stages[0]
    total = len(stages)
    cnt = 1
    for i in range(1, len(stages)):
        if prev not in d:
            break
        if stages[i] == prev:
            cnt += 1
        elif stages[i] != prev:
            d[prev] = cnt / total
            total -= cnt
            cnt = 1
            prev = stages[i]
        if i == len(stages)-1 and prev in d:
            d[prev] = cnt / total            
    answer = sorted(d.keys(), key=lambda x: -d[x])
    return answer
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 03 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/03/PR-42889.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/03/PR-42889.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 안테나</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18310&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18310&quot;&gt;백준 18310번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))
arr.sort()


def cal_distance(arr, mid):
    total = 0
    for a in arr:
        total += abs(arr[mid]-a)
    return total


if len(arr) % 2 == 1:
    mid = len(arr) // 2
else:
    mid1, mid2 = len(arr)//2-1, len(arr)//2
    if cal_distance(arr, mid1) &amp;gt; cal_distance(arr, mid2):
        mid = mid2
    else:
        mid = mid1 

print(arr[mid])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 03 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/03/BOJ-18310.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/03/BOJ-18310.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 카드 정렬하기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1715&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1715&quot;&gt;백준 1715번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

n = int(input())
q = []
for i in range(n):
    a = int(input())
    heapq.heappush(q, a)

res = 0
while len(q) &amp;gt;= 2:
    a = heapq.heappop(q)
    b = heapq.heappop(q)
    res += a+b
    heapq.heappush(q, a+b)
    
print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첨에는 그냥 array로 받고 sort해서  &lt;code class=&quot;highlighter-rouge&quot;&gt;deque&lt;/code&gt;로 풀었는데 새로운 원소가 더해질 때 그렇게 하면 최솟값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt;되지 않기 때문에 안된다.&lt;/p&gt;
</description>
        <pubDate>Wed, 03 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/03/BOJ-1715.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/03/BOJ-1715.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver4 - 국영수</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem10825&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/10825&quot;&gt;백준 10825번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = [0] * n
for i in range(n):
    name, kor, eng, mat = input().split()
    kor, eng, mat = map(int, [kor, eng, mat])
    arr[i] = (name, kor, eng, mat)

arr = sorted(arr, key=lambda x: x[0])
arr = sorted(arr, key=lambda x: -x[3])
arr = sorted(arr, key=lambda x: x[2])
arr = sorted(arr, key=lambda x: -x[1])

for a in arr:
    print(a[0])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 03 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/03/BOJ-10825.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/03/BOJ-10825.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>정렬 with Python</title>
        <description>&lt;p&gt;이번 포스팅에서는 여러 정렬 기법에 대해 알아보고 파이썬으로 간단하게 구현해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;selection-sort&quot;&gt;선택 정렬(Selection Sort)&lt;/h2&gt;

&lt;p&gt;선택 정렬은 한마디로 &lt;strong&gt;Priority Queue with Unsorted Array&lt;/strong&gt;라고 할 수 있습니다.
우선순위 큐가 하나 있다고 가정해봅시다. 데이터를 삽입할 때는 항상 끝에 삽입하고,
&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt; 연산을 오름차순/내림차순으로 수행합니다. 또한 시간복잡도는 $O(n^2)$ 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_idx = i
    for j in range(i+1, len(array)):
        if array[j] &amp;lt; array[min_idx]:
            min_idx = j
    # swap
    array[min_idx], array[i] = array[i], array[min_idx]

print(array)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;insertion-sort&quot;&gt;삽입 정렬(Insertion Sort)&lt;/h2&gt;

&lt;p&gt;삽입 정렬은 선택 정렬과 반대로 &lt;strong&gt;Sorted Array&lt;/strong&gt;로 구현된 우선순위 큐입니다. 최악의 경우 시간복잡도는 선택 정렬과 동일하게 $O(n^2)$이지만 이미 정렬된 경우에는 $O(n)$에 가까울 정도로 빠릅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)-1):
    j = i+1
    while j &amp;gt;= 1 and array[j] &amp;lt; array[j-1]:
        # swap
        array[j-1], array[j] = array[j], array[j-1]
        j -= 1

print(array)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;heap-sort&quot;&gt;힙 정렬(Heap Sort)&lt;/h2&gt;

&lt;p&gt;힙 정렬은 이름과 같이 힙을 이용하여 정렬하는 방법입니다. 시간복잡도는 $O(n\log n)$에 해당합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def heap_sort(arr):
    q = []
    for a in arr:
        heapq.heappush(q, a)
    arr = []
    while q:
        arr.append(heapq.heappop(q))
    return arr

print(heap_sort(array))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;quick-sort&quot;&gt;퀵 솔트(Quick Sort)&lt;/h2&gt;

&lt;p&gt;퀵 솔트란 하나의 피봇을 정해서 피봇보다 작은 값들 - 피봇 - 피봇보다 큰 값들 순으로 오도록 하는 알고리즘입니다. 퀵 솔트의 구현에서는 대부분 재귀함수를 사용합니다. 시간 복잡도는 보통 $O(n \log n)$이지만 최악의 경우엔 $O(n^2)$이 되기도 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    if len(array) &amp;lt;= 1:
        return array

    pivot = array[0]
    array = array[1:]

    left_partition = [x for x in array if x &amp;lt;= pivot]
    right_partition = [x for x in array if x &amp;gt; pivot]

    return quick_sort(left_partition) + [pivot] + quick_sort(right_partition)

print(quick_sort(array))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;merge-sort&quot;&gt;합병 정렬(Merge Sort)&lt;/h2&gt;

&lt;p&gt;마지막으로 살펴볼 정렬 기법은 합병 정렬입니다. 합병 정렬은 어떤 경우에도 $O(n \log n)$의 성능을 보장하지만 대부분의 경우에 퀵 정렬보다 느리다고 합니다. 또한 합병 정렬은 &lt;strong&gt;Divide and Conquer&lt;/strong&gt;의 대표적인 알고리즘 중 하나입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def merge(lst1, lst2):
    n1, n2 = len(lst1), len(lst2)
    i = j = 0
    lst = []
    while i &amp;lt; n1 and j &amp;lt; n2:
        if lst1[i] &amp;lt; lst2[j]:
            lst.append(lst1[i])
            i += 1
        else:
            lst.append(lst2[j])
            j += 1

    while i &amp;lt; n1:
        lst.append(lst1[i])
        i += 1
    
    while j &amp;lt; n2:
        lst.append(lst2[j])
        j += 1

    return lst

def merge_sort(arr):
    if len(arr) &amp;lt;= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

print(merge_sort(array))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 02 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data-structure/2021/02/02/Sorting.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data-structure/2021/02/02/Sorting.html</guid>
        
        <category>sorting</category>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        
        <category>Data-Structure</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 스도쿠</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2239&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2239&quot;&gt;백준 2239번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from copy import deepcopy

board = []
for _ in range(9):
    string = input()
    tmp = [int(x) for x in string]
    board.append(tmp)
res = []


def is_possible(board, x, y):
    num = board[x][y]
    for i in range(9):
        # 가로로 같은지
        if i != y and num == board[x][i]:
            return False
        # 세로로 같은지
        if i != x and num == board[i][y]:
            return False
    # 3x3 사각형을 본다.
    x_, y_ = x // 3, y // 3
    x_, y_ = 3*x_, 3*y_
    for i in range(3):
        for j in range(3):
            if x == x_+i and y == y_+j:
                continue
            if num == board[x_+i][y_+j]:
                return False
    return True

def sdoku(board, x, y):
    global res
    # 항상 사전순이므로 상관 없음
    if not res:
        if x == 9:
            res = deepcopy(board)
            return
        if board[x][y] != 0:
            if y+1 &amp;lt; 9:
                sdoku(board, x, y+1)
            else:
                sdoku(board, x+1, 0)
        else:
            for i in range(1, 10):
                board[x][y] = i
                if is_possible(board, x, y):
                    if y+1 &amp;lt; 9:
                        sdoku(board, x, y+1)
                    else:
                        sdoku(board, x+1, 0)
                board[x][y] = 0


sdoku(board, 0, 0)
for row in res:
    for col in row:
        print(col, end='')
    print()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에느 &lt;code class=&quot;highlighter-rouge&quot;&gt;res&lt;/code&gt;를 리스트 변수로 만들어서 가능한 순서대로 다 넣은 다음 sort를 했더니
시간초과가 떴다. 그런데 for문 돌아가는 걸 생각해보니 그냥 제일 첫번째 성공케이스가 그 답 자체이기 때문에 위처럼 풀 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/31/BOJ-2239.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/31/BOJ-2239.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - 계란으로 계란치기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem16987&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16987&quot;&gt;백준 16987번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
eggs = []
for _ in range(n):
    s, w = map(int, input().split())
    eggs.append([s, w])
cnt = 0


def crush(l, cur, eggs):
    global cnt
    # 가장 오른쪽 계란
    if l == n:
        cnt = max(cnt, cur)
        return
    
    if eggs[l][0] &amp;gt; 0:
        all_broken = True
        for r in range(n):
            # 손에 든 계란이거나 이미 깨진 계란
            if r == l or eggs[r][0] &amp;lt;= 0:
                continue
            all_broken = False
            eggs[l][0] -= eggs[r][1]
            eggs[r][0] -= eggs[l][1]
            cur_ = cur
            cur_ += 1 if eggs[l][0] &amp;lt;= 0 else 0
            cur_ += 1 if eggs[r][0] &amp;lt;= 0 else 0
            crush(l+1, cur_, eggs)
            eggs[l][0] += eggs[r][1]
            eggs[r][0] += eggs[l][1]
        # 다 깨진 계란
        if all_broken:
            crush(l+1, cur, eggs)
    # 손에 든 계란이 깨진 경우
    else:
        crush(l+1, cur, eggs)


crush(0, 0, eggs)
print(cnt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에 알고리즘은 맞게 짰는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;eggs&lt;/code&gt;를 deepcopy해서 처리하는 바람에 시간초과가
났었다. 코딩 테스트에서 파이썬을 쓸 때는 deepcopy는 피하도록 하자.&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/31/BOJ-16987.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/31/BOJ-16987.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 연산자 끼워넣기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14888&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14888&quot;&gt;백준 14888번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))
ops = list(map(int, input().split()))
min_val = int(1e9)
max_val = -int(1e9)


def solution(idx, ops, val):
    global min_val, max_val
    if idx == n-1:
        min_val = min(min_val, val)
        max_val = max(max_val, val)
        return

    for i in range(4):
        if ops[i] &amp;lt;= 0:
            continue
        ops[i] -= 1
        if i == 0:
            solution(idx+1, ops, val+arr[idx+1])
        elif i == 1:
            solution(idx+1, ops, val-arr[idx+1])
        elif i == 2:
            solution(idx+1, ops, val*arr[idx+1])
        elif i == 3:
            if val &amp;lt; 0:
                solution(idx+1, ops, -(-val // arr[idx+1]))
            else:
                solution(idx+1, ops, val // arr[idx+1])
        ops[i] += 1


solution(0, ops, arr[0])
print(max_val, min_val, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/31/BOJ-14888.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/31/BOJ-14888.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>Itertools 정리</title>
        <description>&lt;p&gt;내장 라이브러리인 &lt;code class=&quot;highlighter-rouge&quot;&gt;itertools&lt;/code&gt;를 이용해서 조합, 순열, 중복순열, Cartesian Product 등을 손쉽게 구현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations, permutations, combinations_with_replacement, product

data = '123'
l = combinations(data, 2)
for e in l:
    print(*e) # 12 13 23

l = permutations(data, 2)
for e in l:
    print(*e) # 12 13 21 23 31 32

l = combinations_with_replacement(data, 2)
for e in l:
    print(*e) # 11 12 13 22 23 33

l = product(data, repeat=2)
for e in l:
    print(*e) # 11 12 13 21 22 23 31 32 33
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/python/2021/01/30/Itertools.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/python/2021/01/30/Itertools.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - N-Queen</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem9663&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9663&quot;&gt;백준 9663번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
cnt = 0


def nqueen(arr):
    global cnt
    # 새로운 행 번호
    row = len(arr)
    if row == n:
        cnt += 1
        return

    for i in range(n):
        # 이미 있는 열
        if i in arr:
            continue
        flag = True
        # j번째 행, j번째 행에 해당하는 열 번호는 item
        for j, item in enumerate(arr):
            # 대각선
            if abs(i-item) == abs(row-j):
                flag = False
                break
        if flag:
            arr.append(i)
            nqueen(arr)
            arr.pop()
        

nqueen([])

print(cnt)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-9663.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-9663.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
