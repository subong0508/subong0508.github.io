<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 11 Mar 2021 17:12:18 +0900</pubDate>
    <lastBuildDate>Thu, 11 Mar 2021 17:12:18 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>백준 Gold3 - LCS</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem9251&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9251&quot;&gt;백준 9251번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;str1 = input()
str2 = input()
n = len(str1)
m = len(str2)

dp = [[0] * (m+1) for _ in range(n+1)]
for i in range(1, n+1):
    for j in range(1, m+1):
        if str1[i-1] == str2[j-1]:
            dp[i][j] = dp[i-1][j-1]+1
        else:
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])

print(dp[n][m])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 11 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/11/BOJ-9251.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/11/BOJ-9251.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold3 - LCS 3</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1958&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1958&quot;&gt;백준 1958번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;str1 = input()
str2 = input()
str3 = input()

l1, l2, l3 = map(len, [str1, str2, str3])
dp = [[[0 for k in range(l3+1)] for j in range(l2+1)] for i in range(l1+1)]

for i in range(1, l1+1):
    for j in range(1, l2+1):
        for k in range(1, l3+1):
            if str1[i-1] == str2[j-1] == str3[k-1]:
                dp[i][j][k] = dp[i-1][j-1][k-1]+1
            else:
                dp[i][j][k] = max([dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1]])

print(dp[l1][l2][l3])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 11 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/11/BOJ-1958.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/11/BOJ-1958.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 내리막길</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1520&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1520&quot;&gt;백준 1520번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))

dp = [[-1] * m for _ in range(m)]

def dfs(x, y):
    if x == n-1 and y == m-1:
        return 1
    # 방문한 적이 있다면
    if dp[x][y] != -1:
        return dp[x][y]
    dp[x][y] = 0
    for i in range(4):
        nx, ny = x+dx[i], y+dy[i]
        if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and graph[nx][ny] &amp;lt; graph[x][y]:
            dp[x][y] += dfs(nx, ny)
    return dp[x][y]

print(dfs(0, 0))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 11 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/11/BOJ-1520.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/11/BOJ-1520.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 관악산 등산</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14699&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14699&quot;&gt;백준 14699번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import sys

sys.setrecursionlimit(100000)

n, m = map(int, input().split())
heights = [-1] + list(map(int, input().split()))
graph = [[] for _ in range(n+1)]
for _ in range(m):
    i, j = map(int, input().split())
    if heights[i] &amp;lt; heights[j] and j not in graph[i]:
        graph[i].append(j)
    if heights[j] &amp;lt; heights[i] and i not in graph[j]:
        graph[j].append(i)

dp = [-1] * (n+1)
def dfs(i):
    # 한 번 방문한 곳은 다시 방문하지 않는다.
    if dp[i] != -1:
        return dp[i]
    dp[i] = 1
    for j in graph[i]:
        dp[i] = max(dp[i], dfs(j)+1)
    return dp[i]

for i in range(1, n+1):
    print(dfs(i))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 11 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/11/BOJ-14699.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/11/BOJ-14699.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 팰린드롬?</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem10942&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/10942&quot;&gt;백준 10942번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import sys

input = sys.stdin.readline

n = int(input())
arr = [-1] + list(map(int, input().split()))
m = int(input())

dp = [[0] * (n+1) for _ in range(n+1)]
for i in range(1, n+1):
    dp[i][i] = 1

for i in range(1, n):
    if arr[i] == arr[i+1]:
        dp[i][i+1] = 1

i = 1
diff = 2
while diff &amp;lt;= n-1:
    j = i+diff
    while j &amp;lt;= n:
        # 시작과 끝이 다르면 아니다.
        if arr[i] != arr[j]:
            dp[i][j] = 0
        # 내부의 문자열이 팰린드롬인가?
        else:
            l, r = i+1, j-1
            dp[i][j] = dp[l][r]
        i += 1
        j += 1
    i = 1
    diff += 1

query = [-1] * m
for i in range(m):
    a, b = map(int, input().split())
    query[i] = a, b

for a, b in query:
    print(dp[a][b])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 11 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/11/BOJ-10942.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/11/BOJ-10942.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold3 - 앱</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem7579&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7579&quot;&gt;백준 7579번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
memory = [0] + list(map(int, input().split()))
cost = [0] + list(map(int, input().split()))
dp = [[0] * 10001 for _ in range(n+1)]

for i in range(1, n+1):
    for j in range(1, 10001):
        if cost[i] &amp;lt;= j: # 주어진 코스트를 만족한다면 메모리를 최대화하자
            dp[i][j] = max(dp[i-1][j], memory[i]+dp[i-1][j-cost[i]])
        else:
            dp[i][j] = dp[i-1][j]

for j in range(1, 10001):
    if dp[n][j] &amp;gt;= m:
        print(j)
        break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;냅색 알고리즘의 응용문제로, 메모리에 대해 코스트를 최소화하는 테이블은 메모리 초과가 난다.
따라서 코스트에 대해 메모리를 최대화하는 DP 테이블을 만들면 된다.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/10/BOJ-7579.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/10/BOJ-7579.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 이모티콘</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14226&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14226&quot;&gt;백준 14226번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

s = int(input())
q = deque()
q.append((1, 0))
INF = int(1e9)
dist = [[-1] * (s+1) for _ in range(s+1)]
dist[1][0] = 0

while q:
    now, clip = q.popleft()
    # 화면에 있는 임티 복사
    if dist[now][now] == -1:
        dist[now][now] = dist[now][clip] + 1
        q.append((now, now))
    # 클립보드 복사
    if now+clip &amp;lt;= s and dist[now+clip][clip] == -1:
        dist[now+clip][clip] = dist[now][clip] + 1
        q.append((now+clip, clip))
    # 삭제
    if now-1 &amp;gt; 0 and dist[now-1][clip] == -1:
        dist[now-1][clip] = dist[now][clip] + 1
        q.append((now-1, clip))

res = INF
for i in range(s+1):
    if dist[s][i] != -1:
        res = min(res, dist[s][i])

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BFS + 다이나믹 프로그래밍 문제인데, 골드3 정도는 달아야 할 것 같다.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/10/BOJ-14226.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/10/BOJ-14226.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 평범한 배낭</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem12865&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/12865&quot;&gt;백준 12865번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, k = map(int, input().split())
dp = [[0] * (k+1) for _ in range(n+1)]
ws = [0] * (n+1)
vs = [0] * (n+1)
for i in range(1, n+1):
    w, v  = map(int, input().split())
    ws[i] = w
    vs[i] = v

for i in range(1, n+1):
    for j in range(1, k+1):
        if ws[i] &amp;lt;= j: # 담을 수 있는 경우
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-ws[i]]+vs[i])
        else:
            dp[i][j] = dp[i-1][j]

print(dp[n][k], sep='\n')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 문제는 Knapsack algorithm의 대표적인 문제로, 최적의 조합을 찾는 문제이다.
1번부터 n번까지 아이템을 보면서 넣을지/말지를 결정하면 된다.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/10/BOJ-12865.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/10/BOJ-12865.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 가장 큰 정사각형 찾기</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12905&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12905&quot;&gt;프로그래머스 12905번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(board):
    answer = board[0][0]
    n, m = len(board), len(board[0])
    for j in range(1, m):
        for i in range(1, n):
            if board[i][j] == 1:
                board[i][j] = min([board[i-1][j-1], board[i-1][j], board[i][j-1]])+1
            answer = max(answer, board[i][j])
    return answer ** 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;점화식을 못 찾아서 한참 헤매다가 다른 분의 풀이를 보고서야 이해했다.
다시 풀어봐야지…&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/09/PR-12905.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/09/PR-12905.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 전깃줄</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2565&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2565&quot;&gt;백준 2565번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
d = {}
for _ in range(n):
    k, v = map(int, input().split())
    d[k] = v
arr = sorted(d, key=lambda x: d[x])

dp = [0] * n
for i in range(n):
    dp[i] = 1
    for j in range(i):
        if arr[i] &amp;gt; arr[j]:
            dp[i] = max(dp[i], dp[j]+1)

print(len(arr)-max(dp))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;가장 긴 증가하는 부분 수열 알고리즘으로 바꿔서 풀 수 있는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/09/BOJ-2565.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/09/BOJ-2565.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
