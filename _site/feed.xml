<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 28 Jan 2021 19:23:55 +0900</pubDate>
    <lastBuildDate>Thu, 28 Jan 2021 19:23:55 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>스택, 큐 with Python</title>
        <description>&lt;p&gt;이번 포스팅에서는 스택, 큐에 대한 개념을 알아보고 파이썬으로 간단하게 구현해보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;스택&lt;/h1&gt;

&lt;p&gt;스택은 &lt;strong&gt;LIFO&lt;/strong&gt;(후입선출)의 특성을 가진 자료구조입니다. 시간복잡도는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;삽입: $O(1)$&lt;/li&gt;
  &lt;li&gt;삭제: $O(1)$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파이썬에서는 다른 라이브러리를 쓸 필요없이 기본 자료형인 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;를 활용하여 삽입 및 삭제 연산을 수행할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;arr = [1, 2, 3, 4, 5]
stack = []

# 삽입
for a in arr:
    stack.append(a)
print(stack)

# 삭제
while stack:
    print(stack.pop())
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;큐&lt;/h1&gt;

&lt;p&gt;큐는 기본적으로 &lt;strong&gt;FIFO&lt;/strong&gt;(선입선출)의 특성을 띄는 자료구조입니다. 시간복잡도는 앞서 설명한 스택과 동일합니다.&lt;/p&gt;

&lt;p&gt;주의해야할 점은 스택과 다르게 파이썬의 기본 자료구조인 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;를 사용해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop(0)&lt;/code&gt;을 통해 삭제연산을 수행하면 시간복잡도가 $O(n)$이 된다는 것입니다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;를 쓰기보다는 파이썬에서는 내장 모듈인 &lt;code class=&quot;highlighter-rouge&quot;&gt;collections&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;deque&lt;/code&gt;을 쓰면 간단하게 구현할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

q = deque()

# 삽입
arr = [1, 2, 3, 4, 5]
for a in arr:
    q.append(a)

# peek
print(q[0])

# pop
# popleft 말고 pop을 쓰면 선입선출
while q:
    print(q.popleft())
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data-structure/2021/01/28/Stack,-Queue.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data-structure/2021/01/28/Stack,-Queue.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Data-Structure</category>
        
      </item>
    
      <item>
        <title>백준 Silver4 - 괄호</title>
        <description>&lt;h3 id=&quot;silver4---httpswwwacmicpcnetproblem9012&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9012&quot;&gt;백준 Silver4 - 괄호&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;문제&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.&lt;/p&gt;

&lt;p&gt;여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;입력&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;출력&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예제&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;입력&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6
(())())
(((()())()
(()())((()))
((()()(()))(((())))()
()()()()(()()())()
(()((())()(
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;출력&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NO
NO
YES
NO
YES
NO
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;t = int(input())
res = []

def is_vps(string):
    stack = []
    for ch in string:
        if ch == '(':
            stack.append(ch)
        else:
            if not stack or stack.pop() != '(':
                return False
    return len(stack) == 0


for _ in range(t):
    string = input()
    if is_vps(string):
        res.append(&quot;YES&quot;)
    else:
        res.append(&quot;NO&quot;)

print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/28/BOJ-9012.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/28/BOJ-9012.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver4 - 카드2</title>
        <description>&lt;h3 id=&quot;silver4---2httpswwwacmicpcnetproblem2164&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2164&quot;&gt;백준 Silver4 - 카드2&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;문제&lt;/strong&gt;&lt;br /&gt;
N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.&lt;/p&gt;

&lt;p&gt;이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.&lt;/p&gt;

&lt;p&gt;예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.&lt;/p&gt;

&lt;p&gt;N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;입력&lt;/strong&gt;&lt;br /&gt;
첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n = int(input())
q = deque()
for i in range(1, n+1):
    q.append(i)

while len(q) &amp;gt; 1:
    q.popleft()
    if len(q) == 1:
        break
    q.append(q.popleft())

print(q.pop())
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/28/BOJ-2164.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/28/BOJ-2164.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 과제는 끝나지 않아!</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem17952&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17952&quot;&gt;백준 17952&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;문제&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;성애는 이번 학기에 전공을 정말 많이 듣는다. 이로 인해 거의 매일을 과제를 하면서 보내고 있다. 그런데도 과제가 줄어들 기미가 보이지 않는데, 바로 분단위로 과제가 추가되고 있기 때문이다. 다행히 과제 제출 기한은 학기가 끝날 때까지이다. 너무나도 많은 과제를 하다가 미쳐버린 성애는 아래와 같은 규칙으로 과제를 해 나가고 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;과제는 가장 최근에 나온 순서대로 한다. 또한 과제를 받으면 바로 시작한다.&lt;/li&gt;
  &lt;li&gt;과제를 하던 도중 새로운 과제가 나온다면, 하던 과제를 중단하고 새로운 과제를 진행한다.&lt;/li&gt;
  &lt;li&gt;새로운 과제가 끝났다면, 이전에 하던 과제를 이전에 하던 부분부터 이어서 한다. (성애는 기억력이 좋기 때문에 아무리 긴 시간이 지나도 본인이 하던 부분을 기억할 수 있다.)
성애는 과제를 받자마자 이 과제가 몇 분이 걸릴지 정확하게 알 수 있고, 성애가 제출한 과제는 무조건 만점을 받는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;성애는 이번 학기에 자기가 받을 과제 점수를 예상해보고 싶다. 하지만 과제 점수를 예상하는 지금도 과제가 추가되고 있기에 여유를 부릴 수가 없다. 여러분이 성애가 받을 과제 점수를 구해주자!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;입력&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;첫째 줄에 이번 학기가 몇 분인지를 나타내는 정수 N이 주어진다. (1 ≤ N ≤ 1,000,000)&lt;/p&gt;

&lt;p&gt;두번째 줄부터 N줄 동안은 학기가 시작하고 N분째에 주어진 과제의 정보가 아래의 두 경우 중 하나로 주어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 A T: 과제의 만점은 A점이고, 성애가 이 과제를 해결하는데 T분이 걸린다. A와 T는 모두 정수이다. (1 ≤ A ≤ 100, 1 ≤ T ≤ 1,000,000)&lt;/li&gt;
  &lt;li&gt;0: 해당 시점에는 과제가 주어지지 않았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;출력&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;성애가 받을 과제 점수를 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예제&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;입력&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3
1 100 3
0
0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;출력&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;100
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())

hw = []
res = 0
for i in range(n):
    now = input()
    if now != '0':
        _, score, time = map(int, now.split())
        hw.append([score, time])
    if hw:
        hw[-1][1] -= 1
        if hw[-1][1] == 0:
            res += hw[-1][0]
            hw.pop()

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/28/BOJ-17952.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/28/BOJ-17952.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 세훈이의 선물가게</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem17225&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17225&quot;&gt;백준 17225번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;문제&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;세훈이는 선물가게를 운영한다. 세훈이의 선물가게는 특이하게도 손님이 어떤 선물을 구매할지 선택할 수가 없다. 대신 세훈이의 취향으로 랜덤하게 준비된 선물 중 몇 개를 구매할 것인지, 파란색과 빨간색 중 어떤 색으로 포장 받을 것인지만 결정해 주문할 수 있다.&lt;/p&gt;

&lt;p&gt;상민이와 지수는 세훈이의 가게에서 선물 포장을 맡은 아르바이트생이다. 손님들은 파란색 포장지를 원하면 상민이에게, 빨간색 포장지를 원하면 지수에게 주문을 한다. 두 사람은 각자 주문을 받으면 그때부터 포장을 시작하는데, 현재 남아있는 선물 중 가장 앞에 있는 선물을 가져와 포장하고 주문을 받은 개수만큼 이를 반복하는 형태다. 이때 선물 하나를 포장하는 데 상민이는 A초, 지수는 B초가 걸린다. 두 사람 모두 받거나 밀린 주문이 없는데 미리 선물을 가져오거나 포장하는 일은 없으며, &lt;strong&gt;두 사람이 동시에 선물을 가져올 때는 알바짬이 조금 더 있는 상민이가 먼저 가져오고, 지수가 그 뒤의 선물을 가져온다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;세훈이는 어제 구매한 선물이 망가져 있다는 항의 전화를 받았다. 자신이 준비한 선물에는 문제가 없었기에 손님에게 포장지의 색을 물었지만, 손님은 자신이 받은 선물이 무엇인지만 말하며 화를 낼 뿐이었다. 어쩔 수 없이 세훈이는 어제 가게를 방문한 손님들의 주문 내역을 보고 그 선물을 누가 포장했는지 파악하려 한다.&lt;/p&gt;

&lt;p&gt;방문한 손님의 수와 각 손님이 주문한 시각, 선택한 포장지, 포장 받을 선물의 개수가 주어졌을 때 상민이와 지수가 각자 어떤 선물들을 포장했는지 알아내는 프로그램을 작성해보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;입력&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;첫 줄에 상민이가 선물 하나를 포장하는 데 걸리는 시간 A, 지수가 선물 하나를 포장하는 데 걸리는 시간 B, 어제 세훈이 가게의 손님 수 N(1 ≤ N ≤ 1,000)이 주어진다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;이후 N개의 줄에 걸쳐 1번부터 N번 손님의 주문 시각 ti(1 ≤ ti ≤ 86,400), 선택한 포장지의 색깔 ci(ci = “B”&lt;/td&gt;
      &lt;td&gt;“R”), 주문한 선물의 개수 mi(1 ≤ mi ≤ 100)가 주어진다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ti는 가게가 오픈한 지 ti초 후에 손님이 주문했음을 뜻하며 ci는 포장지의 색깔을 의미하는 알파벳으로 “B”는 파란색을, “R”은 빨간색을 의미한다. 주어지는 입력은 시간의 흐름에 맞게 ti의 오름차순으로 주어지며, 서로 같은 시간에 주문한 손님은 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;출력&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;첫 번째 줄에 상민이가 포장한 선물의 개수를 출력한다. 이후 두 번째 줄에 상민이가 포장한 선물들의 번호를 오름차순으로 공백으로 구분하여 출력한다.&lt;/p&gt;

&lt;p&gt;세 번째 줄에 지수가 포장한 선물의 개수를 출력한다. 이후 네 번째 줄에 지수가 포장한 선물들의 번호를 오름차순으로 공백으로 구분하여 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예제&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;입력&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 0 3
1 B 3
4 R 2
7 R 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;출력&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3
1 2 3
4
4 5 6 7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;a, b, n = map(int, input().split())
maxb = maxr = 0
q = []
for _ in range(n):
    t, c, m = input().split()
    t, m = map(int, [t, m])
    if c == 'B':
        # 상민이가 포장가능한 시간
        t = max(t, maxb)
        for j in range(m):
            q.append([t, c])
            t += a
        maxb = t
    else:
        # 지수가 포장가능한 시간
        t = max(t, maxr)
        for j in range(m):
            q.append([t, c])
            t += b
        maxr = t

q = sorted(q, key=lambda x: -ord(x[1]))
q = sorted(q, key=lambda x: -x[0])

res = [[], []]
idx = 0
while q:
    idx += 1
    _, c = q.pop()
    if c == 'B':
        res[0].append(idx)
    else:
        res[1].append(idx)

for r in res:
    print(len(r))
    print(*r)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우선순위큐를 사용하는 문제. 사실 큐를 사용하는 문제인줄 알고 한참을 헤매다가 다른 분의 풀이를 보고서야 이해했다..&lt;/p&gt;

&lt;p&gt;여기서 중요한 점은 두 가지다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;상민/지수가 포장을 시작할 수 있는 시간은 그 전 포장이 끝난 이후므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;maxb, maxr&lt;/code&gt; 변수를 통해 포장을 시작하는 시간 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;를 정의해 줄 것. 따라서 우선순위큐 &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt;에는 상민/지수가 쉬지 않고 포장을 했을 때 포장이 끝나는 시간이 들어간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;포장이 끝나는 시간이 같다면 상민이가 먼저 포장을 하기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt;를 정렬할 때 상민이가 더 뒤로가게(&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt; 연산을 수행해야 하므로) 정렬해주는 과정을 거쳐야 한다. 그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;heapq&lt;/code&gt; 라이브러리를 사용하지 않았다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/28/BOJ-17225.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/28/BOJ-17225.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver5 - 요세푸스 문제</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1158&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1158&quot;&gt;백준 1158번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;문제&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;요세푸스 문제는 다음과 같다.&lt;/p&gt;

&lt;p&gt;1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &amp;lt;3, 6, 2, 7, 5, 1, 4&amp;gt;이다.&lt;/p&gt;

&lt;p&gt;N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;입력&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;입력&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;7 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;출력&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;3, 6, 2, 7, 5, 1, 4&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, k = map(int, input().split())
arr = [i for i in range(1, n+1)]

res = []
idx = k-1
while True:
    item = arr.pop(idx)
    res.append(str(item))
    if not arr:
        break
    # 길이가 1 줄었으므로 한 발 물러선다.
    idx = (idx-1) % len(arr)
    for _ in range(k):
        idx = (idx + 1) % len(arr)

print('&amp;lt;' + ', '.join(res) + '&amp;gt;')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 28 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/28/BOJ-1158.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/28/BOJ-1158.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv1 추천문제 + 풀이 모음</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;추천문제&lt;/h2&gt;

&lt;p&gt;사실 코딩 수업을 들은 적이 있거나 독학한 적이 있으면 프로그래머스 Lv1은 손쉽게 풀 수 있다. 그리고 그 와중에서도 난이도 차이가 꽤나 많이 나서 추천문제만 모아보았다. 추천 문제들은 주로 구현 문제 또는 엣지 케이스에 잘 걸린다거나 효율성 테스트(시간복잡도 측정)에 걸리는 문제들이다. 그냥 내기준 다른 문제들보다 까다로운 문제들로 골라봤다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/64061&quot;&gt;크레인 인형뽑기 게임&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/72410&quot;&gt;신규 아이디 추천&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42862&quot;&gt;체육복&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12901&quot;&gt;2016년&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/68935&quot;&gt;3진법 뒤집기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12906&quot;&gt;같은 숫자는 싫어&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12915&quot;&gt;문자열 내 마음대로 정렬하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12921&quot;&gt;소수 찾기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12926&quot;&gt;시저 암호&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12930&quot;&gt;이상한 문자 만들기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/67256&quot;&gt;키패드 누르기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12982&quot;&gt;예산&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/17681&quot;&gt;[1차] 비밀지도&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42889&quot;&gt;실패율&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/17682&quot;&gt;[1차] 다트 게임&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;풀이&lt;/h2&gt;
&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons64061&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/64061&quot;&gt;크레인 인형뽑기 게임&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(board, moves):
    answer = 0
    n = len(board)
    stack = []
    for m in moves:
        for i in range(n):
            if board[i][m-1] != 0:
                stack.append(board[i][m-1])
                board[i][m-1] = 0
                # 인형삭제
                if len(stack) &amp;gt;= 2 and stack[-1] == stack[-2]:
                    stack.pop()
                    stack.pop()
                    answer += 2
                break
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons68644&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/68644&quot;&gt;두 개 뽑아서 더하기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(numbers):
    answer = set()
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            answer.add(numbers[i]+numbers[j])
    answer = sorted(answer)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set 자료형으로 중복된 값이 삽입되지 않게 구현하였다. 시간복잡도는 $n^2 + n\log n \rightarrow O(n^2)$&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42576&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42576&quot;&gt;완주하지 못한 선수&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(participant, completion):
    d = {}
    for p in participant:
        if p in d:
            d[p] += 1
        else:
            d[p] = 1
    
    for c in completion:
        d[c] -= 1
    
    for k in d:
        if d[k] != 0:
            answer = k
            break
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dictionary 자료형을 이용해서 돔영이인도 처리해주었음. 시간복잡도는 $3n \rightarrow O(n)$&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons72410&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/72410&quot;&gt;신규 아이디 추천&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import string

def solution(new_id):
    # 1. 대문자-&amp;gt;소문자
    new_id = new_id.lower()
    # 2. 유효하지 않은 문자 제거
    valid_str = list(string.ascii_lowercase) + list(map(str, range(10))) + ['-', '_', '.']
    valid_str = set(valid_str)
    tmp = ''
    for i in range(len(new_id)):
        # O(1)
        if new_id[i] in valid_str:
            tmp += new_id[i]
    new_id = tmp
    # 3. 마침표 두 번 치환
    tmp = ''
    i = 0
    while i &amp;lt; len(new_id):
        if new_id[i] != '.':
            tmp += new_id[i]
            i += 1
            continue
        j = i
        while j &amp;lt; len(new_id) and new_id[j] == '.':
            j += 1
        i = j
        tmp += '.'
    new_id = tmp
    # 4. 처음이나 끝 '.' 제거
    if len(new_id) &amp;gt; 0 and new_id[0] == '.':
        new_id = new_id[1:]
    if len(new_id) &amp;gt; 0 and new_id[-1] == '.':
        new_id = new_id[:-1]
    # 5. 빈 문자열이라면 'a' 대입
    if new_id == '':
        new_id = 'a'
    # 6. 길이가 16자 이상이라면 15개까지만
    if len(new_id) &amp;gt;= 16:
        new_id = new_id[:15]
        # 마지막 '.' 처리
        if new_id[-1] == '.':
            new_id = new_id[:-1]
    # 길이가 2자 이하라면
    if len(new_id) &amp;lt;= 2:
        ch = new_id[-1]
        while len(new_id) &amp;lt; 3:
            new_id += ch
    return new_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3번에서 마침표가 여러번 나오는 걸 하나의 마침표로 치환해주는게 조금 복잡해서 애먹은 문제..&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42840&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42840&quot;&gt;모의고사&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(answers):
    answer = []
    st1 = [1, 2, 3, 4, 5]
    st2 = [2, 1, 2, 3, 2, 4, 2, 5]
    st3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    cnt1 = get_cnt(st1, answers)
    cnt2 = get_cnt(st2, answers)
    cnt3 = get_cnt(st3, answers)
    cnts = [cnt1, cnt2, cnt3]
    max_val = max(cnts)
    for i in range(3):
        if cnts[i] == max_val:
            answer.append(i+1)
    return answer

def get_cnt(st, answers):
    cnt = 0
    for i in range(len(answers)):
        if st[i % len(st)] == answers[i]:
            cnt += 1
    return cnt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;k-httpsprogrammerscokrlearncourses30lessons42748&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42748&quot;&gt;K번째 수&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(array, commands):
    answer = []
    for c in commands:
        i, j, k = c
        tmp = array[i-1:j]
        tmp.sort()
        answer.append(tmp[k-1])
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42862&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42862&quot;&gt;체육복&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n, lost, reserve):
    students = [1] * (n+1)
    # 0번째 학생은 존재하지 않음
    students[0] = 0
    for l in lost:
        students[l] -= 1
    for r in reserve:
        students[r] += 1
    for r in reserve:
        # 여벌을 가지고 왔지만 도난당한 경우
        if students[r] == 1:
            continue
        if 1 &amp;lt;= r-1 and students[r-1] == 0:
            students[r-1] += 1
            students[r] -= 1
        elif r+1 &amp;lt;= n and students[r+1] == 0:
            students[r+1] += 1
            students[r] -= 1
    # 여벌을 가지고 왔지만 빌려주지 못한 경우를 위해 min 함수 적용
    students = [min(1, st) for st in students]
    return sum(students)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;생각보다 신경써야 할 케이스가 많아서 푸는데 시간이 좀 걸렸다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12901&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12901&quot;&gt;2016년&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(a, b):
    days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT']
    months = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    # 월, 일, 요일
    month = day = 1
    now = 5
    while month != a or day != b:
        now = (now + 1) % len(days)
        day += 1
        # 한 달이 지나면
        if day &amp;gt; months[month]:
            day = 1
            month += 1 
    answer = days[now]
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;요일에 해당하는 배열과 각 달의 일수를 저장한 배열을 이용하면 어렵지 않은 문제였다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12903&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12903&quot;&gt;가운데 글자 가져오기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(s):
    answer = ''
    if len(s) % 2 == 1:
        answer = s[len(s)//2]
    else:
        answer = s[len(s)//2-1] + s[len(s)//2]
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons68935&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/68935&quot;&gt;3진법 뒤집기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n):
    triple = ''
    while n &amp;gt;= 1:
        triple += str(n % 3)
        n //= 3

    i = len(triple)-1
    d = 1
    answer = 0
    while i &amp;gt;= 0:
        answer += int(triple[i]) * d
        d *= 3
        i -= 1
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;triple&lt;/code&gt;을 만들 때 이미 뒤집어져있으므로 바로 10진법으로 바꿔주면 된다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12906&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12906&quot;&gt;같은 숫자는 싫어&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(arr):
    answer = []
    i = 0
    while i &amp;lt; len(arr):
        j = i
        while j &amp;lt; len(arr) and arr[j] == arr[i]:
            j += 1
        answer.append(arr[i])
        i = j
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;슬라이딩 윈도우를 이용하여 풀어주었다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12910&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12910&quot;&gt;나누어 떨어지는 숫자 배열&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(arr, divisor):
    answer = []
    for a in arr:
        if a % divisor == 0:
            answer.append(a)
    
    if not answer:
        answer = [-1]
    answer.sort()
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12912&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12912&quot;&gt;두 정수 사이의 합&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(a, b):
    a, b = min(a, b), max(a, b)
    answer = 0
    for i in range(a, b+1):
        answer += i
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12915&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12915&quot;&gt;문자열 내 마음대로 정렬하기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(strings, n):
    answer = sorted(strings)
    answer = sorted(answer, key=lambda x: x[n])
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;쉬운 문제지만 인덱스 n으로 정렬하는 것이 사전순정렬보다 우선순위이기 때문에 &lt;strong&gt;직관과 반대로 먼저 사전순정렬을 해준 다음에 인덱스 n으로 정렬해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;p-y-httpsprogrammerscokrlearncourses30lessons12916&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12916&quot;&gt;문자열 내 p와 y의 개수&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(s):
    s = s.lower()
    p_num = y_num = 0
    for ch in s:
        if ch == 'p':
            p_num += 1
        elif ch == 'y':
            y_num += 1
    return p_num == y_num
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12917&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12917&quot;&gt;문자열 내림차순으로 배치하기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(s):
    s = list(s)
    s.sort(reverse=True)
    answer = ''.join(s)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12918&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12918&quot;&gt;문자열 다루기 기본&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(s):
    if not (len(s) == 4 or len(s) == 6):
        return False
    for ch in s:
        if not ch.isdigit():
            return False
    return True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;파이썬 string의 내장 메소드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;isdigit()&lt;/code&gt;을 활용하면 더 쉽게 풀 수 있는 문제였다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12919&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12919&quot;&gt;서울에서 김서방 찾기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(seoul):
    idx = seoul.
    answer = &quot;김서방은 &quot; + str(idx) + &quot;에 있다&quot;
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12921&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12921&quot;&gt;소수 찾기&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;(틀린 코드)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n):
    answer = 0
    for i in range(2, n+1):
        if is_prime(i):
            answer += 1
    return answer

def is_prime(n):
    i = 2
    while i*i &amp;lt;= n:
        if n % i == 0:
            return False
        i += 1
    return True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 문제는 일반적인 소수를 찾는 방법을 주어진 범위에 모두 적용하면 효율성 테스트에서 틀린다ㅠㅠ 따라서 보다 효율적인 알고리즘을 사용해야하는데, &lt;strong&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4#%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4%EB%A5%BC_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4%EB%A1%9C_%EA%B5%AC%ED%98%84&quot;&gt;에라토스테네스의 체&lt;/a&gt;&lt;/strong&gt;라는 알고리즘을 사용하면 된다.&lt;/p&gt;

&lt;p&gt;(맞는 코드)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n):
    array = [True] * (n+1)
    # 0과 1은 소수가 아니다.
    array[:2] = [False] * 2
    i = 2
    while i*i &amp;lt;=  n:
        if array[i]:
            j = 2*i
            while j &amp;lt;= n:
                array[j] = False
                j += i
        i += 1
    answer = sum(array)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12922&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12922&quot;&gt;수박수박수박수박수박수?&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n):
    answer = ''
    arr = ['수', '박']
    for i in range(n):
        answer += arr[i % 2]
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12925&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12925&quot;&gt;문자열을 정수로 바꾸기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(s):
    return int(s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;역시 코테는 파이썬이 짱인듯하다..&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons70128&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/70128&quot;&gt;내적&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(a, b):
    answer = 0
    for i in range(len(a)):
        answer += a[i] * b[i]
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12926&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12926&quot;&gt;시저 암호&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(s, n):
    answer = ''
    for ch in s:
        if ch == ' ':
            answer += ch
        # 소문자라면
        elif ord('a') &amp;lt;= ord(ch) &amp;lt;= ord('z'):
            tmp = ord(ch)+n
            if tmp &amp;gt; ord('z'):
                tmp -= 26
            answer += chr(tmp)
        # 대문자라면
        else:
            tmp = ord(ch)+n
            if tmp &amp;gt; ord('Z'):
                tmp -= 26
            answer += chr(tmp)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‘z’ 같은 경우에는 1을 더했을 때 ‘a’가 나와야 하므로 ‘z’보다 크면 26을 빼줘야하는게 이 문제의 핵심이었다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12928&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12928&quot;&gt;약수의 합&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n):
    answer = 0
    for i in range(1, n+1):
        if n % i == 0:
            answer += i
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12930&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12930&quot;&gt;이상한 문자 만들기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(s):
    answer = ''
    i = 0
    for ch in s:
        if ch == ' ':
            answer += ch
            i  = 0
            continue
        if i % 2 == 0:
            answer += ch.upper()
        else:
            answer += ch.lower()
        i += 1
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;공백을 기준으로 단어를 분리해서 짝/홀수를 세어줘야 하기 때문에 공백을 만나면 &lt;code class=&quot;highlighter-rouge&quot;&gt;i=0&lt;/code&gt;이 된다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12931&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12931&quot;&gt;자릿 수 더하기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n):
    answer = 0
    string = str(n)
    for ch in string:
        answer += int(ch)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12932&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12932&quot;&gt;자연수 뒤집어 배열로 만들기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n):
    string = str(n)[::-1]
    answer = []
    for ch in string:
        answer.append(int(ch))
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12933&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12933&quot;&gt;정수 내림차순으로 배치하기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n):
    answer = 0
    lst = list(str(n))
    lst.sort(reverse=True)
    answer = int(''.join(lst))
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12934&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12934&quot;&gt;정수 제곱근 판별&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n):
    i = 1
    x = -1
    while i*i &amp;lt;= n:
        if i*i == n:
            x = i
        i += 1
        
    if x == -1:
        answer = -1
    else:
        answer = (x+1) ** 2
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12935&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12935&quot;&gt;제일 작은 수 제거하기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(arr):
    min_val = min(arr)
    answer = [x for x in arr if x != min_val]
    if not answer:
        answer.append(-1)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12937&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12937&quot;&gt;짝수와 홀수&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(num):
    if num % 2 == 0:
        answer = 'Even'
    else:
        answer = 'Odd'
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons67256&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/67256&quot;&gt;키패드 누르기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(numbers, hand):
    answer = ''
    # 왼손, 오른손 위치
    l = (3, 0)
    r = (3, 2)
    for n in numbers:
        if n in (1, 4, 7):
            answer += 'L'
            l = n//3, 0
        elif n in (3, 6, 9):
            answer += 'R'
            r = n//3-1, 2
        else:
            c = (n//3, 1)
            # 0인 경우 예외 처리
            if n == 0:
                c = (3, 1)
            l_dist = distance(l, c)
            r_dist = distance(r, c)
            if l_dist &amp;lt; r_dist:
                l = c
                answer += 'L'
            elif r_dist &amp;lt; l_dist:
                r = c
                answer += 'R'
            else: # 두 거리가 같을때
                if hand == 'left':
                    answer += 'L'
                    l = c
                else:
                    answer += 'R'
                    r = c
    return answer

def distance(a, b):
    return abs(a[0]-b[0])+abs(a[1]-b[1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;numbers&lt;/code&gt;안에 있는 0을 따로 예외처리해줘야 한다. 그 부분만 빼면 평범한 구현문제인듯하다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12940&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12940&quot;&gt;최대공약수와 최소공배수&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n, m):
    gcd = find_gcd(max(n, m), min(n, m))
    lcm = n * m / gcd
    answer = [gcd, lcm]
    return answer

def find_gcd(m, n):
    &quot;&quot;&quot;m has to be greater than or equal to n&quot;&quot;&quot;
    r = m % n
    while r &amp;gt; 0:
        m, n = n, r
        r = m % n
    return n
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12943&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12943&quot;&gt;콜라츠 추측&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(num):
    answer = 0
    while num != 1:
        answer += 1
        if num % 2 == 0:
            num //= 2
        else:
            num = num*3 + 1
        if answer &amp;gt;= 500:
            answer = -1
            break
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12944&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12944&quot;&gt;평균 구하기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(arr):
    cnt = len(arr)
    total = sum(arr)
    return total / cnt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12947&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12947&quot;&gt;하샤드 수&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(x):
    d = 0
    x_str = str(x)
    for ch in x_str:
        d += int(ch)
    return x % d == 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12948&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12948&quot;&gt;핸드폰 번호 가리기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(phone_number):
    answer = '*' * (len(phone_number)-4) + phone_number[-4:]
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12950&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12950&quot;&gt;행렬의 덧셈&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(arr1, arr2):
    answer = [[0] * len(arr1[0]) for _ in range(len(arr1))]
    for i in range(len(answer)):
        for j in range(len(answer[0])):
            answer[i][j] += (arr1[i][j] + arr2[i][j])
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;x---n-httpsprogrammerscokrlearncourses30lessons12954&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12954&quot;&gt;x만큼 간격이 있는 n개의 숫자&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(x, n):
    answer = [x*i for i in range(1, n+1)]
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12969&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12969&quot;&gt;직사각형 별찍기&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;a, b = map(int, input().strip().split(' '))
for i in range(b):
    for j in range(a):
        print('*', end='')
    print()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons12982&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/12982&quot;&gt;예산&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(d, budget):
    answer = 0
    d.sort(reverse=True)
    while d:
        budget -= d.pop()
        if budget == 0:
            answer += 1
            break
        elif budget &amp;lt; 0:
            break
        answer += 1
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons17681&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/17681&quot;&gt;[1차] 비밀지도&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(n, arr1, arr2):
    answer = []
    for a, b, in zip(arr1, arr2):
        str1, str2 = bin(a)[2:], bin(b)[2:]
        # 공백처리
        if len(str1) &amp;lt; n:
            str1 = (n-len(str1)) * '0' + str1
        if len(str2) &amp;lt; n:
            str2 = (n-len(str2)) * '0' + str2
            
        tmp = ['#' if ch1 == '1' or ch2 == '1' else ' ' for 
              ch1, ch2 in zip(str1, str2)]
        answer.append(''.join(tmp))
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;파이썬 내장함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt;을 사용하면 십진수를 이진법으로 쉽게 바꿔줄 수 있다. 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;에 맞게 패딩처리도 해줘야한다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42889&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42889&quot;&gt;실패율&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(N, stages):
    d = {i: 0 for i in range(1, N+1)}
    total = len(stages)
    cnt = 1
    stages.sort()
    prev = stages[0]
    for i in range(1, len(stages)):
        # 범위를 이미 넘어선 경우
        if prev &amp;gt; N:
            break
            
        # 딕셔너리 업데이트
        if stages[i] != prev:
            d[prev] = cnt / total
            total -= cnt
            cnt = 1
            prev = stages[i]
        # 마지막 원소까지 d에 있는 경우
        elif i == len(stages)-1 and prev in d:
            cnt += 1
            d[prev] = total / cnt
        else:
            cnt += 1
            
    # stable sort: reverse=True말고 -를 붙여주어야 한다.
    answer = sorted(d.keys(), key=lambda x: -d[x])
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stages&lt;/code&gt;를 정렬해주고 직전의 값과 비교해주면서 딕셔너리를 업데이트 해주었다. 이때 &lt;code class=&quot;highlighter-rouge&quot;&gt;stages&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;보다 큰 값이 있을 수도 있으니 예외처리를 해주고, &lt;code class=&quot;highlighter-rouge&quot;&gt;[4, 4, 4, 4]&lt;/code&gt;같은 경우 마지막까지 범위안에 들어가므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;elif&lt;/code&gt;조건을 추가했다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;em&gt;stable sort&lt;/em&gt;를 위해 파이썬의 내장함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;sorted&lt;/code&gt;를 사용했는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;reverse=True&lt;/code&gt;를 옵션으로 줘버리면 &lt;em&gt;reverse stable sort&lt;/em&gt;가 되기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 파라미터에 마이너스(-)를 적용한 람다함수를 값으로 주었다.&lt;/p&gt;

&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons17682&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/17682&quot;&gt;[1차] 다트 게임&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(dartResult):
    answer = 0
    # 점수들을 담은 스택
    stack = []
    for i, ch in enumerate(dartResult):
        if ch.isdigit():
            # 숫자가 이어지는 경우
            if stack and dartResult[i-1].isdigit():
                stack.append(stack.pop()*10 + int(ch))
            else:
                stack.append(int(ch))
        elif ch in ('S', 'D', 'T'):
            if ch == 'S':
                m = 1
            elif ch == 'D':
                m = 2
            elif ch == 'T':
                m = 3
            # 점수를 바꿔준다.
            stack[-1]  = stack[-1] ** m
        else:
            # 스타상 처리
            if ch == '*':
                if len(stack) &amp;gt;= 2:
                    stack[-1] *= 2
                    stack[-2] *= 2
                else:
                    stack[-1] *= 2
            else: # 아차상 처리
                stack[-1] *= -1
        
    answer = sum(stack)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지금까지 획득한 점수들을 담은 배열을 스택으로 생각하고 처리해주면 되는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/25/Programmers-Lv1-1.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/25/Programmers-Lv1-1.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>Django 기본 명령어 모음</title>
        <description>&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# run server
&amp;gt; python manage.py runserver {port_number}

# app 만들기
&amp;gt; python manage.py startapp {app_name}

# migration
&amp;gt; python manage.py makemigrations {app_name}
&amp;gt; python manage.py migrate {app_name}

# check
&amp;gt; python manage.py sqlmigrate {app_name} 0001_initial
&amp;gt; python manage.py dbshell
&amp;gt; python manage.py showmigrations {app_name}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 25 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/backend/2021/01/25/Django-commands.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/backend/2021/01/25/Django-commands.html</guid>
        
        <category>python</category>
        
        <category>django</category>
        
        <category>backend</category>
        
        <category>server</category>
        
        
        <category>Backend</category>
        
      </item>
    
      <item>
        <title>Pix2Pix, CycleGAN</title>
        <description>&lt;p&gt;이번 포스팅에서는 image-to-image translation model의 조상님격인 Pix2Pix와 CycleGAN에 대해서 알아보겠습니다. Pix2Pix를 먼저 다루고 그 후에 CycleGAN에 대해 다루려고 합니다.&lt;/p&gt;

&lt;p&gt;아래는 Pix2Pix 원논문에 나와있는 image-to-image translation을 잘 보여주는 사진입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/img2img.png&quot; alt=&quot;image-to-image translation&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;pix2pix&quot;&gt;Pix2Pix&lt;/h1&gt;

&lt;p&gt;vanilla GAN은 random noise vector $z$를 output image $y$로 보내는 mapping function $G: x \rightarrow y$를 학습합니다. 그러나 conditional GAN은 observed image $x$와 random noise vector $z$를 $y$로 보내는 mapping을 학습합니다. 즉, $G: { x, z } \rightarrow y$를 학습합니다. 이를 그림으로 나타내면 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/training-pix2pix.png&quot; alt=&quot;Pix2Pix&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;objective&quot;&gt;Objective&lt;/h2&gt;

&lt;p&gt;conditional GAN의 objective function은 아래와 같이 표현될 수 있습니다.&lt;/p&gt;

&lt;p&gt;$\mathcal{L_\textbf{cGAN}}(G, D) = \underset{x, y}{\mathbb{E}}[\log D(x, y)] +\underset{x, z}{\mathbb{E}}[\log (1-D(x, G(x, z)))]$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;즉, 기존 GAN과 다르게 D는 $x, y$가 진짜 이미지에서 온 pair인지 판별하게 됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;또한 GAN objective에 L1 loss를 추가해줌으로써 G로 하여금 D를 속일뿐만 아니라 output과 ground truth가 비슷하게 만드는 태스크를 추가합니다.&lt;/p&gt;

&lt;p&gt;$\mathcal{L_\text{L1}}(G) = \mathbb{E}_{x,y,z}[\vert\vert y-G(x,z) \underset{1}{\vert\vert}]$&lt;/p&gt;

&lt;p&gt;따라서 final objective는 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;$G^{*} = \arg \underset{G}{\min} \underset{D}{\max}\mathcal{L_\textbf{cGAN}}(G, D)+\lambda\mathcal{L_\text{L1}}(G)$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;원래는 $z$에다가 Gaussian noise를 넣어주는 것이 정석인데, 여기서는 &lt;em&gt;dropout&lt;/em&gt;을 적용하는 것으로 대체합니다. train/test시에 모두 &lt;em&gt;dropout&lt;/em&gt;의 형태로 noise를 넣어주는 것입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/pix2pix-losses.png&quot; alt=&quot;Pix2Pix Losses&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 두 loss term을 모두 합쳐준게 제일 결과가 좋습니다.&lt;/p&gt;

&lt;h2 id=&quot;network-architecture&quot;&gt;Network Architecture&lt;/h2&gt;

&lt;p&gt;구체적인 네트워크 구조에 대해서 설명하겠습니다. image-to-image translation model에서는 input과 output이 우리가 눈으로 보기에는 다른 구조를 가지지만 사실은 같은 underlying structure에서 rendering을 한 것이라고 주장합니다. &lt;strong&gt;따라서, input의 구조와 output의 구조가 align 되어야합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 논문은 U-Net shape을 가진 G에 skip connection을 추가해줌으로써 encoder-decoder network의 information bottleneck 현상을 방지합니다. low-level information도 잘 전달되도록 하는 것이라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;L1 Loss를 우리의 비용함수에 포함하는 것은 G가 low frequencies를 제대로 capture하도록 강제하는 것으로 볼 수 있습니다. 이로인해 D는 high-frequency structure만 잡아내면 되고, 이 논문의 저자들은 &lt;em&gt;PatchGAN&lt;/em&gt;이라는 새로운 구조를 도입합니다.&lt;/p&gt;

&lt;p&gt;D는 G가 생성한 전체 이미지를 보는 대신에, $N \times N$ 크기의 patch를 보고 real/fake 여부를 판별합니다. 그 후에 이것들을 평균내 D의 output으로 넣어줍니다. 이렇게 함으로써 이미지의 high-frequency를 모델링했다고 합니다. 경험적으로 $70 \times 70$짜리 패치정도가 적당했다고 하네요.&lt;/p&gt;

&lt;p&gt;또한 특이한 점은 test시에도 train data의 통계량을 사용하지 않고 test data의 통계량을 사용했다고 합니다. 개인적으로는 $z$를 dropout으로 넣었기때문에 이 방법이 더 효과적이었던 것 같습니다.&lt;/p&gt;

&lt;p&gt;그 뒤에는 여러 실험결과가 나오는데, 저는 이 부분은 생략하고 CycleGAN으로 넘어가겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;cyclegan&quot;&gt;CycleGAN&lt;/h1&gt;

&lt;p&gt;먼저, Cycle GAN으로 생성된 결과부터 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/cycle-img.png&quot; alt=&quot;cycle-gan&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지금부터 설명드릴 Cycle GAN은 Pix2Pix의 문제점인 data insuffiency를 해결한 논문입니다. Pix2Pix는 paired image dataset이 필요합니다. 그러나 실제로 그런 데이터는 흔하지 않습니다.&lt;/p&gt;

&lt;p&gt;Cycle GAN은 &lt;strong&gt;서로 다른 도메인&lt;/strong&gt;의 이미지들간 mapping을 구해주는 모델입니다. 즉, $G: X \rightarrow Y$라는 translator와 $F: Y \rightarrow X$라는 translator를 구해줍니다. $G^{-1}= F$의 관계가 성립합니다.&lt;/p&gt;

&lt;p&gt;하지만 우리가 neural network에게 $G^{-1}= F$가 성립하도록 explicit하게 제재를 가해주는 방법이 없습니다. 따라서 이 논문들의 저자는 &lt;strong&gt;Cycle Consistency Loss&lt;/strong&gt;를 더함으로써 $F(G(x)) \approxeq x$, $G(F(x)) \approxeq y$가 성립하도록 해주었습니다.&lt;/p&gt;

&lt;p&gt;전체적인 네트워크 구조는 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/cycle-arc.png&quot; alt=&quot;cycle-gan&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;objective-1&quot;&gt;Objective&lt;/h2&gt;

&lt;h3 id=&quot;adversarial-loss&quot;&gt;Adversarial Loss&lt;/h3&gt;

&lt;p&gt;generated image가 target domain에서 왔는지 판별하는 D를 통해 adversarial 하게 학습합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/cycle-loss1.png&quot; alt=&quot;cycle-gan&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cycle-consistency-loss&quot;&gt;Cycle Consistency Loss&lt;/h3&gt;

&lt;p&gt;$G, F$가 역함수 관계에 있을 수 있도록 학습합니다. 이는 mode collapsing 문제도 해결해준다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/cycle-loss2.png&quot; alt=&quot;cycle-gan&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;full-objective&quot;&gt;Full Objective&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/cycle-loss3.png&quot; alt=&quot;cycle-gan&quot; /&gt;&lt;/p&gt;

&lt;p&gt;언급한 Loss를 모두 결합하면 위와 같습니다.&lt;/p&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1611.07004.pdf&quot;&gt;Image-to-Image Translation with Conditional Adversarial Networks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1703.10593&quot;&gt;Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/generative-models/2021/01/13/Pix2Pix.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/generative-models/2021/01/13/Pix2Pix.html</guid>
        
        <category>GAN</category>
        
        <category>Pix2Pix</category>
        
        <category>pix2pix</category>
        
        <category>CycleGAN</category>
        
        <category>deep-learning</category>
        
        
        <category>generative-models</category>
        
      </item>
    
      <item>
        <title>InfoGAN</title>
        <description>&lt;p&gt;이번 포스팅에서는 InfoGAN에 대해서 알아보겠습니다. GAN에 대한 설명은 생략하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, InfoGAN의 motivation 부터 알아보려고 합니다. GAN을 통해 우리는 latent variable $z$에서 실제 데이터 $x$로 가는 mapping을 학습합니다. 그래서 $z$를 latent representation이라고 합니다. 그러나 아쉽게도 GAN은 entangled representation을 학습합니다. 아래는 disentagled/entagled의 차이점을 시각화한 그림입니다. (&lt;a href=&quot;https://science.sciencemag.org/content/295/5552/7/tab-figures-data&quot;&gt;이미지 출처&lt;/a&gt;) &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://science.sciencemag.org/content/sci/295/5552/7/F1.medium.gif&quot; alt=&quot;swiss roll&quot; /&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;D보다는 B에서 manifold가 깔끔하게 학습되었고, GAN을 통해서 이런 깔끔한 manifold, 즉 &lt;strong&gt;disentangled&lt;/strong&gt; representaion을 학습함으로써 이미지의 퀄리티와 explainability를 동시에 향상시켰다는 것이 이 논문의 주요 내용입니다.&lt;/p&gt;

&lt;h2 id=&quot;mutual-information-for-inducing-latent-codes&quot;&gt;Mutual Information for Inducing Latent Codes&lt;/h2&gt;

&lt;p&gt;원래 GAN에서는 input noise vector로 $z$를 넣어줍니다. 대부분 $z$는 $\mathcal{N}[\mathbf{0}, \sigma^{2} \mathbf{I}]$를 따른다고 가정합니다. generator는 어떤 제한없이 $z$를 그대로 받아서 이미지를 생성하게 됩니다. 결과적으로, $z$의 각 차원이 데이터의 semantic feature와 대응되지 않는다는 문제점이 생깁니다.&lt;/p&gt;

&lt;p&gt;하지만 실제로 이미지 데이터는 semantically meaningful factors로 분해될 수 있습니다. 예를 들어, MNIST에서는 숫자의 휘어진 정도 또는 numerical identity(0-9)가 있겠습니다. 이런 특징들을 $z$가 잡을 수 있다면 훨씬 해석이 쉬운 동시에 원하는 이미지를 생성하기도 쉬울 것입니다.&lt;/p&gt;

&lt;p&gt;이 논문에서는, input noise vector를 크게 두 파트로 분류합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$z$: incompressible한 noise&lt;/li&gt;
  &lt;li&gt;$c$: latent code - data의 semantic feature에 해당합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기서 $c$는 factored distribution을 가정합니다. 왜냐하면 이미지의 각 salient feature가 독립이라고 가정하는 것이 합리적이기 때문입니다. 수식으로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;$P(c_{1}, …, c_{L}) = \prod_{i=1}^{L}P(c_{i})$&lt;/p&gt;

&lt;p&gt;우리는 generator에 $z, c$를 인풋으로 넣어줍니다. 그러면 generator는 $G(z, c)$로 표현할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 이 논문에 key idea를 설명하겠습니다. 이 논문은 &lt;strong&gt;latent code $c$와 $G(z, c)$간에 high mutual information이 있어야 한다는 제약조건을 상정합니다. 따라서, $I(c;G(z, c))$는 높아야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$I(X;Y)$란 $Y$가 관측되었을 때 $X$의 불확실성이 감소되는 정도를 의미합니다. 만약 $X$, $Y$가 indepentdent하다면 $I(X;Y)=0$이 성립합니다. 만약 information theory에 대해서 생소하다면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Conditional_entropy&quot;&gt;링크&lt;/a&gt;를 참조하면 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;따라서 우리의 목표는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;$\min_{G}\max_{D}V_{I}(D, G) = V(D, G)-\lambda I(c;G(z,c))$&lt;/p&gt;

&lt;p&gt;여기서 regularization term에 해당하는 $\lambda I(c;G(z,c))$는 latent code $c$의 information이 generation process에서 소실되지 않도록 강제합니다.&lt;/p&gt;

&lt;h2 id=&quot;variational-mutual-information-maximization&quot;&gt;Variational Mutual Information Maximization&lt;/h2&gt;

&lt;p&gt;하지만 실제로 $I(c;G(z,c))$를 직접 최대화하는 것에는 어려움이 있습니다. 왜냐하면 $P(c \vert x)$를 알아야 하기 때문입니다. &lt;strong&gt;따라서 우리는 variational lower bound 테크닉을 이용해서 $P(c \vert x)$를 $Q(c \vert x)$로 근사합니다.&lt;/strong&gt; 이제 variational lower bound에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;$I(c;G(z,c))=H(c)-H(c\vert G(z, c)=\mathbb{E_{x \thicksim G(z, c)}}[\mathbb{E_{c’ \thicksim P(c \vert x)}[log P(c’ \vert x)]}] + H(c)$&lt;/p&gt;

&lt;p&gt;$=\mathbb{E_{x \thicksim G(z, c)}}[D_{KL}(P(c’ \vert x) \vert\vert Q(c’ \vert x))] +\mathbb{E_{c’ \thicksim P(c \vert x)}}[log Q(c’ \vert x)] + H(c)$&lt;/p&gt;

&lt;p&gt;$\geq \mathbb{E_{x \thicksim G(z, c)}}[\mathbb{E_{c’ \thicksim P(c \vert x)}}[log Q(c’ \vert x)]] + H(c)$&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;font color=&quot;red&quot;&gt;$\mathcal{L_{I}}(G, Q) = \mathbb{E_{x \thicksim G(z, c)}}[\mathbb{E_{c' \thicksim P(c \vert x)}}[log Q(c' \vert x)]] + H(c)$&lt;/font&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여기서도 문제가 발생합니다. $\mathbb{E_{c’ \thicksim P(c \vert x)}}[log Q(c’ \vert x)]$에 $P(c \vert x)$가 들어간다는 점입니다. 하지만 수리통계학의 &lt;em&gt;lemma&lt;/em&gt;에 의해 해결가능합니다. (&lt;a href=&quot;http://aoliver.org/correct-proof-of-infogan-lemma&quot;&gt;링크&lt;/a&gt;에 자세히 나와있습니다.) 구체적인 수식을 살펴보겠습니다. $G(z, c)$는 $P_{G}(x \vert z, c)$로 새로 나타낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;$\mathbb{E_{x \thicksim G(z, c)}}[\mathbb{E_{c’ \thicksim P(c \vert x)}}[log Q(c’ \vert x)]] = \mathbb{E_{x \thicksim P_{G}(x \vert z, c), c’ \thicksim P(c’ \vert x)}}[logQ(c’ \vert x)]$&lt;/p&gt;

&lt;p&gt;$=\mathbb{E_{x \thicksim P_{G}(x \vert z, c), c \thicksim x, c’ \thicksim P(c’ \vert x)}}[logQ(c’ \vert x)]=\mathbb{E_{x \thicksim G(z, c), c \thicksim p(c)}}[logQ(c’ \vert x)]$&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;font color=&quot;red&quot;&gt;${L_{I}}(G, Q) = \mathbb{E_{x \thicksim G(z, c), c \thicksim p(c)}}[logQ(c' \vert x)] + H(c)$&lt;/font&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그러면 이제 마지막식은 Monte Carlo simulation으로 손쉽게 구할 수 있고 최종목표식은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;$\min_{G}\max_{D}V_{I}(D, G) = V(D, G)-\lambda{L_{I}}(G, Q)$&lt;/p&gt;

&lt;p&gt;수식으로만 보니 와닿지 않기 때문에 이 논문을 요약하여 한장의 그림으로 나타내어 보았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/infoGAN.png&quot; alt=&quot;InfoGAN structrure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;핵심은 generator로 하여금 semantic feature/latent code c를 복원할 수 있을 만큼 생성을 해라!가 되겠습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;실제로 코드로 구현할 때는 $Q$를 neural network로 구현하되 $D$와 모든 convolution layer를 공유하고 $Q(c \vert x)$를 위한 FC layer만 추가해주었다고 합니다. 이로써 $Q$에 대한 cost는 vanilla GAN과 거의 동일해집니다.&lt;/p&gt;

&lt;p&gt;$c_{i}$가 categorical 변수일 때는 $Q(c _{i}\vert x)$를 구하는데 softmax nonlinearity를 이용했고 continuous 변수일 때는 factored Gaussian으로 충분했다고 합니다.&lt;/p&gt;

&lt;p&gt;또한 $\lambda$에 대한 튜닝도 쉬웠다고 하는데요. $c_{i}$가 categorical 변수일 때는 $\lambda$를 1로 두고, continuous 변수일 때는 그것보다 작은 값을 이용했다고 언급하고 있습니다. 마지막으로 GAN structure는 DC-GAN을 이용했습니다.&lt;/p&gt;

&lt;h2 id=&quot;experiments&quot;&gt;Experiments&lt;/h2&gt;

&lt;h3 id=&quot;mutual-information-maximization&quot;&gt;Mutual Information Maximization&lt;/h3&gt;

&lt;p&gt;InfoGAN의 학습이 잘 되었다면 lower bound가 $H(c)$로 maximize 됩니다. 이말인즉슨 bound가 tight한 동시에 maximal mutual information을 얻었다는 뜻입니다. 원논문의 Fig1이 이를 시각화해서 보여주고 있습니다. 화질이 좋지 않아서 첨부하진 않았습니다. vanilla GAN은 lower bound가 $H(c)$로 maximize되지 않지만 InfoGAN은 빠르게 수렴하고 있습니다. 이는 vanilla GAN에서 generator는 이미지의 semantic feature를 잡아내지 못함을 뜻합니다.&lt;/p&gt;

&lt;h2 id=&quot;disentangled-representation&quot;&gt;Disentangled Representation&lt;/h2&gt;

&lt;p&gt;MNIST에 대해 살펴보겠습니다. $c_{1} \thicksim Cat(K=10, p=0.1)$을 사용했고 $c_{2}, c_{3}$은 continous variations를 나타내기 위한 변수로 사용했다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/gans/infogan-mnist.png&quot; alt=&quot;InfoGAN MNIST&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우리의 예상대로 $c_{1}$은 digit type을 나타내는 피쳐에 해당합니다. 그리고 $c_{2}, c_{3}$는 각각 rotation, width에 해당하는 피쳐가 되겠습니다.&lt;/p&gt;

&lt;p&gt;다른 데이터셋을 시각화한 결과가 궁금하시다면 원논문을 참조하시면 됩니다. latent code $c$가 이미지의 semantic feature를 잘 잡아냄을 알 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1606.03657.pdf&quot;&gt;InfoGAN: Interpretable Representation Learning by
Information Maximizing Generative Adversarial Nets&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/generative-models/2021/01/07/InfoGAN.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/generative-models/2021/01/07/InfoGAN.html</guid>
        
        <category>GAN</category>
        
        <category>InfoGAN</category>
        
        <category>deep-learning</category>
        
        <category>representation-learning</category>
        
        
        <category>generative-models</category>
        
      </item>
    
  </channel>
</rss>
