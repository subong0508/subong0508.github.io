<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 16 Feb 2021 23:23:09 +0900</pubDate>
    <lastBuildDate>Tue, 16 Feb 2021 23:23:09 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>프로그래머스 Lv3 - 단어 변환</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons43163&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/43163&quot;&gt;프로그래머스 43163번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

def diff(word1, word2):
    cnt = 0
    for i in range(len(word1)):
        if word1[i] != word2[i]:
            cnt += 1
    return cnt

def solution(begin, target, words):
    answer = 0
    q = deque([(begin, answer)])
    visited = set()
    visited.add(begin)
    while q:
        now, ans = q.popleft()
        if now == target:
            return ans
        neighbors = [word for word in words if diff(now, word) == 1]
        for n in neighbors:
            if n not in visited:
                visited.add(n)
                q.append((n, ans+1))
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그래프인걸 알고 풀어서 쉬웠지만 몰랐다면 그래프/BFS를 생각해내기 쉽지 않았을 것 같은 문제.&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/PR-43163.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/PR-43163.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - 나이트의 이동</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem7562&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7562&quot;&gt;백준 7562번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

t = int(input())
res = []

dx = [-2, -2, -1, -1, 1, 1, 2, 2]
dy = [-1, 1, -2, 2, -2, 2, -1, 1]


def solve(n, src, dest):
    cnt = 0
    q = deque([(src[0], src[1], cnt)])
    visited = set()
    visited.add(src)
    while q:
        x, y, cnt = q.popleft()
        if (x, y) == dest:
            return cnt
        for i in range(8):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and (nx, ny) not in visited:
                visited.add((nx, ny))
                q.append((nx, ny, cnt+1))
    return -1


for _ in range(t):
    n = int(input())
    src = tuple(map(int, input().split()))
    dest = tuple(map(int, input().split()))
    cnt = solve(n, src, dest)
    res.append(cnt)

print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전형적인 BFS 문제였다.&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/BOJ-7562.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/BOJ-7562.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 빙산</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2573&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2573&quot;&gt;백준 2573번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, m = map(int, input().split())
graph = []
for _ in range(n):
    tmp = map(int, input().split())
    graph.append(list(tmp))

ices = set()
for i in range(n):
    for j in range(m):
        if graph[i][j] &amp;gt; 0:
            ices.add((i, j))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def melt(ices):
    new_ices = set()
    dels = set()
    for x, y in ices:
        cnt = 0
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and graph[nx][ny] == 0:
                cnt += 1
        new_ices.add((x, y, graph[x][y]-cnt))
    # 빙산 녹이기
    for x, y, val in new_ices:
        graph[x][y] = max(0, val)
        if graph[x][y] == 0:
            dels.add((x, y))
    # 녹은 빙산은 제외
    ices = ices - dels
    return ices

def bfs(x, y):
    q = deque([(x, y)])
    visited = {(x, y)}
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and graph[nx][ny] &amp;gt; 0 and (nx, ny) not in visited:
                visited.add((nx, ny))
                q.append((nx, ny))
    return len(visited)


res = 0
while True:
    res += 1
    ices = melt(ices)
    # 빙산이 다 녹아버린 상태
    if not ices:
        print(0)
        break
    # 임의의 점에서 BFS 수행
    for x, y in ices:
        cnt = bfs(x, y)
        break
    # 빙산이 두 덩어리 이상으로 나눠짐
    if cnt &amp;lt; len(ices):
        print(res)
        break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그래프 문제로 알고 풀었는데 사실은 구현에 더 초점이 맞춰진 문제였다. 그냥 문제에서 제시한 대로 빙산이 녹는 걸 구현한 후, BFS를 이용해서 연결된 빙산의 수를 구해 전체 빙산의 수보다 적다면 빙산이 나눠진 것이므로 위와 같은 방식으로 풀 수 있었다.&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/BOJ-2573.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/BOJ-2573.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - DFS 스페셜 저지</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem16964&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16964&quot;&gt;백준 16964번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;틀린 풀이(시간초과)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
graph = [set() for _ in range(n+1)]
for _ in range(n-1):
    i, j = map(int, input().split())
    graph[i].add(j)
    graph[j].add(i)
stack = list(map(int, input().split()))
my_stack = []
visited = [False] * len(graph)


def dfs(i, visited):
    global my_stack
    visited[i] = True
    my_stack.append(i)
    for j in range(len(stack)):
        if not visited[stack[j]] and stack[j] in graph[i]:
            dfs(stack[j], visited)


dfs(stack[0], visited)
if my_stack == stack:
    print(1)
else:
    print(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for j in range(len(stack))&lt;/code&gt; 이 부분이 $O(N)$이기 때문에 전체 시간복잡도가 $O(N^{2})$가 되서 시간초과로 틀렸다. 그래서 어떻게 해야할까 고민하다가 인접 리스트를 탐색의 순서대로 정렬해도 같은 결과가 아닌가??라는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;올바른 풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
graph = [[] for _ in range(n+1)]
for _ in range(n-1):
    i, j = map(int, input().split())
    graph[i].append(j)
    graph[j].append(i)
stack = list(map(int, input().split()))
d = {}
for i in range(len(stack)):
    d[stack[i]] = i
# 탐색해야 하는 순서대로 정렬
for g in graph:
    g.sort(key=lambda x: d[x])
my_stack = []
visited = [False] * len(graph)


def dfs(i, visited):
    global my_stack
    visited[i] = True
    my_stack.append(i)
    for j in graph[i]:
        if not visited[j]:
            dfs(j, visited)


dfs(1, visited)
if my_stack == stack:
    print(1)
else:
    print(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사실 이 문제에 좀 오류가 있는 것 같은게 &lt;code class=&quot;highlighter-rouge&quot;&gt;dfs(stack[0], visited)&lt;/code&gt;로 하면 100% 까지 맞다가 틀린다. 항상 1번부터 탐색을 하기 때문에 2번부터 탐색을 하면 올바른 DFS라도 틀려야한다는데 좀 억지스러웠다. 여튼 &lt;code class=&quot;highlighter-rouge&quot;&gt;dfs(1, visited)&lt;/code&gt;로 해야한다.&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/BOJ-16964.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/BOJ-16964.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 토마토(7576번, 7569번)</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem7576&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7576&quot;&gt;백준 7576번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;틀린 풀이(시간초과)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

m, n = map(int, input().split())
graph = []
for _ in range(n):
    tmp = list(map(int, input().split()))
    graph.append(tmp)

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y):
    if graph[x][y] != 1:
        return
    q = deque([(x, y)])
    visited = set()
    visited.add((x, y))
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and (nx, ny) not in visited:
                if graph[nx][ny] == -1:
                    continue
                visited.add((nx, ny))
                if graph[nx][ny] == 0:
                    graph[nx][ny] = graph[x][y]+1
                else:
                    graph[nx][ny] = min(graph[nx][ny], graph[x][y]+1)
                q.append((nx, ny))

for i in range(n):
    for j in range(m):
        bfs(i, j)

impossible = False
max_num = 1
for i in range(n):
    if not impossible:
        for j in range(m):
            if graph[i][j] == -1:
                continue
            if graph[i][j] == 0:
                impossible = True
                break
            max_num = max(max_num, graph[i][j])

if impossible:
    print(-1)
elif max_num == 1:
    print(0)
else:
    print(max_num-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;i, j&lt;/code&gt;에서 BFS를 수행하니 시간 초과로 계속해서 실패했다. 
이 문제의 관건은 익은 사과(즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;graph[i][j] == 1&lt;/code&gt;)들을 큐에 넣어주고 BFS를 수행해야 하는 것이었다. 생각해보면 익은 사과들의 레벨은 모두 0이므로 다같이 큐에 넣어줘야 최적해를 구해줄 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;올바른 풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

m, n = map(int, input().split())
graph = []
for _ in range(n):
    tmp = list(map(int, input().split()))
    graph.append(tmp)

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(q):
    visited = set()
    for x, y in q:
        visited.add((x, y))
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and (nx, ny) not in visited:
                if graph[nx][ny] == -1:
                    continue
                visited.add((nx, ny))
                graph[nx][ny] = graph[x][y]+1
                q.append((nx, ny))


q = deque()
for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            q.append((i, j))

bfs(q)

impossible = False
max_num = 1
for i in range(n):
    if not impossible:
        for j in range(m):
            if graph[i][j] == -1:
                continue
            if graph[i][j] == 0:
                impossible = True
                break
            max_num = max(max_num, graph[i][j])

if impossible:
    print(-1)
elif max_num == 1:
    print(0)
else:
    print(max_num-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem7569&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7569&quot;&gt;백준 7569번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

m, n, h = map(int, input().split())
graph = [[] for _ in range(h)]
for i in range(h):
    for j in range(n):
        tmp = list(map(int, input().split()))
        graph[i].append(tmp)

dx = [-1, 1, 0, 0, 0, 0]
dy = [0, 0, -1, 1, 0, 0]
dz = [0, 0, 0, 0, -1, 1]


def bfs(q):
    visited = set()
    for z, x, y in q:
        visited.add((z, x, y))
    visited.add((z, x, y))
    while q:
        z, x, y = q.popleft()
        for i in range(6):
            nz, nx, ny = z+dz[i], x+dx[i], y+dy[i]
            if 0 &amp;lt;= nz &amp;lt; h and 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m:
                if graph[nz][nx][ny] != -1 and (nz, nx, ny) not in visited:
                    visited.add((nz, nx, ny))
                    graph[nz][nx][ny] = graph[z][x][y]+1
                    q.append((nz, nx, ny))
    

q = deque()
for i in range(h):
    for j in range(n):
        for k in range(m):
            if graph[i][j][k] == 1:
                q.append((i, j, k))

bfs(q)

max_num = 1
impossible = False
for i in range(h):
    for j in range(n):
        for k in range(m):
            if graph[i][j][k] == -1:
                continue
            if graph[i][j][k] == 0:
                impossible = True
            else:
                max_num = max(max_num, graph[i][j][k])

if impossible:
    print(-1)
elif max_num == 1:
    print(0)
else:
    print(max_num - 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에 문제와 거의 비슷하지만, z축까지 생각해줘야하는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-7576.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-7576.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 단지번호붙이기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2667&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2667&quot;&gt;백준 2667번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n = int(input())
graph = []
for _ in range(n):
    tmp = [int(x) for x in input()]
    graph.append(tmp)
total_cnt = 0
res = []

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y, graph):
    global total_cnt, res
    if graph[x][y] == 0:
        return
    total_cnt += 1
    cnt = 0
    q = deque([(x, y)])
    graph[x][y] = 0
    while q:
        x, y = q.popleft()
        cnt += 1
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and graph[nx][ny] == 1:
                graph[nx][ny] = 0
                q.append((nx, ny))
    res.append(cnt)


for i in range(n):
    for j in range(n):
        bfs(i, j, graph)
res.sort()

print(total_cnt)
print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2667.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2667.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 바이러스</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2606&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2606&quot;&gt;백준 2606번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
m = int(input())
graph = [[] for _ in range(n+1)]
for _ in range(m):
    i, j = map(int, input().split())
    graph[i].append(j)
    graph[j].append(i)
visited = [False] * (n+1)
cnt = 0


def dfs(i, visited):
    global cnt
    visited[i] = True
    cnt += 1
    for j in graph[i]:
        if not visited[j]:
            dfs(j, visited)


dfs(1, visited)
print(cnt-1)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2606.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2606.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 보물섬</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2589&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2589&quot;&gt;백준 2589번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, m = map(int, input().split())
graph = []
for _ in range(n):
    tmp = [1 if x == 'L' else 0 for x in input()]
    graph.append(tmp)

starts = []
for i in range(n):
    for j in range(m):
        # 출발가능한 곳들
        if graph[i][j] == 1:
            starts.append((i, j))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


# bfs를 수행하면서 start에서 최단거리가 가장 먼 곳까지의 거리 탐색
def bfs(start):
    x, y = start
    res = cnt = 0
    q = deque([(x, y, cnt)])
    visited = set()
    visited.add((x, y))
    while q:
        x, y, cnt = q.popleft()
        res = max(res, cnt)
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and graph[nx][ny] == 1 and (nx, ny) not in visited:
                visited.add((nx, ny))
                q.append((nx, ny, cnt+1))
    return res


res = 0
for start in starts:
    res = max(res, bfs(start))
print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2589.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2589.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 벽 부수고 이동하기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2206&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2206&quot;&gt;백준 2206번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, m = map(int, input().split())
graph = []
for _ in range(n):
    tmp = [int(x) for x in input()]
    graph.append(tmp)

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y):
    crush = False
    cnt = 1
    q = deque([(x, y, crush, cnt)])
    # 벽을 부수지 않고 온 경우
    visit1 = [[False for _ in range(m)] for _ in range(n)]
    # 벽을 부수고 온 경우
    visit2 = [[False for _ in range(m)] for _ in range(n)]
    while q:
        x, y, crush, cnt = q.popleft()
        if x == n-1 and y  == m-1:
            return cnt
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m:
                # 벽을 부수지 않고 왔다
                if not crush:
                    # 안 부시고 새로 감
                    if graph[nx][ny] == 0 and visit1[nx][ny] == 0:
                        visit1[nx][ny] = True
                        q.append((nx, ny, crush, cnt+1))
                    # 새로 부신다
                    elif graph[nx][ny] == 1:
                        visit2[nx][ny] = True
                        q.append((nx, ny, True, cnt+1))
                # 벽을 부수고 왔다
                else:
                    if graph[nx][ny] == 0 and visit2[nx][ny] == 0:
                        visit2[nx][ny] = True
                        q.append((nx, ny, crush, cnt+1))
    return -1


print(bfs(0, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;벽을 부수고 왔을 때랑 아닐 때랑 방문 여부 행렬을 다르게 놓고 풀어야 하는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2206.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2206.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 숨바꼭질, Gold5 - 숨바꼭질 3</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1697&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1697&quot;&gt;백준 1697번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, k = map(int, input().split())

def bfs(n, k):
    cnt = 0
    q = deque([(n, cnt)])
    visited = set()
    while q:
        now, cnt = q.popleft()
        if now == k:
            return cnt
        if 0 &amp;lt;= now-1 and (now-1) not in visited:
            visited.add(now-1)
            q.append((now-1, cnt+1))
        if now+1 &amp;lt;= int(1e5) and now+1 not in visited:
            visited.add(now+1)
            q.append((now+1, cnt+1))
        if 2*now &amp;lt;= int(1e5) and 2*now not in visited:
            visited.add(2*now)
            q.append((2*now, cnt+1))
    return -1


print(bfs(n, k))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem13549&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13549&quot;&gt;백준 13549번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, k = map(int, input().split())


def bfs(n, k):
    cnt = 0
    q = deque([(n, cnt)])
    visited = set()
    while q:
        now, cnt = q.popleft()
        if now == k:
            return cnt
        # 순간이동 하는 것을 먼저 둔다.
        if 2*now &amp;lt;= int(1e5) and 2*now not in visited:
            visited.add(2*now)
            q.append((2*now, cnt))
        if 0 &amp;lt;= now-1 and (now-1) not in visited:
            visited.add(now-1)
            q.append((now-1, cnt+1))
        if now+1 &amp;lt;= int(1e5) and now+1 not in visited:
            visited.add(now+1)
            q.append((now+1, cnt+1))
    return -1


print(bfs(n, k))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-1697.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-1697.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
