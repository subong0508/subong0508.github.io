<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 04 Feb 2021 20:25:34 +0900</pubDate>
    <lastBuildDate>Thu, 04 Feb 2021 20:25:34 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>프로그래머스 Lv3 - 징검다리 건너기</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons64062&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/64062&quot;&gt;프로그래머스 64062번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def run_possible(stones, n, k):
    stones = stones.copy()
    # (n-1)명이 징검다리를 건넌 후 결과
    stones = [max(0, x-n+1) for x in stones]
    i = 0
    while i &amp;lt; len(stones):
        if stones[i] &amp;gt; 0:
            i += 1
        else:
            j = i+1
            # 0의 연속된 갯수
            while j &amp;lt; len(stones) and stones[j] &amp;lt;= 0:
                j += 1
            # 0이 k개 이상 연속되면 건널 수 없다.
            if j-i &amp;gt;= k:
                return False
            i = j
    return True

def solution(stones, k):
    l = 1
    r = sum(stones)
    answer = l
    while l &amp;lt;= r:
        mid = (l + r) // 2
        if run_possible(stones, mid, k):
            # 현재 값 저장
            answer = mid
            l = mid + 1
        else:
            r = mid - 1
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;run_possible&lt;/code&gt; 함수를 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;명이 직접 건너는 걸로 짰는데 효율성 테스트에서 전멸을 당했다.&lt;/p&gt;

&lt;p&gt;그런데 문제의 조건에서 &lt;strong&gt;단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.&lt;/strong&gt; 라고 했기 때문에 0인 디딤돌 바로 다음으로 건너야 한다.&lt;/p&gt;

&lt;p&gt;이 말은 0이 k개 이상 연속되면 건널 수 없다는 소리이기 때문에 $O(n)$으로 짤 수 있었다.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/04/PR-64062.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/04/PR-64062.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 합이 0인 네 정수</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem7453&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7453&quot;&gt;백준 7453번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
A = [0] * n
B = [0] * n
C = [0] * n
D = [0] * n

for i in range(n):
    a, b, c, d = map(int, input().split())
    A[i] = a
    B[i] = b
    C[i] = c
    D[i] = d

left = []
right = []

for i in range(n):
    for j in range(n):
        left.append(A[i]+B[j])
        right.append(C[i]+D[j])

d = {}
for r in right:
    d[r] = d.get(r, 0) + 1

res = 0
for l in left:
    target = 0 - l
    res += d.get(target, 0)
print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원래 이분탐색으로 풀었다가 시간초과해서 딕셔너리로 바꿨다. ㅠ&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/04/BOJ-7453.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/04/BOJ-7453.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - 기타 레슨</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2343&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2343&quot;&gt;백준 2343번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = list(map(int, input().split()))


def is_possible(size):
    total = 0
    cnt = 1
    for i in range(n):
        if total + arr[i] &amp;gt; size:
            cnt += 1
            total = arr[i]
        else:
            total += arr[i] 
    return cnt &amp;lt;= m 


l = 1
r = sum(arr)
max_val = max(arr)
res = r
while l &amp;lt;= r:
    mid = (l + r) // 2
    if mid &amp;gt;= max_val and is_possible(mid):
        res = mid
        r = mid - 1
    else:
        l = mid + 1

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mid &amp;gt;= max_val&lt;/code&gt; 라는 조건을 못 생각해서 다른 분들의 풀이를 보고서야 이해했다. 항상 블루레이의 크기 레슨의 최댓값 이상이어야한다.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/04/BOJ-2343.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/04/BOJ-2343.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 랜선 자르기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1654&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1654&quot;&gt;백준 1654번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;k, n = map(int, input().split())
arr = [0] * k
for i in range(k):
    arr[i] = int(input())


def get_num(arr, length):
    cnt = 0
    for a in arr:
        cnt += a // length
    return cnt


l = 1
r = sum(arr)
res = 0

while l &amp;lt;= r:
    mid = (l + r) // 2
    ans = get_num(arr, mid)
    if ans &amp;gt;= n:
        res = mid
        l = mid+1
    else:
        r = mid-1

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 04 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/04/BOJ-1654.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/04/BOJ-1654.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 게임</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1072&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1072&quot;&gt;백준 1072번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;x, y = map(int, input().split())
z = int(100 * y / x)

l = 1
r = x
res = -1

while l &amp;lt;= r:
    mid = (l + r) // 2
    new_z = int(100 * (y+mid) / (x+mid))
    if new_z &amp;lt;= z:
        l = mid + 1
    else:
        res = mid
        r = mid - 1

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 04 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/04/BOJ-1072.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/04/BOJ-1072.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver4 - 수 찾기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1920&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1920&quot;&gt;백준 1920번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))
m = int(input())
nums = list(map(int, input().split()))
arr.sort()

def binary_search(num, arr):
    left = 0
    right = len(arr)-1
    while left &amp;lt;= right:
        mid = (left + right) // 2
        if arr[mid] == num:
            return mid
        elif arr[mid] &amp;gt; num:
            right = mid - 1
        else:
            left = mid + 1
    return -1

for num in nums:
    idx = binary_search(num, arr)
    if idx != -1:
        print(1)
    else:
        print(0)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 03 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/03/BOJ-1920.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/03/BOJ-1920.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver4 - 듣보잡</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1764&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1764&quot;&gt;백준 1764번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
no_listen = set()
for _ in range(n):
    no_listen.add(input())
no_see = set()
for _ in range(m):
    no_see.add(input())

res = no_listen &amp;amp; no_see
print(len(res))
res = sorted(res)
print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이분탐색을 활용할 수도 있겠지만 파이썬의 내장자료형인 &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;을 통해 더 효율적으로 풀 수 있다.&lt;/p&gt;
</description>
        <pubDate>Wed, 03 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/03/BOJ-1764.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/03/BOJ-1764.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv1 - 실패율</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42889&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42889&quot;&gt;프로그래머스 42889번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(N, stages):
    d = {i: 0 for i in range(1, N+1)}
    stages.sort()
    prev = stages[0]
    total = len(stages)
    cnt = 1
    for i in range(1, len(stages)):
        if prev not in d:
            break
        if stages[i] == prev:
            cnt += 1
        elif stages[i] != prev:
            d[prev] = cnt / total
            total -= cnt
            cnt = 1
            prev = stages[i]
        if i == len(stages)-1 and prev in d:
            d[prev] = cnt / total            
    answer = sorted(d.keys(), key=lambda x: -d[x])
    return answer
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 03 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/03/PR-42889.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/03/PR-42889.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 안테나</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18310&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18310&quot;&gt;백준 18310번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))
arr.sort()


def cal_distance(arr, mid):
    total = 0
    for a in arr:
        total += abs(arr[mid]-a)
    return total


if len(arr) % 2 == 1:
    mid = len(arr) // 2
else:
    mid1, mid2 = len(arr)//2-1, len(arr)//2
    if cal_distance(arr, mid1) &amp;gt; cal_distance(arr, mid2):
        mid = mid2
    else:
        mid = mid1 

print(arr[mid])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 03 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/03/BOJ-18310.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/03/BOJ-18310.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 카드 정렬하기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1715&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1715&quot;&gt;백준 1715번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

n = int(input())
q = []
for i in range(n):
    a = int(input())
    heapq.heappush(q, a)

res = 0
while len(q) &amp;gt;= 2:
    a = heapq.heappop(q)
    b = heapq.heappop(q)
    res += a+b
    heapq.heappush(q, a+b)
    
print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첨에는 그냥 array로 받고 sort해서  &lt;code class=&quot;highlighter-rouge&quot;&gt;deque&lt;/code&gt;로 풀었는데 새로운 원소가 더해질 때 그렇게 하면 최솟값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt;되지 않기 때문에 안된다.&lt;/p&gt;
</description>
        <pubDate>Wed, 03 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/03/BOJ-1715.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/03/BOJ-1715.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
