<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 20 Feb 2021 01:13:43 +0900</pubDate>
    <lastBuildDate>Sat, 20 Feb 2021 01:13:43 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>프로그래머스 Lv2 - 프렌즈4블록</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons17679&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/17679&quot;&gt;프로그래머스 17679번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def erase(m, n, board):
    s = set()
    for i in range(m-1):
        for j in range(n-1):
            # 이미 빈 상태
            if board[i][j] == 0:
                continue
            if board[i][j] == board[i+1][j] == board[i][j+1] == board[i+1][j+1]:
                s |= {(i, j), (i+1, j), (i, j+1), (i+1, j+1)}
    for i, j in s:
        board[i][j] = 0
    return len(s)

def go_down(m, n, board):
    for j in range(n):
        for i in range(m-1, -1, -1):
            if board[i][j] != 0:
                continue
            k = i
            while k &amp;gt;= 0 and board[k][j] == 0:
                k -= 1
            if k &amp;gt;= 0:
                board[i][j], board[k][j] = board[k][j], board[i][j]

def solution(m, n, board):
    board = [list(b) for b in board]
    answer = 0
    while True:
        tmp = erase(m, n, board)
        # 새로 지울게 없다면
        if tmp == 0:
            break
        answer += tmp
        go_down(m, n, board)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;애니팡..&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/PR-17679.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/PR-17679.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 인내의 도미노 장인 호석</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem20165&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20165&quot;&gt;백준 20165번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m, r = map(int, input().split())
domino = [list(map(int, input().split())) for _ in range(n)]
domino_origin = [[-1] * m for _ in range(n)]
for i in range(n):
    for j in range(m):
        domino_origin[i][j] = domino[i][j]
attack = []
defence = []
for i in range(2*r):
    if i % 2 == 0:
        x, y, d = input().split()
        attack.append((int(x)-1, int(y)-1, d))
    else:
        x, y = map(int, input().split())
        defence.append((x-1, y-1))
        
direcs = {&quot;E&quot;: [0, 1], &quot;W&quot;: [0, -1], &quot;S&quot;: [1, 0], &quot;N&quot;: [-1, 0]}

def hit(x, y, d):
    global cnt
    if x &amp;lt; 0 or x &amp;gt;= n or y &amp;lt; 0 or y &amp;gt;= m:
        return
    k = domino[x][y]
    dx, dy = direcs[d]
    for i in range(1, k):
        nx, ny = x+i*dx, y+i*dy
        hit(nx, ny, d)
    # 도미노 쓰러뜨리기
    if domino[x][y] != 0:
        cnt += 1
        domino[x][y] = 0

def up(x, y):
    if x &amp;lt; 0 or x &amp;gt;= n or y &amp;lt; 0 or y &amp;gt;= m:
        return
    domino[x][y] = domino_origin[x][y]

cnt = 0
for i in range(r):
    hit(*attack[i])
    up(*defence[i])

for i in range(n):
    domino[i] = ['S' if e != 0 else 'F' for e in domino[i]]

print(cnt)
for i in range(n):
    print(*domino[i])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/BOJ-20165.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/BOJ-20165.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 미세먼지 안녕!</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem17144&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17144&quot;&gt;백준 17144번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;r, c, t = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(r)]
c1 = -1
for i in range(r):
    if graph[i][0] == -1:
        c1 = i
        break
c2 = c1+1

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dust():
    q = []
    for i in range(r):
        for j in range(c):
            if graph[i][j] &amp;gt; 0:
                q.append((i, j))
    infected = dict()
    deleted = dict()
    for x, y in q:
        cnt = 0
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; r and 0 &amp;lt;= ny &amp;lt; c and graph[nx][ny] != -1:
                cnt += 1
                infected[(nx, ny)] = infected.get((nx, ny), 0) + graph[x][y] // 5
        deleted[(x, y)] = cnt * (graph[x][y] // 5)
    for x, y in infected:
        graph[x][y] += infected[(x, y)]
    for x, y in deleted:
        graph[x][y] -= deleted[(x, y)]

def clean(xc, up):
    # 공기청정기 위/아래
    if up:
        ds = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    else:
        ds = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    x, y = xc, 1
    i = 0
    s = set()
    while True:
        nx, ny = x+ds[i][0], y+ds[i][1]
        if nx == xc and y == 0:
            break
        # 가장자리라면
        if nx &amp;lt; 0 or nx &amp;gt;= r or ny &amp;lt; 0 or ny &amp;gt;= c:
            i += 1
        else:
            s.add((nx, ny, graph[x][y]))
            x, y = nx, ny
    graph[xc][1] = 0
    for x, y, val in s:
        graph[x][y] = val

for _ in range(t):
    dust()
    clean(c1, True)
    clean(c2, False)

res = 0
for i in range(r):
    for j in range(c):
        if graph[i][j] &amp;gt; 0:
            res += graph[i][j]

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;쉬울 것 같았는데 생각보다 구현이 빡셌다.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/BOJ-17144.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/BOJ-17144.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 치킨 배달</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem15686&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15686&quot;&gt;백준 15686번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

n, m = map(int, input().split())
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))
chickens = [(i, j) for j in range(n) for i in range(n) if graph[i][j] == 2]
houses = [(i, j) for j in range(n) for i in range(n) if graph[i][j] == 1]

def cal_dist(h: tuple, c: tuple):
    return abs(h[0]-c[0])+abs(h[1]-c[1])

def cal_min_dist(h: tuple, cs: list):
    min_dist = int(1e9)
    for c in cs:
        min_dist = min(min_dist, cal_dist(h, c))
    return min_dist

res = int(1e9)
combs = combinations(chickens, m)
for comb in combs:
    tmp = 0
    cs = list(comb)
    for h in houses:
        tmp += cal_min_dist(h, cs)
    res = min(res, tmp)

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/BOJ-15686.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/BOJ-15686.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 감시 피하기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18428&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18428&quot;&gt;백준 18428번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

n = int(input())
graph = []
for _ in range(n):
    graph.append(input().split())
# teachers
ts = set()
candidates = []
for i in range(n):
    for j in range(n):
        if graph[i][j] == 'T':
            ts.add((i, j))
        elif graph[i][j] == 'X':
            candidates.append((i, j))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
        
combs = combinations(candidates, 3)


def cctv(x, y, i, visited):
    global s
    visited.add((x, y))
    if graph[x][y] == 'S':
        s.add((x, y))
    nx, ny = x+dx[i], y+dy[i]
    if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and (nx, ny) not in visited and graph[nx][ny] != 'O':
        cctv(nx, ny, i, visited)


cnt = 36
for comb in combs:
    s = set()
    for i, j in comb:
        graph[i][j] = 'O'
    for t in ts:
        visited = set()
        for i in range(4):
            cctv(t[0], t[1], i, visited)
    for i, j in comb:
        graph[i][j] = 'X'
    cnt = min(cnt, len(s))

if not cnt:
    print(&quot;YES&quot;)
else:
    print(&quot;NO&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일반적인 DFS가 아니라 방향이 있는 DFS로 풀면 된다. 사실은 재귀가 아닌 단순 반복문으로도 풀 수 있는 문제다.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18428.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18428.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 경쟁적 전염</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18405&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18405&quot;&gt;백준 18405번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque


n, k = map(int, input().split())
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))
s, x, y = map(int, input().split())

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(graph):
    cnt = 1
    q = []
    visited = [[False] * (1+n) for _ in range(1+n)]
    for i in range(n):
        for j in range(n):
            if graph[i][j] != 0:
                q.append((i, j, cnt))
                visited[i][j] = True
    # 1번 바이러스부터 순서대로 탐색
    q.sort(key=lambda x: graph[x[0]][x[1]])
    q = deque(q)
    while q:
        x, y, cnt = q.popleft()
        # s초가 지나면 종료
        if cnt &amp;gt; s:
            return
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and not visited[nx][ny] and graph[nx][ny] == 0:
                visited[nx][ny] = True
                graph[nx][ny] = graph[x][y]
                q.append((nx, ny, cnt+1))


bfs(graph)
print(graph[x-1][y-1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1번부터 순서대로 탐색하도록 BFS를 구현하는게 조금 까다로운 문제였다.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18405.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18405.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - 특정 거리의 도시 찾기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18352&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18352&quot;&gt;백준 18352번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, m, k, x = map(int, input().split())
graph = [[] for _ in range(n+1)]
for _ in range(m):
    i, j = map(int, input().split())
    graph[i].append(j)
res = []


def bfs(start):
    global res
    cnt = 0
    q = deque([(start, cnt)])
    visited = [False] * (1+n)
    visited[start] = True
    while q:
        now, cnt = q.popleft()
        if cnt == k:
            res.append(now)
        for v in graph[now]:
            if not visited[v]:
                visited[v] = True
                q.append((v, cnt+1))
    

bfs(x)

if not res:
    print(-1)
else:
    res.sort()
    print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18352.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18352.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 인구 이동</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem16234&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16234&quot;&gt;백준 16234번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, l, r = map(int, input().split())
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y, visited):
    if visited[x][y]:
        return 0
    q = deque([(x, y)])
    visited[x][y] = True
    neighbors = [(x, y)]
    cnt = 0
    while q:
        x, y = q.popleft()
        cnt += 1
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and not visited[nx][ny]:
                diff = abs(graph[x][y]-graph[nx][ny])
                if l &amp;lt;= diff &amp;lt;= r:
                    visited[nx][ny] = True
                    q.append((nx, ny))
                    neighbors.append((nx, ny))
    # 연합을 맺지 못함
    if cnt == 1:
        return 0
    total = 0
    for x, y in neighbors:
        total += graph[x][y]
    for x, y in neighbors:
        graph[x][y] = total // len(neighbors)
    return cnt


res = 0
while True:
    cnt = 0
    visited = [[False] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            cnt += bfs(i, j, visited)
    if cnt == 0:
        print(res)
        break
    res += 1
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-16234.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-16234.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 연산자 끼워넣기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14888&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14888&quot;&gt;백준 14888번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))
ops = list(map(int, input().split()))
min_val = int(1e9)
max_val = -int(1e9)


def solution(idx, ops, val):
    global min_val, max_val
    if idx == n-1:
        min_val = min(min_val, val)
        max_val = max(max_val, val)
        return

    for i in range(4):
        if ops[i] &amp;lt;= 0:
            continue
        ops[i] -= 1
        if i == 0:
            solution(idx+1, ops, val+arr[idx+1])
        elif i == 1:
            solution(idx+1, ops, val-arr[idx+1])
        elif i == 2:
            solution(idx+1, ops, val*arr[idx+1])
        elif i == 3:
            if val &amp;lt; 0:
                solution(idx+1, ops, -(-val // arr[idx+1]))
            else:
                solution(idx+1, ops, val // arr[idx+1])
        ops[i] += 1


solution(0, ops, arr[0])

print(max_val)
print(min_val)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;완전 탐색/DFS를 통해 풀 수 있었다.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-14888.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-14888.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 괄호 변환</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons60058&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/60058&quot;&gt;프로그래머스 60058번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def is_right(p):
    stack = []
    for ch in p:
        if ch == '(':
            stack.append(ch)
        else:
            if len(stack) == 0 or stack.pop() != '(':
                return False
    return len(stack) == 0

def is_balanced(p):
    return p.count('(') == p.count(')')

def parse(p):
    u, v = p, ''
    for i in range(1, len(p)):
        u_, v_ = p[:i], p[i:]
        if is_balanced(u_) and is_balanced(v_):
            u, v = u_, v_
            break
    return u, v

def solution(p):
    answer = ''
    if is_right(p):
        return p
    u, v = parse(p)
    if is_right(u):
        answer = u + solution(v)
    else:
        answer += '('
        answer += solution(v)
        answer += ')'
        for ch in u[1:-1]:
            if ch == '(':
                answer += ')'
            else:
                answer += '('
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;문제 자체가 헷갈리게 서술되어 있어서 많이 헤맸다..&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/PR-60058.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/PR-60058.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
