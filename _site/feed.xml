<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 02 Mar 2021 00:04:26 +0900</pubDate>
    <lastBuildDate>Tue, 02 Mar 2021 00:04:26 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>프로그래머스 Lv3 - 섬 연결하기</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42861&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42861&quot;&gt;프로그래머스 42861번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    parent[a] = b

def solution(n, costs):
    answer = 0
    parent = [i for i in range(n)]
    costs.sort(key=lambda x: x[2])
    for a, b, c in costs:
        if find_parent(parent, a) != find_parent(parent, b):
            union(parent, a, b)
            answer += c
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;평범한 MST 문제였다.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/01/PR-42861.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/01/PR-42861.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 친구 네트워크</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem4195&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/4195&quot;&gt;백준 4195번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;t = int(input())


def solution(f):
    # 이름: 그룹
    network = {}
    # 그룹: 인원수
    network_inv = {}
    res = []
    for i in range(f):
        f1, f2 = input().split()
        if f1 not in network and f2 not in network: # 새로운 그룹을 만든다
            network[f1] = network[f2] = i
            network_inv[i] = 2
            res.append(2)
        elif f1 in network and f2 not in network: # f2를 f1 무리에 넣기
            network[f2] = network[f1]
            network_inv[network[f1]] += 1
            res.append(network_inv[network[f1]])
        elif f2 in network and f1 not in network: # f1을 f2 무리에 넣기
            network[f1] = network[f2]
            network_inv[network[f2]] += 1
            res.append(network_inv[network[f2]])
        elif f1 in network and f2 in network and network[f1] != network[f2]:
            # union
            network_inv[network[f1]] += network_inv[network[f2]]
            network_inv[network[f2]] = 0
            res.append(network_inv[network[f1]])
            prev = network[f2]
            for k, v in network.items():
                if v == prev:
                    network[k] = network[f1]
        elif f1 in network and f2 in network and network[f1] == network[f2]:
            res.append(network_inv[network[f1]])
    return res


res = []
for _ in range(t):
    f = int(input())
    tmp = solution(f)
    res.append(tmp)

for tmp in res:
    print(*tmp, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/01/BOJ-4195.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/01/BOJ-4195.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold1 - 최종 순위</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem3665&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/3665&quot;&gt;백준 3665번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

t = int(input())

def solution(n, m, ranks, changes):
    graph = [[0] * (n+1) for _ in range(n+1)]
    indegrees = [0] * (n+1)
    for i in range(n):
        win = ranks[i]
        for j in range(i+1, n):
            fail = ranks[j]
            graph[win][fail] = 1
            indegrees[fail] += 1
    
    for i in range(m):
        a, b = changes[i]
        # a -&amp;gt; b =&amp;gt; b -&amp;gt; a
        if graph[a][b] == 1:
            graph[b][a] = 1
            graph[a][b] = 0
            indegrees[a] += 1
            indegrees[b] -= 1
        # b -&amp;gt; a =&amp;gt; a -&amp;gt; b
        else:
            graph[a][b] = 1
            graph[b][a] = 0
            indegrees[b] += 1
            indegrees[a] -= 1

    q = deque()
    for i in range(1, n+1):
        if indegrees[i] == 0:
            q.append(i)

    res = []
    for _ in range(n):
        if len(q) == 0:
            return &quot;IMPOSSIBLE&quot;
        if len(q) &amp;gt; 1:
            return &quot;?&quot;
        now = q.popleft()
        res.append(str(now))
        for i in range(1, n+1):
            if graph[now][i] == 1:
                indegrees[i] -= 1
                if indegrees[i] == 0:
                    q.append(i)
    return ' '.join(res)


res = []
for i in range(t):
    n = int(input())
    ranks = list(map(int, input().split()))
    m = int(input())
    changes = []
    for j in range(m):
        a, b = map(int, input().split())
        changes.append((a, b))
    res.append(solution(n, m, ranks, changes))

for r in res:
    print(r)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보기 드문 위상정렬 문제… 두번째 푸는 건데도 어렵다.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/01/BOJ-3665.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/01/BOJ-3665.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 행성 터널</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2887&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2887&quot;&gt;백준 2887번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
coords = []
parent = [i for i in range(n)]
for i in range(n):
    x, y, z = map(int, input().split())
    coords.append((i, x, y, z))

INF = int(1e9)
edges = {}

# 가까운 좌표끼리 거리를 계산한다.
for k in range(1, 4):
    coords_ = sorted(coords, key=lambda x: x[k])
    for i in range(1, n):
        a, x1, y1, z1 = coords_[i-1]
        b, x2, y2, z2 = coords_[i]
        d = min([abs(x1-x2), abs(y1-y2), abs(z1-z2)])
        edges[(a, b)] = min(edges.get((a, b), INF), d)

edges = sorted(edges.items(), key=lambda x: x[1])

def find_parent(x):
    if parent[x] != x:
        parent[x] = find_parent(parent[x])
    return parent[x]

def union(a, b):
    a = find_parent(a)
    b = find_parent(b)
    if a &amp;lt; b:
        parent[b] = a
    else:
        parent[a] = b

res = 0
for (a, b), c in edges:
    if find_parent(a) != find_parent(b):
        union(a, b)
        res += c

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/01/BOJ-2887.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/01/BOJ-2887.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold3 - 다리 만들기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2146&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2146&quot;&gt;백준 2146번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n = int(input())
graph = []
for _ in range(n):
    tmp = map(int, input().split())
    graph.append(list(tmp))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y, val):
    graph[x][y] = val
    q = deque()
    q.appendleft((x, y))
    res = [(x, y)]
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and graph[nx][ny] == 1:
                graph[nx][ny] = val
                q.appendleft((nx, ny))
                res.append((nx, ny))
    return res


islands = []
val = 2
for i in range(n):
    for j in range(n):
        if graph[i][j] == 1:
            islands.append(bfs(i, j, val))
            val += 1

m = len(islands)
res = int(1e9)
for i in range(m):
    island1 = islands[i]
    for j in range(m):
        if j == i:
            continue
        island2 = islands[j]
        for x1, y1 in island1:
            for x2, y2 in island2:
                res = min(res, abs(x1-x2)+abs(y1-y2)-1)

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;간단한 BFS로 해결할 수 있었다.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/01/BOJ-2146.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/01/BOJ-2146.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 여행 가자</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1976&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1976&quot;&gt;백준 1976번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
m = int(input())
graph = [[0] * (n+1)]
for _ in range(n):
    tmp = map(int, input().split())
    graph.append([0] + list(tmp))
parent = [i for i in range(n+1)]
arr = list(map(int, input().split()))
edges = []

for i in range(1, n+1):
    for j in range(1, n+1):
        if graph[i][j] != 0:
            edges.append((i, j))


def find_parent(x):
    if parent[x] != x:
        parent[x] = find_parent(parent[x])
    return parent[x]

def union(a, b):
    a = find_parent(a)
    b = find_parent(b)
    if a &amp;lt; b:
        parent[b] = a
    else:
        parent[a] = b


for a, b in edges:
    if find_parent(a) != find_parent(b):
        union(a, b)

s = set()
for a in arr:
    s.add(parent[a])

if len(s) == 1:
    print(&quot;YES&quot;)
else:
    print(&quot;NO&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;union-find&lt;/strong&gt; 알고리즘으로 푸는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/01/BOJ-1976.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/01/BOJ-1976.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 도시 분할 계획</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1647&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1647&quot;&gt;백준 1647번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
parent = [i for i in range(n+1)]
edges = []
for _ in range(m):
    a, b, c = map(int, input().split())
    edges.append((a, b, c))


def find_parent(x):
    if parent[x] != x:
        parent[x] = find_parent(parent[x])
    return parent[x]

def union(a, b):
    a = find_parent(a)
    b = find_parent(b)
    parent[a] = b


edges.sort(key=lambda x: x[2])
res = []
for a, b, c in edges:
    if find_parent(a) != find_parent(b):
        union(a, b)
        res.append(c)
    
# 가장 큰 간선을 뺌으로써 두 마을 완성
print(sum(res)-max(res))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/01/BOJ-1647.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/01/BOJ-1647.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold1 - 공항</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem10775&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/10775&quot;&gt;백준 10775번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;G = int(input())
P = int(input())


def dock(g, d):
    # 더 이상 도킹할 수 없는 경우
    if g &amp;lt;= 0:
        return -1
    elif g not in d:
        d[g] = g-1
        return g
    else:
        res = dock(d[g], d)
        if res != -1:
            d[g] = res-1
        return res


cnt = 0
d = {}
arr = []
for _ in range(P):
    g = int(input())
    arr.append(g)

for g in arr:
    if dock(g, d) != -1:
        cnt += 1
    else:
        break

print(cnt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;union-find&lt;/strong&gt; 유형의 응용문제, recursion limit을 늘려줘야 &lt;code class=&quot;highlighter-rouge&quot;&gt;RecursionError&lt;/code&gt;가 나지 않는다.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/01/BOJ-10775.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/01/BOJ-10775.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>Graph Theory with Python</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;서로소 집합&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시간복잡도: $O(V + M \log_{2}{V})$&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# 원소가 속한 집합 찾기
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합 merge
def union(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a &amp;lt; b:
        parent[b] = a
    else:
        parent[a] = b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;사이클 판별&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;for i in range(num_edges):
    a, b = map(int, input().split())
    if find_parent(parent, a) == find_parent(parent, b):
        cycle = True
        print(&quot;Cycle&quot;)
    else:
        union(parent, a, b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;minimum-spanning-tree&quot;&gt;크루스칼 알고리즘: Minimum Spanning Tree&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시간복잡도: $O(E \log {E})$&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;res = 0
edges.sort()
for e in edges:
    cost, a, b = e
    # not cycle
    if find_parent(parent, a) != find_parent(parent, b):
        union(parent, a, b)
        res += cost
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;위상 정렬&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;시간복잡도: $O(V + E)$&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def topological_sort():
    result = []
    q = deque()

    # 진입차수가 0인 노드들 큐에 삽입
    for i in range(1, v+1):
        if indegree[i] == 0:
            q.append(i)

    while q:
        now = q.popleft()
        result.append(now)
        for i in graph[now]:
            indegree[i] -= 1
            # 진입차수가 0이 된다면
            if indegree[i] == 0:
                q.append(i)
    
    return result
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data-structure/2021/02/28/GraphTheory.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data-structure/2021/02/28/GraphTheory.html</guid>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        <category>graph</category>
        
        <category>shortest-path</category>
        
        
        <category>Data-Structure</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 사이클 게임</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem20040&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20040&quot;&gt;백준 20040번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
parent = [i for i in range(n)]


def find_parent(x):
    if parent[x] != x:
        parent[x] = find_parent(parent[x])
    return parent[x]

def union(a, b):
    a = find_parent(a)
    b = find_parent(b)
    if a &amp;lt; b:
        parent[b] = a 
    else:
        parent[a] = b


res = 0
for i in range(1, m+1):
    a, b = map(int, input().split())
    if find_parent(a) == find_parent(b):
        if res == 0:
            res = i
    else:
        union(a, b)

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 28 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/28/BOJ-20040.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/28/BOJ-20040.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
