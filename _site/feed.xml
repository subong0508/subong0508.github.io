<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 28 Feb 2021 00:02:02 +0900</pubDate>
    <lastBuildDate>Sun, 28 Feb 2021 00:02:02 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Shortest Path with Python</title>
        <description>&lt;p&gt;오늘은 파이썬을 이용해 weighted graph(가중치가 있는 그래프)에서 최단 경로를 찾는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;가중치가 없는 그래프라면 &lt;strong&gt;BFS&lt;/strong&gt;를 통해 최단 경로를 손쉽게 구할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;다익스트라 알고리즘&lt;/h1&gt;

&lt;p&gt;다익스트라 알고리즘은 한 노드에서 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘입니다.
다익스트라는 기본적으로 그리디 알고리즘의 한 종류로, 방문하지 않은 노드 중 가장 가까운 노드를 통해 갈 수 있는 경로를 개선합니다.&lt;/p&gt;

&lt;p&gt;다익스트라 알고리즘을 사용할 때는 시간복잡도를 개선하기 위해 힙 자료구조를 사용하고, 시간 복잡도는 $O(E \log {V})$가 됩니다.&lt;/p&gt;

&lt;p&gt;파이썬으로 간단하게 구현하면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq


# weighted graph
graph = [
    [0, 10, 20],
    [2, 0, 3],
    [10, 4, 0]
]
INF = int(1e9)


def dijkstra(start, graph):
    distance = [INF for _ in range(len(graph))]
    distance[start] = 0
    q = []
    heapq.heappush(q, (0, start)) # 거리, 노드
    while q:
        dist, now = heapq.heappop(q)
        # 이미 처리된 노드
        if distance[now] &amp;lt; dist:
            continue
        for i in range(len(graph)):
            if dist+graph[now][i] &amp;lt; distance[i]:
                distance[i] = dist+graph[now][i]
                heapq.heappush(q, (distance[i], i))
    return distance


print(dijkstra(0, graph)) # 0 10 13
print(dijkstra(1, graph)) # 2 0 3
print(dijkstra(2, graph)) # 6 4 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;플로이드 워셜 알고리즘&lt;/h1&gt;

&lt;p&gt;다음은 모든 지점에서 다른 모든 지점으로 가는 최단 경로를 구해주는 플로이드 워셜 알고리즘에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;플로이드 워셜 알고리즘의 시간복잡도는 $O(V^{3})$이라, 일반적인 코딩 테스트 환경에서는 정점의 수가 1000개 이하인 경우만 가능합니다.&lt;/p&gt;

&lt;p&gt;파이썬으로 구현한 코드는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# weighted graph
INF = int(1e9)
graph = [
    [0, 4, INF, 6],
    [3, 0, 7, INF],
    [5, INF, 0, 4],
    [INF, INF, 2, 0]
]
n = len(graph)

for k in range(n):
    for i in range(n):
        for j in range(n):
            graph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j])

print(*graph, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data-structure/2021/02/27/ShortestPath.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data-structure/2021/02/27/ShortestPath.html</guid>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        <category>graph</category>
        
        <category>shortest-path</category>
        
        
        <category>Data-Structure</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 문자열 압축</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons60057&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/60057&quot;&gt;프로그래머스 60057번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def compress(s, n):
    i = 0
    lst = []
    while i &amp;lt; len(s):
        lst.append(s[i:i+n])
        i += n
    string = ''
    prev = lst[0]
    cnt = 1
    for i in range(1, len(lst)):
        if lst[i] != prev:
            string += prev if cnt == 1 else (str(cnt)+prev)
            prev = lst[i]
            cnt = 1
        else:
            cnt += 1
        # 맨마지막인 경우에
        if i == len(lst)-1:
            string += prev if cnt == 1 else (str(cnt)+prev)
    return len(string)

def solution(s):
    answer = len(s)
    for i in range(1, len(s)):
        tmp = compress(s, i)
        if tmp &amp;lt; answer:
            answer = tmp
    return answer
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/27/PR-60057.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/27/PR-60057.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 뱀</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem3190&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/3190&quot;&gt;백준 3190번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
k = int(input())
apples = set()
for _ in range(k):
    x, y = map(int, input().split())
    apples.add((x, y))
m = int(input())
times = []
for _ in range(m):
    t, lr = input().split()
    times.append((int(t), lr))


def rotate(d, lr):
    # 왼쪽으로 90도 회전
    if lr == 'L':
        return (d - 1) % 4
    # 오른쪽으로 90도 회전
    else:
        return (d + 1) % 4


# 동/서/남/북: [dx, dy]
direcs = {0: [0, 1], 1: [1, 0], 2: [0, -1], 3: [-1, 0]}

res = 0
x = y = 1 # 현재 위치
d = 0 # 현재는 동쪽을 보고 있다
tail = (1, 1)
body = [tail]

while True:
    res += 1
    dx, dy = direcs[d] 
    nx, ny = x+dx, y+dy
    # 벽에 부딪힘
    if nx &amp;lt; 1 or nx &amp;gt; n or ny &amp;lt; 1 or ny &amp;gt; n:
        break
    # 자기 몸에 부딪힘
    if (nx, ny) in body:
        break
    if (nx, ny) in apples:
        body.append((nx, ny))
        apples.remove((nx, ny))
    else:
        body.append((nx, ny))
        body = body[1:] # 꼬리제거
    x, y = nx, ny
    if times and times[0][0] == res:
        d = rotate(d, times[0][1])
        times = times[1:]

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/27/BOJ-3190.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/27/BOJ-3190.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 최단경로</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1753&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1753&quot;&gt;백준 1753번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

v, e = map(int, input().split())
k = int(input())
INF = int(1e9)
edges = {}
for _ in range(e):
    u, v_, w = map(int, input().split())
    edges[(u, v_)] = min(edges.get((u, v_), INF), w)

graph = [[] for _ in range(v+1)]
for u, v_ in edges:
    w = edges[(u, v_)]
    graph[u].append((v_, w))


def dijkstra(start):
    q = []
    distance = [INF for _ in range(v+1)]
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:
        dist, now = heapq.heappop(q)
        if distance[now] &amp;lt; dist:
            continue
        for i, c in graph[now]:
            cost = dist + c
            if cost &amp;lt; distance[i]:
                distance[i] = cost
                heapq.heappush(q, (cost, i))
    return distance


res = dijkstra(k)
for i in range(1, v+1):
    if res[i] == INF:
        print(&quot;INF&quot;)
    else:
        print(res[i])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;adjacency matrix로 풀면 메모리 초과가 나고, adjacency list로 풀어야 한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/27/BOJ-1753.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/27/BOJ-1753.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 특정한 최단경로</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1504&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1504&quot;&gt;백준 1504번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

n, e = map(int, input().split())
INF = int(1e9)
graph = [[] for _ in range(n+1)]
for _ in range(e):
    a, b, c = map(int, input().split())
    graph[a].append((b, c))
    graph[b].append((a, c))
v1, v2 = map(int, input().split())

def dijkstra(start, graph):
    distance = [INF for _ in range(n+1)]
    q = []
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:
        dist, now = heapq.heappop(q)
        if distance[now] &amp;lt; dist:
            continue
        for v, c in graph[now]:
            cost = dist + c
            if cost &amp;lt; distance[v]:
                distance[v] = cost
                heapq.heappush(q, (cost, v))
    return distance

# 1 -&amp;gt; v1 -&amp;gt; v2 -&amp;gt; n
res1 = dijkstra(1, graph)[v1]+dijkstra(v1, graph)[v2]+dijkstra(v2, graph)[n]
# 1 -&amp;gt; v2 -&amp;gt; v1 -&amp;gt; n
res2 = dijkstra(1, graph)[v2]+dijkstra(v2, graph)[v1]+dijkstra(v1, graph)[n]
res = min(res1, res2)
if res &amp;gt;= INF:
    print(-1)
else:
    print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/27/BOJ-1504.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/27/BOJ-1504.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 플로이드</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem11404&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/11404&quot;&gt;백준 11404번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
m = int(input())
INF = 1e9
graph = [[INF] * (n+1) for i in range(n+1)]
for i in range(1, n+1):
    graph[i][i] = 0

for _ in range(m):
    start, end, cost = map(int, input().split())
    graph[start][end] = min(graph[start][end], cost)

for k in range(1, n+1):
    for i in range(1, n+1):
        for j in range(1, n+1):
            graph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j])

for i in range(1, n+1):
    for j in range(1, n+1):
        if graph[i][j] != INF:
            print(graph[i][j], end=' ')
        else:
            print(0, end=' ')
    print()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 27 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/27/BOJ-11404.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/27/BOJ-11404.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv3 - 자물쇠와 열쇠</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons60059&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/60059&quot;&gt;프로그래머스 60059번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import numpy as np

def rotate(m, key):
    key_ = [[0] * m for _ in range(m)]
    for i in range(m):
        for j in range(m):
            key_[j][m-i-1] = key[i][j]
    return key_

def solution(key, lock):
    answer = False
    n = len(lock)
    m = len(key)
    keys = []
    for i in range(4):
        keys.append(key)
        key = rotate(m, key)
        
    xs = []
    ys = []
    for i in range(n):
        for j in range(n):
            if lock[i][j] == 0:
                xs.append(i)
                ys.append(j)
    if not xs:
        return True
    
    x1, x2 = min(xs), max(xs)
    y1, y2 = min(ys), max(ys)

    lock = np.array(lock)[x1:x2+1, y1:y2+1]
    l1, l2 = lock.shape[0], lock.shape[1]
    
    keys_ = []
    for key in keys:
        key_arr = np.array(key)
        for i in range(key_arr.shape[0]-l1+1):
            for j in range(key_arr.shape[1]-l2+1):
                keys_.append(key_arr[i:i+l1, j:j+l2])
    
    for k in keys_:
        if k.shape != lock.shape:
            continue
        if (k == 1-lock).all():
            return True
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;행렬 연산을 쉽게 하려고 &lt;code class=&quot;highlighter-rouge&quot;&gt;numpy&lt;/code&gt; 라이브러리를 사용했다.&lt;/p&gt;
</description>
        <pubDate>Wed, 24 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/24/PR-60059.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/24/PR-60059.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 구슬탈출 2</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem13460&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13460&quot;&gt;백준 13460번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
board = []
for _ in range(n):
    board.append([ch for ch in input()])
# 공들의 위치
balls = [-1] * 2
for i in range(n):
    for j in range(m):
        if board[i][j] == 'R':
            balls[0] = [i, j]
        elif board[i][j] == 'B':
            balls[1] = [i, j]

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def move(x, y, d, board):
    while True:
        nx, ny = x+dx[d], y+dy[d]
        if board[nx][ny] != '.':
            break
        x, y = nx, ny
    if board[nx][ny] == 'O':
        x, y = nx, ny
    return x, y


def move_balls(balls, board, d):
    # 위로 이동, y좌표가 같다면 x좌표가 작은 것부터 이동
    flag1 = d == 0 and balls[0][1] == balls[1][1] and balls[0][0] &amp;gt; balls[1][0]
    # 아래로 이동, y좌표가 같다면 x좌표가 큰 것부터 이동
    flag2 = d == 1 and balls[0][1] == balls[1][1] and balls[0][0] &amp;lt; balls[1][0]
    # 왼쪽으로 이동, x좌표가 같다면 y좌표가 작은 것부터 이동
    flag3 = d == 2 and balls[0][0] == balls[1][0] and balls[0][1] &amp;gt; balls[1][1]
    # 오른쪽으로 이동, x좌표가 같다면 y좌표가 큰 것부터 이동
    flag4 = d == 3 and balls[0][0] == balls[1][0] and balls[0][1] &amp;lt; balls[1][1]
    if flag1 or flag2 or flag3 or flag4:
        bx, by = move(*balls[1], d, board)
        board[balls[1][0]][balls[1][1]] = '.' # 빈칸이 되고
        board[bx][by] = 'B' if board[bx][by] != 'O' else 'O'
        rx, ry  = move(*balls[0], d, board)
        board[balls[0][0]][balls[0][1]] = '.' # 빈칸이 되고
        board[rx][ry] = 'R' if board[rx][ry] != 'O' else 'O'
    else:
        rx, ry = move(*balls[0], d, board)
        board[balls[0][0]][balls[0][1]] = '.' # 빈칸이 되고
        board[rx][ry] = 'R' if board[rx][ry] != 'O' else 'O'
        bx, by = move(*balls[1], d, board)
        board[balls[1][0]][balls[1][1]] = '.' # 빈칸이 되고
        board[bx][by] = 'B' if board[bx][by] != 'O' else 'O'
    balls_ = [[rx, ry], [bx, by]]
    return balls_


cnt = 11


def solution(now, balls, board):
    global cnt
    if now &amp;gt;= cnt:
        return
    rx, ry = balls[0]
    bx, by = balls[1]
    if board[rx][ry] == 'O': # 성공
        cnt = min(cnt, now)
    elif board[bx][by] != 'O': # 파란 구슬이 안 빠졌을 때
        for i in range(4):
            balls_ = move_balls(balls, board, i)
            # 빨간 구슬, 파란 구슬이 다를 때만
            if balls_[0] != balls_[1]:
                solution(now+1, balls_, board)
            # 다시 돌려놓기
            x, y = balls_[0]
            board[x][y] = '.' if board[x][y] != 'O' else 'O'
            x, y = balls_[1]
            board[x][y] = '.' if board[x][y] != 'O' else 'O'
            board[rx][ry] = 'R'
            board[bx][by] = 'B'


solution(0, balls, board)

if cnt == 11:
    print(-1)
else:
    print(cnt)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 23 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/23/BOJ-13460.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/23/BOJ-13460.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold3 - 청소년 상어</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem19236&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19236&quot;&gt;백준 19236번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from copy import deepcopy

graph = [[-1] * 4 for _ in range(4)]
for i in range(4):
    tmp = list(map(int, input().split()))
    for j in range(0, 8, 2):
        graph[i][j // 2] = [tmp[j], tmp[j+1]]

moves = {1: [-1, 0], 2: [-1, -1], 3: [0, -1], 4: [1, -1],
         5: [1, 0], 6: [1, 1], 7: [0, 1], 8: [-1, 1]}
shark = [0, 0]
res = 0

def check_fish(x, y, d, shark):
    nx, ny = x+moves[d][0], y+moves[d][1]
    if nx &amp;lt; 0 or nx &amp;gt;= 4 or ny &amp;lt; 0 or ny &amp;gt;= 4 or [nx, ny] == shark:
        return [-1, -1]
    else:
        return [nx, ny]

def move_fish(graph, shark):
    order = {}
    for i in range(4):
        for j in range(4):
            if [i, j] != shark and graph[i][j][0] != 0:
                # 번호: 좌표
                order[graph[i][j][0]] = (i, j)
    order = sorted(order.items(), key=lambda x: x[0])
    order = dict(order)
    for o in order.keys():
        x, y = order[o]
        while True:
            nx, ny = check_fish(x, y, graph[x][y][1], shark)
            if nx != -1 and ny != -1:
                break
            # rotate
            graph[x][y][1] += 1
            if graph[x][y][1] &amp;gt; 8:
                graph[x][y][1] -= 8
        # 다른 물고기가 있는 칸이라면
        if graph[nx][ny][0] != 0:
            # swap
            order[graph[x][y][0]], order[graph[nx][ny][0]] = (nx, ny), (x, y)
            graph[x][y], graph[nx][ny] = graph[nx][ny], graph[x][y]
        else: # 비어있는 칸이라면
            order[graph[x][y][0]] = (nx, ny)
            graph[nx][ny] = graph[x][y]
            graph[x][y] = [0, 0]

def move_shark(now, graph, shark): # 지금까지 먹은 물고기수, 그래프, 상어 좌표
    global res
    move_fish(graph, shark)
    x, y = shark
    # 물고기 개수, 방향
    num, d = graph[x][y]
    dx, dy = moves[d]
    # 잡아 먹힘
    graph[x][y] = [0, 0]
    results = []
    for i in range(1, 4):
        nx, ny = x+dx*i, y+dy*i
        if 0 &amp;lt;= nx &amp;lt; 4 and 0 &amp;lt;= ny &amp;lt; 4 and graph[nx][ny][0] != 0:
            results.append((nx, ny))
    if results:
        for nx, ny in results:
            move_shark(now+num, deepcopy(graph), [nx, ny])
    else: # 더 이상 갈 곳이 없으므로 종료
        res = max(res, now+num)

move_shark(0, graph, shark)

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;구현이 굉장히 빡센 문제.. 연습이 많이 필요할 것 같다.&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/21/BOJ-19236.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/21/BOJ-19236.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 2048(Easy)</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem12100&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/12100&quot;&gt;백준 12100번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from copy import deepcopy
from collections import deque

n = int(input())
board = []
for _ in range(n):
    board.append(list(map(int, input().split())))


def go_up(board):
    for j in range(n):
        col = [board[i][j] for i in range(n) if board[i][j] &amp;gt; 0]
        i = 0
        new_col = deque()
        while i &amp;lt; len(col)-1:
            if col[i] == col[i+1]:
                new_col.append(col[i]+col[i+1])
                i += 2
            else:
                new_col.append(col[i])
                i += 1
        if i == len(col)-1:
            new_col.append(col[i])
        new_col = list(new_col) + [0] * (n-len(new_col))
        for i in range(n):
            board[i][j] = new_col[i]
        

def go_down(board):
    for j in range(n):
        col = [board[i][j] for i in range(n) if board[i][j] &amp;gt; 0]
        i = len(col)-1
        new_col = deque()
        while i &amp;gt; 0:
            if col[i] == col[i-1]:
                    new_col.appendleft(col[i]+col[i-1])
                    i -= 2
            else:
                new_col.appendleft(col[i])
                i -= 1
        if i == 0:
            new_col.appendleft(col[i])
        new_col = [0] * (n-len(new_col)) + list(new_col)
        for i in range(n):
            board[i][j] = new_col[i]


def go_right(board):
    for i in range(n):
        row = [x for x in board[i] if x &amp;gt; 0]
        j = len(row)-1
        new_row = deque()
        while j &amp;gt; 0:
            if row[j] == row[j-1]:
                new_row.appendleft(row[j]+row[j-1])
                j -= 2
            else:
                new_row.appendleft(row[j])
                j -= 1
        if j == 0:
            new_row.appendleft(row[j])
        new_row = [0] * (n-len(new_row)) + list(new_row)
        for j in range(n):
            board[i][j] = new_row[j]


def go_left(board):
    for i in range(n):
        row = [x for x in board[i] if x &amp;gt; 0]
        j = 0
        new_row = deque()
        while j &amp;lt; len(row)-1:
            if row[j] == row[j+1]:
                new_row.append(row[j]+row[j+1])
                j += 2
            else:
                new_row.append(row[j])
                j += 1
        if j == len(row)-1:
            new_row.append(row[j])
        new_row = list(new_row) + [0] * (n-len(new_row))
        for j in range(n):
            board[i][j] = new_row[j]

res = 0

def go(cnt, board):
    global res
    if cnt == 5:
        for i in range(n):
            for j in range(n):
                res = max(res, board[i][j])
        return
    for i in range(4):
        board_ = deepcopy(board)
        if i == 0:
            go_up(board_)
            go(cnt+1, board_)
        elif i == 1:
            go_down(board_)
            go(cnt+1, board_)
        elif i == 2:
            go_right(board_)
            go(cnt+1, board_)
        elif i == 3:
            go_left(board_)
            go(cnt+1, board_)

go(0, board)

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0인 것들은 제외하고 새로운 행/열을 만든 다음에 합쳐주는게 관건이었다. 그 와중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;deque&lt;/code&gt;를 적절히 사용해야 순서가 안바뀌고 제대로 된다. 구현은 언제 풀어도 어렵다ㅠ&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/21/BOJ-12100.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/21/BOJ-12100.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
