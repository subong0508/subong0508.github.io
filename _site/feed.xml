<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 03 Feb 2021 00:55:06 +0900</pubDate>
    <lastBuildDate>Wed, 03 Feb 2021 00:55:06 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>정렬 with Python</title>
        <description>&lt;p&gt;이번 포스팅에서는 여러 정렬 기법에 대해 알아보고 파이썬으로 간단하게 구현해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;selection-sort&quot;&gt;선택 정렬(Selection Sort)&lt;/h2&gt;

&lt;p&gt;선택 정렬은 한마디로 &lt;strong&gt;Priority Queue with Unsorted Array&lt;/strong&gt;라고 할 수 있습니다.
우선순위 큐가 하나 있다고 가정해봅시다. 데이터를 삽입할 때는 항상 끝에 삽입하고,
&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt; 연산을 오름차순/내림차순으로 수행합니다. 또한 시간복잡도는 $O(n^2)$ 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_idx = i
    for j in range(i+1, len(array)):
        if array[j] &amp;lt; array[min_idx]:
            min_idx = j
    # swap
    array[min_idx], array[i] = array[i], array[min_idx]

print(array)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;insertion-sort&quot;&gt;삽입 정렬(Insertion Sort)&lt;/h2&gt;

&lt;p&gt;삽입 정렬은 선택 정렬과 반대로 &lt;strong&gt;Sorted Array&lt;/strong&gt;로 구현된 우선순위 큐입니다. 최악의 경우 시간복잡도는 선택 정렬과 동일하게 $O(n^2)$이지만 이미 정렬된 경우에는 $O(n)$에 가까울 정도로 빠릅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)-1):
    j = i+1
    while j &amp;gt;= 1 and array[j] &amp;lt; array[j-1]:
        # swap
        array[j-1], array[j] = array[j], array[j-1]
        j -= 1

print(array)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;heap-sort&quot;&gt;힙 정렬(Heap Sort)&lt;/h2&gt;

&lt;p&gt;힙 정렬은 이름과 같이 힙을 이용하여 정렬하는 방법입니다. 시간복잡도는 $O(n\log n)$에 해당합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def heap_sort(arr):
    q = []
    for a in arr:
        heapq.heappush(q, a)
    arr = []
    while q:
        arr.append(heapq.heappop(q))
    return arr

print(heap_sort(array))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;quick-sort&quot;&gt;퀵 솔트(Quick Sort)&lt;/h2&gt;

&lt;p&gt;퀵 솔트란 하나의 피봇을 정해서 피봇보다 작은 값들 - 피봇 - 피봇보다 큰 값들 순으로 오도록 하는 알고리즘입니다. 퀵 솔트의 구현에서는 대부분 재귀함수를 사용합니다. 시간 복잡도는 보통 $O(n \log n)$이지만 최악의 경우엔 $O(n^2)$이 되기도 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    if len(array) &amp;lt;= 1:
        return array

    pivot = array[0]
    array = array[1:]

    left_partition = [x for x in array if x &amp;lt;= pivot]
    right_partition = [x for x in array if x &amp;gt; pivot]

    return quick_sort(left_partition) + [pivot] + quick_sort(right_partition)

print(quick_sort(array))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;merge-sort&quot;&gt;합병 정렬(Merge Sort)&lt;/h2&gt;

&lt;p&gt;마지막으로 살펴볼 정렬 기법은 합병 정렬입니다. 합병 정렬은 어떤 경우에도 $O(n \log n)$의 성능을 보장하지만 대부분의 경우에 퀵 정렬보다 느리다고 합니다. 또한 합병 정렬은 &lt;strong&gt;Divide and Conquer&lt;/strong&gt;의 대표적인 알고리즘 중 하나입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def merge(lst1, lst2):
    n1, n2 = len(lst1), len(lst2)
    i = j = 0
    lst = []
    while i &amp;lt; n1 and j &amp;lt; n2:
        if lst1[i] &amp;lt; lst2[j]:
            lst.append(lst1[i])
            i += 1
        else:
            lst.append(lst2[j])
            j += 1

    while i &amp;lt; n1:
        lst.append(lst1[i])
        i += 1
    
    while j &amp;lt; n2:
        lst.append(lst2[j])
        j += 1

    return lst

def merge_sort(arr):
    if len(arr) &amp;lt;= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

print(merge_sort(array))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 02 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data-structure/2021/02/02/Sorting.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data-structure/2021/02/02/Sorting.html</guid>
        
        <category>sorting</category>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        
        <category>Data-Structure</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 스도쿠</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2239&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2239&quot;&gt;백준 2239번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from copy import deepcopy

board = []
for _ in range(9):
    string = input()
    tmp = [int(x) for x in string]
    board.append(tmp)
res = []


def is_possible(board, x, y):
    num = board[x][y]
    for i in range(9):
        # 가로로 같은지
        if i != y and num == board[x][i]:
            return False
        # 세로로 같은지
        if i != x and num == board[i][y]:
            return False
    # 3x3 사각형을 본다.
    x_, y_ = x // 3, y // 3
    x_, y_ = 3*x_, 3*y_
    for i in range(3):
        for j in range(3):
            if x == x_+i and y == y_+j:
                continue
            if num == board[x_+i][y_+j]:
                return False
    return True

def sdoku(board, x, y):
    global res
    # 항상 사전순이므로 상관 없음
    if not res:
        if x == 9:
            res = deepcopy(board)
            return
        if board[x][y] != 0:
            if y+1 &amp;lt; 9:
                sdoku(board, x, y+1)
            else:
                sdoku(board, x+1, 0)
        else:
            for i in range(1, 10):
                board[x][y] = i
                if is_possible(board, x, y):
                    if y+1 &amp;lt; 9:
                        sdoku(board, x, y+1)
                    else:
                        sdoku(board, x+1, 0)
                board[x][y] = 0


sdoku(board, 0, 0)
for row in res:
    for col in row:
        print(col, end='')
    print()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에느 &lt;code class=&quot;highlighter-rouge&quot;&gt;res&lt;/code&gt;를 리스트 변수로 만들어서 가능한 순서대로 다 넣은 다음 sort를 했더니
시간초과가 떴다. 그런데 for문 돌아가는 걸 생각해보니 그냥 제일 첫번째 성공케이스가 그 답 자체이기 때문에 위처럼 풀 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/31/BOJ-2239.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/31/BOJ-2239.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - 계란으로 계란치기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem16987&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16987&quot;&gt;백준 16987번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
eggs = []
for _ in range(n):
    s, w = map(int, input().split())
    eggs.append([s, w])
cnt = 0


def crush(l, cur, eggs):
    global cnt
    # 가장 오른쪽 계란
    if l == n:
        cnt = max(cnt, cur)
        return
    
    if eggs[l][0] &amp;gt; 0:
        all_broken = True
        for r in range(n):
            # 손에 든 계란이거나 이미 깨진 계란
            if r == l or eggs[r][0] &amp;lt;= 0:
                continue
            all_broken = False
            eggs[l][0] -= eggs[r][1]
            eggs[r][0] -= eggs[l][1]
            cur_ = cur
            cur_ += 1 if eggs[l][0] &amp;lt;= 0 else 0
            cur_ += 1 if eggs[r][0] &amp;lt;= 0 else 0
            crush(l+1, cur_, eggs)
            eggs[l][0] += eggs[r][1]
            eggs[r][0] += eggs[l][1]
        # 다 깨진 계란
        if all_broken:
            crush(l+1, cur, eggs)
    # 손에 든 계란이 깨진 경우
    else:
        crush(l+1, cur, eggs)


crush(0, 0, eggs)
print(cnt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에 알고리즘은 맞게 짰는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;eggs&lt;/code&gt;를 deepcopy해서 처리하는 바람에 시간초과가
났었다. 코딩 테스트에서 파이썬을 쓸 때는 deepcopy는 피하도록 하자.&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/31/BOJ-16987.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/31/BOJ-16987.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 연산자 끼워넣기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14888&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14888&quot;&gt;백준 14888번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))
ops = list(map(int, input().split()))
min_val = int(1e9)
max_val = -int(1e9)


def solution(idx, ops, val):
    global min_val, max_val
    if idx == n-1:
        min_val = min(min_val, val)
        max_val = max(max_val, val)
        return

    for i in range(4):
        if ops[i] &amp;lt;= 0:
            continue
        ops[i] -= 1
        if i == 0:
            solution(idx+1, ops, val+arr[idx+1])
        elif i == 1:
            solution(idx+1, ops, val-arr[idx+1])
        elif i == 2:
            solution(idx+1, ops, val*arr[idx+1])
        elif i == 3:
            if val &amp;lt; 0:
                solution(idx+1, ops, -(-val // arr[idx+1]))
            else:
                solution(idx+1, ops, val // arr[idx+1])
        ops[i] += 1


solution(0, ops, arr[0])
print(max_val, min_val, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/31/BOJ-14888.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/31/BOJ-14888.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>Itertools 정리</title>
        <description>&lt;p&gt;내장 라이브러리인 &lt;code class=&quot;highlighter-rouge&quot;&gt;itertools&lt;/code&gt;를 이용해서 조합, 순열, 중복순열, Cartesian Product 등을 손쉽게 구현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations, permutations, combinations_with_replacement, product

data = '123'
l = combinations(data, 2)
for e in l:
    print(*e) # 12 13 23

l = permutations(data, 2)
for e in l:
    print(*e) # 12 13 21 23 31 32

l = combinations_with_replacement(data, 2)
for e in l:
    print(*e) # 11 12 13 22 23 33

l = product(data, repeat=2)
for e in l:
    print(*e) # 11 12 13 21 22 23 31 32 33
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/python/2021/01/30/Itertools.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/python/2021/01/30/Itertools.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - N-Queen</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem9663&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9663&quot;&gt;백준 9663번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
cnt = 0


def nqueen(arr):
    global cnt
    # 새로운 행 번호
    row = len(arr)
    if row == n:
        cnt += 1
        return

    for i in range(n):
        # 이미 있는 열
        if i in arr:
            continue
        flag = True
        # j번째 행, j번째 행에 해당하는 열 번호는 item
        for j, item in enumerate(arr):
            # 대각선
            if abs(i-item) == abs(row-j):
                flag = False
                break
        if flag:
            arr.append(i)
            nqueen(arr)
            arr.pop()
        

nqueen([])

print(cnt)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-9663.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-9663.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - N과 M(1)(2)(3)</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem15649&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15649&quot;&gt;백준 15649번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = [i for i in range(1, n+1)]
answer = []


def combinations(arr, s):
    global answer
    if len(s) == m:
        # shallow copy
        answer.append(s[:])
        return

    for e in arr:
        if e not in s:
            s.append(e)
            combinations(arr, s)
            s.pop()


combinations(arr, [])

for a in answer:
    print(*a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전형적인 백트랙킹 문제라고 하는데 백트랙킹이 뭔지 몰라서 찾아보니 완전탐색처럼 모든 경우를 탐색하지만 중간 중간에 조건에 맞지 않는 케이스를 가지치기하여 탐색시간을 줄이는 기법이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem15650&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15650&quot;&gt;백준 15650번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = [i for i in range(1, n+1)]
answer = []


def combinations(arr, s):
    global answer
    if len(s) == m:
        # shallow copy
        answer.append(s[:])
        return

    for e in arr:
        if len(s) == 0 or (s and e &amp;gt; s[-1]):
            s.append(e)
            combinations(arr, s)
            s.pop()


combinations(arr, [])

for a in answer:
    print(*a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1)과 거의 유사하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;len(s) == 0 or (s and e &amp;gt; s[-1])&lt;/code&gt;의 조건을 추가해서 오름차순이라는 조건과 중복이 없다는 조건을 만족할 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem15651&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15651&quot;&gt;백준 15651번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = [i for i in range(1, n+1)]
answer = []


def combinations(arr, s):
    global answer
    if len(s) == m:
        # shallow copy
        answer.append(s[:])
        return

    for e in arr:
        s.append(e)
        combinations(arr, s)
        s.pop()


combinations(arr, [])

for a in answer:
    print(*a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 조건도 넣어주지 않으면 중복수열을 구할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-15649.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-15649.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 스타트와 링크</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14889&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14889&quot;&gt;백준 14889번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

n = int(input())
arr = [[0] * (n+1)]
for _ in range(n):
    arr.append([0] + list(map(int, input().split())))
whole = set(range(1,  n+1))
comb = list(combinations(whole, n//2))
# 중복되는 경우 제외
comb = comb[:len(comb)//2]

res = int(1e9)
for start_ in comb:
    start = set(start_)
    link = whole - start
    val1 = 0
    val2 = 0
    # 스타트 팀원들에 대해서
    for m in start:
        # Sii는 항상 0이므로 상관 없음
        for e in start:
            val1 += arr[m][e]
    # 링크 팀원들에 대해서
    for m in link:
        for e in link:
            val2 += arr[m][e]
    res = min(res, abs(val1-val2))

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;combinations&lt;/code&gt;를 통해 팀을 두개로 가른 다음 모든 경우에 대해 완전 탐색을 하면 된다.&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-14889.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-14889.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 소수 찾기</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42839&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42839&quot;&gt;프로그래머스 42839번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import permutations

def is_prime(n):
    if n &amp;lt;= 1:
        return False
    i = 2
    while i*i &amp;lt;= n:
        if n % i == 0:
            return False
        i += 1
    return True

def solution(numbers):
    s = set()
    for i in range(1, len(numbers)+1):
        comb = permutations(numbers, i)
        for c in comb:
            n = int(''.join(list(c)))
            if is_prime(n):
                s.add(n)
    return len(s)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/PR-42839.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/PR-42839.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 카펫</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42842&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42842&quot;&gt;프로그래머스 42842번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def is_right(n, m , brown, yellow):
    # n: 세로, m: 가로
    brown_ = 2*m+2*(n-2)
    yellow_ = n*m-brown_
    return brown_ == brown and yellow_ == yellow

def solution(brown, yellow):
    # a: 세로, b: 가로
    total = brown+yellow
    arr = []
    answer = []
    # arr: total의 약수 페어를 모아놓은 배열
    for i in range(1, total//2):
        if total % i == 0:
            a, b = i, total // i
            arr.append((min(a, b), max(a, b)))
    for a, b in arr:
        if a*b == brown+yellow and is_right(a, b, brown, yellow):
            answer.extend([b, a])
            break
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에는 이중 for loop으로 코드를 짰는데 시간복잡도에서 걸리는 것을 보고 시간복잡도를 $O(n)$으로 짰다. 이 문제의 핵심은 &lt;code class=&quot;highlighter-rouge&quot;&gt;brown+yellow&lt;/code&gt;의 약수를 $O(n)$으로 짜는 알고리즘인듯하다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/PR-42842.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/PR-42842.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
