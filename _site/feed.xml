<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 14 Feb 2021 19:51:48 +0900</pubDate>
    <lastBuildDate>Sun, 14 Feb 2021 19:51:48 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>백준 Silver1 - 토마토(7576번, 7569번)</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem7576&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7576&quot;&gt;백준 7576번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;틀린 풀이(시간초과)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

m, n = map(int, input().split())
graph = []
for _ in range(n):
    tmp = list(map(int, input().split()))
    graph.append(tmp)

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y):
    if graph[x][y] != 1:
        return
    q = deque([(x, y)])
    visited = set()
    visited.add((x, y))
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and (nx, ny) not in visited:
                if graph[nx][ny] == -1:
                    continue
                visited.add((nx, ny))
                if graph[nx][ny] == 0:
                    graph[nx][ny] = graph[x][y]+1
                else:
                    graph[nx][ny] = min(graph[nx][ny], graph[x][y]+1)
                q.append((nx, ny))

for i in range(n):
    for j in range(m):
        bfs(i, j)

impossible = False
max_num = 1
for i in range(n):
    if not impossible:
        for j in range(m):
            if graph[i][j] == -1:
                continue
            if graph[i][j] == 0:
                impossible = True
                break
            max_num = max(max_num, graph[i][j])

if impossible:
    print(-1)
elif max_num == 1:
    print(0)
else:
    print(max_num-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;i, j&lt;/code&gt;에서 BFS를 수행하니 시간 초과로 계속해서 실패했다. 
이 문제의 관건은 익은 사과(즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;graph[i][j] == 1&lt;/code&gt;)들을 큐에 넣어주고 BFS를 수행해야 하는 것이었다. 생각해보면 익은 사과들의 레벨은 모두 0이므로 다같이 큐에 넣어줘야 최적해를 구해줄 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;올바른 풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

m, n = map(int, input().split())
graph = []
for _ in range(n):
    tmp = list(map(int, input().split()))
    graph.append(tmp)

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(q):
    visited = set()
    for x, y in q:
        visited.add((x, y))
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and (nx, ny) not in visited:
                if graph[nx][ny] == -1:
                    continue
                visited.add((nx, ny))
                graph[nx][ny] = graph[x][y]+1
                q.append((nx, ny))


q = deque()
for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            q.append((i, j))

bfs(q)

impossible = False
max_num = 1
for i in range(n):
    if not impossible:
        for j in range(m):
            if graph[i][j] == -1:
                continue
            if graph[i][j] == 0:
                impossible = True
                break
            max_num = max(max_num, graph[i][j])

if impossible:
    print(-1)
elif max_num == 1:
    print(0)
else:
    print(max_num-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem7569&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7569&quot;&gt;백준 7569번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

m, n, h = map(int, input().split())
graph = [[] for _ in range(h)]
for i in range(h):
    for j in range(n):
        tmp = list(map(int, input().split()))
        graph[i].append(tmp)

dx = [-1, 1, 0, 0, 0, 0]
dy = [0, 0, -1, 1, 0, 0]
dz = [0, 0, 0, 0, -1, 1]


def bfs(q):
    visited = set()
    for z, x, y in q:
        visited.add((z, x, y))
    visited.add((z, x, y))
    while q:
        z, x, y = q.popleft()
        for i in range(6):
            nz, nx, ny = z+dz[i], x+dx[i], y+dy[i]
            if 0 &amp;lt;= nz &amp;lt; h and 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m:
                if graph[nz][nx][ny] != -1 and (nz, nx, ny) not in visited:
                    visited.add((nz, nx, ny))
                    graph[nz][nx][ny] = graph[z][x][y]+1
                    q.append((nz, nx, ny))
    

q = deque()
for i in range(h):
    for j in range(n):
        for k in range(m):
            if graph[i][j][k] == 1:
                q.append((i, j, k))

bfs(q)

max_num = 1
impossible = False
for i in range(h):
    for j in range(n):
        for k in range(m):
            if graph[i][j][k] == -1:
                continue
            if graph[i][j][k] == 0:
                impossible = True
            else:
                max_num = max(max_num, graph[i][j][k])

if impossible:
    print(-1)
elif max_num == 1:
    print(0)
else:
    print(max_num - 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에 문제와 거의 비슷하지만, z축까지 생각해줘야하는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-7576.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-7576.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 단지번호붙이기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2667&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2667&quot;&gt;백준 2667번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n = int(input())
graph = []
for _ in range(n):
    tmp = [int(x) for x in input()]
    graph.append(tmp)
total_cnt = 0
res = []

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y, graph):
    global total_cnt, res
    if graph[x][y] == 0:
        return
    total_cnt += 1
    cnt = 0
    q = deque([(x, y)])
    graph[x][y] = 0
    while q:
        x, y = q.popleft()
        cnt += 1
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and graph[nx][ny] == 1:
                graph[nx][ny] = 0
                q.append((nx, ny))
    res.append(cnt)


for i in range(n):
    for j in range(n):
        bfs(i, j, graph)
res.sort()

print(total_cnt)
print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2667.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2667.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 바이러스</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2606&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2606&quot;&gt;백준 2606번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
m = int(input())
graph = [[] for _ in range(n+1)]
for _ in range(m):
    i, j = map(int, input().split())
    graph[i].append(j)
    graph[j].append(i)
visited = [False] * (n+1)
cnt = 0


def dfs(i, visited):
    global cnt
    visited[i] = True
    cnt += 1
    for j in graph[i]:
        if not visited[j]:
            dfs(j, visited)


dfs(1, visited)
print(cnt-1)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2606.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2606.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 보물섬</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2589&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2589&quot;&gt;백준 2589번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, m = map(int, input().split())
graph = []
for _ in range(n):
    tmp = [1 if x == 'L' else 0 for x in input()]
    graph.append(tmp)

starts = []
for i in range(n):
    for j in range(m):
        # 출발가능한 곳들
        if graph[i][j] == 1:
            starts.append((i, j))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


# bfs를 수행하면서 start에서 최단거리가 가장 먼 곳까지의 거리 탐색
def bfs(start):
    x, y = start
    res = cnt = 0
    q = deque([(x, y, cnt)])
    visited = set()
    visited.add((x, y))
    while q:
        x, y, cnt = q.popleft()
        res = max(res, cnt)
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and graph[nx][ny] == 1 and (nx, ny) not in visited:
                visited.add((nx, ny))
                q.append((nx, ny, cnt+1))
    return res


res = 0
for start in starts:
    res = max(res, bfs(start))
print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2589.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2589.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 벽 부수고 이동하기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2206&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2206&quot;&gt;백준 2206번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, m = map(int, input().split())
graph = []
for _ in range(n):
    tmp = [int(x) for x in input()]
    graph.append(tmp)

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y):
    crush = False
    cnt = 1
    q = deque([(x, y, crush, cnt)])
    # 벽을 부수지 않고 온 경우
    visit1 = [[False for _ in range(m)] for _ in range(n)]
    # 벽을 부수고 온 경우
    visit2 = [[False for _ in range(m)] for _ in range(n)]
    while q:
        x, y, crush, cnt = q.popleft()
        if x == n-1 and y  == m-1:
            return cnt
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m:
                # 벽을 부수지 않고 왔다
                if not crush:
                    # 안 부시고 새로 감
                    if graph[nx][ny] == 0 and visit1[nx][ny] == 0:
                        visit1[nx][ny] = True
                        q.append((nx, ny, crush, cnt+1))
                    # 새로 부신다
                    elif graph[nx][ny] == 1:
                        visit2[nx][ny] = True
                        q.append((nx, ny, True, cnt+1))
                # 벽을 부수고 왔다
                else:
                    if graph[nx][ny] == 0 and visit2[nx][ny] == 0:
                        visit2[nx][ny] = True
                        q.append((nx, ny, crush, cnt+1))
    return -1


print(bfs(0, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;벽을 부수고 왔을 때랑 아닐 때랑 방문 여부 행렬을 다르게 놓고 풀어야 하는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2206.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-2206.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 숨바꼭질, Gold5 - 숨바꼭질 3</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1697&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1697&quot;&gt;백준 1697번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, k = map(int, input().split())

def bfs(n, k):
    cnt = 0
    q = deque([(n, cnt)])
    visited = set()
    while q:
        now, cnt = q.popleft()
        if now == k:
            return cnt
        if 0 &amp;lt;= now-1 and (now-1) not in visited:
            visited.add(now-1)
            q.append((now-1, cnt+1))
        if now+1 &amp;lt;= int(1e5) and now+1 not in visited:
            visited.add(now+1)
            q.append((now+1, cnt+1))
        if 2*now &amp;lt;= int(1e5) and 2*now not in visited:
            visited.add(2*now)
            q.append((2*now, cnt+1))
    return -1


print(bfs(n, k))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem13549&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13549&quot;&gt;백준 13549번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, k = map(int, input().split())


def bfs(n, k):
    cnt = 0
    q = deque([(n, cnt)])
    visited = set()
    while q:
        now, cnt = q.popleft()
        if now == k:
            return cnt
        # 순간이동 하는 것을 먼저 둔다.
        if 2*now &amp;lt;= int(1e5) and 2*now not in visited:
            visited.add(2*now)
            q.append((2*now, cnt))
        if 0 &amp;lt;= now-1 and (now-1) not in visited:
            visited.add(now-1)
            q.append((now-1, cnt+1))
        if now+1 &amp;lt;= int(1e5) and now+1 not in visited:
            visited.add(now+1)
            q.append((now+1, cnt+1))
    return -1


print(bfs(n, k))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-1697.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-1697.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 연구소</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14502&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14502&quot;&gt;백준 14502번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations
from collections import deque

n, m = map(int, input().split())
graph = []
for _ in range(n):
    tmp = list(map(int, input().split()))
    graph.append(tmp)

candidates = []
walls = []
virus = deque()
for i in range(n):
    for j in range(m):
        if graph[i][j] == 0:
            candidates.append((i, j))
        elif graph[i][j] == 1:
            walls.append((i, j))
        else:
            virus.append((i, j))
combs = list(combinations(candidates, 3))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

    
def propagate(q, graph):
    q = q.copy()
    visited = [[False for _ in range(m)] for _ in range(n)]
    for x, y in q:
        visited[x][y] = True
    cnt = len(q)
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and not visited[nx][ny] and graph[nx][ny] == 0:
                visited[nx][ny] = True
                cnt += 1
                q.append((nx, ny))
    return cnt


safety = 0
for c in combs:
    for x, y in c:
        graph[x][y] = 1
    cnt = propagate(virus, graph)
    safety = max(safety, n*m-(cnt+len(walls)+3))
    for x, y in c:
        graph[x][y] = 0

print(safety)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;N, M의 범위가 8 이하이므로 완전탐색을 통해 풀 수 있었다.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/14/BOJ-14502.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/14/BOJ-14502.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv4 - 무지의 먹방 라이브</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42891&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42891&quot;&gt;프로그래머스 42891번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(food_times, k):
    ft = [(i+1, t) for i, t in zip(range(len(food_times)), food_times)]
    # 음식 먹는 시간이 작은 순대로 뒤에 오게 정렬
    ft = sorted(ft, key=lambda x: -x[1])
    prev = 0
    time = 0
    answer = -1
    while ft:
        idx, now = ft.pop()
        # pop 연산을 했으므로 +1
        time += (now-prev) * (len(ft) + 1)
        # k분보다 시간이 더 지났다면 무효화
        if time &amp;gt; k:
            time -= (now-prev) * (len(ft) + 1)
            ft.append((idx, now))
            break
        prev = now
    if ft:
        ft = sorted(ft, key=lambda x: x[0])
        idx = 0
        answer = ft[(k-time) % len(ft)][0]
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 문제는 큐를 사용해서 풀었다간 효율성 테스트에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;가 2 x 10 ^ 13이므로 틀린다. 따라서 힙을 사용하거나 정렬을 사용해야한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/13/PR-42891.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/13/PR-42891.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>DFS, BFS with Python</title>
        <description>&lt;h1 id=&quot;dfs--&quot;&gt;DFS(깊이 우선 탐색)&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Depth-First Search&lt;/strong&gt;의 약자로, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;그래프는 노드(Node)/정점(Vertex)과 간선(Edge)로 구성되는데 그래프를 표현하는 방법으로는 &lt;strong&gt;인접 행렬, 인접 리스트&lt;/strong&gt;가 있다.
인접 행렬은 NxN 행렬을 만들어서 i번째 노드에서 j번째 노드로 갈 수 있다면 1을 표시, 갈 수 없다면 0을 표시하는 것이 일반적이다.
인접 리스트의 i번째 원소는 i번째 노드에서 갈 수 있는 노드들을 담고 있다.&lt;/p&gt;

&lt;p&gt;DFS를 파이썬으로 나타낸 코드는 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# 인접 리스트
graph = [
    [1, 2],
    [0, 3],
    [0],
    [3]
]
# 방문 여부
visited = [False] * len(graph)
stack = []


def dfs(i, visited, stack):
    stack.append(i)
    visited[i] = True
    for j in graph[i]:
        if not visited[j]:
            dfs(j, visited, stack)


dfs(0, visited, stack)
print(*stack) # 0 1 3 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;bfs--&quot;&gt;BFS(너비 우선 탐색)&lt;/h1&gt;

&lt;p&gt;BFS를 수행할 때는 선입선출의 특성을 띠는 큐 자료구조를 사용한다. BFS의 중요한 특징은 한 노드에서 다른 노드로 가는 최단거리를 항상 구한다는 것이다.&lt;/p&gt;

&lt;p&gt;BFS를 파이썬으로 나타낸 코드는 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque


# 인접 리스트
graph = [
    [1, 2],
    [0, 3],
    [0],
    [3]
]
# 방문 여부
visited = [False] * len(graph)
stack = []


def bfs(start, visited, stack):
    q = deque([start])
    while q:
        now = q.popleft()
        visited[now] = True
        stack.append(now)
        for j in graph[now]:
            if not visited[j]:
                q.append(j)
    

bfs(0, visited, stack)
print(*stack) # 0 1 2 3
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 13 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data-structure/2021/02/13/DFS,-BFS.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data-structure/2021/02/13/DFS,-BFS.html</guid>
        
        <category>graph</category>
        
        <category>dfs</category>
        
        <category>bfs</category>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        
        <category>Data-Structure</category>
        
      </item>
    
      <item>
        <title>백준 Silver5 - 문자열 뒤집기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1439&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1439&quot;&gt;백준 1439번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;s = input()
n = len(s)
d = {'0': 0, '1': 0}

i = 0
while i &amp;lt; n:
    j = i + 1
    while j &amp;lt; n and s[j] == s[i]:
        j += 1
    d[s[i]] += 1
    i = j

print(min(d['0'], d['1']))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;연속된 0이 몇 번 나오는지/연속된 1이 몇 번 나오는지 구한 다음에 더 작은 수에 대해서 뒤집으면 된다.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/13/BOJ-1439.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/13/BOJ-1439.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
