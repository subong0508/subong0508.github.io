<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 18 Feb 2021 20:54:35 +0900</pubDate>
    <lastBuildDate>Thu, 18 Feb 2021 20:54:35 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>백준 Silver1 - 감시 피하기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18428&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18428&quot;&gt;백준 18428번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

n = int(input())
graph = []
for _ in range(n):
    graph.append(input().split())
# teachers
ts = set()
candidates = []
for i in range(n):
    for j in range(n):
        if graph[i][j] == 'T':
            ts.add((i, j))
        elif graph[i][j] == 'X':
            candidates.append((i, j))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
        
combs = combinations(candidates, 3)


def cctv(x, y, i, visited):
    global s
    visited.add((x, y))
    if graph[x][y] == 'S':
        s.add((x, y))
    nx, ny = x+dx[i], y+dy[i]
    if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and (nx, ny) not in visited and graph[nx][ny] != 'O':
        cctv(nx, ny, i, visited)


cnt = 36
for comb in combs:
    s = set()
    for i, j in comb:
        graph[i][j] = 'O'
    for t in ts:
        visited = set()
        for i in range(4):
            cctv(t[0], t[1], i, visited)
    for i, j in comb:
        graph[i][j] = 'X'
    cnt = min(cnt, len(s))

if not cnt:
    print(&quot;YES&quot;)
else:
    print(&quot;NO&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일반적인 DFS가 아니라 방향이 있는 DFS로 풀면 된다. 사실은 재귀가 아닌 단순 반복문으로도 풀 수 있는 문제다.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18428.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18428.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 경쟁적 전염</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18405&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18405&quot;&gt;백준 18405번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque


n, k = map(int, input().split())
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))
s, x, y = map(int, input().split())

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(graph):
    cnt = 1
    q = []
    visited = [[False] * (1+n) for _ in range(1+n)]
    for i in range(n):
        for j in range(n):
            if graph[i][j] != 0:
                q.append((i, j, cnt))
                visited[i][j] = True
    # 1번 바이러스부터 순서대로 탐색
    q.sort(key=lambda x: graph[x[0]][x[1]])
    q = deque(q)
    while q:
        x, y, cnt = q.popleft()
        # s초가 지나면 종료
        if cnt &amp;gt; s:
            return
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and not visited[nx][ny] and graph[nx][ny] == 0:
                visited[nx][ny] = True
                graph[nx][ny] = graph[x][y]
                q.append((nx, ny, cnt+1))


bfs(graph)
print(graph[x-1][y-1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1번부터 순서대로 탐색하도록 BFS를 구현하는게 조금 까다로운 문제였다.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18405.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18405.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - 특정 거리의 도시 찾기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18352&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18352&quot;&gt;백준 18352번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, m, k, x = map(int, input().split())
graph = [[] for _ in range(n+1)]
for _ in range(m):
    i, j = map(int, input().split())
    graph[i].append(j)
res = []


def bfs(start):
    global res
    cnt = 0
    q = deque([(start, cnt)])
    visited = [False] * (1+n)
    visited[start] = True
    while q:
        now, cnt = q.popleft()
        if cnt == k:
            res.append(now)
        for v in graph[now]:
            if not visited[v]:
                visited[v] = True
                q.append((v, cnt+1))
    

bfs(x)

if not res:
    print(-1)
else:
    res.sort()
    print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18352.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18352.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 인구 이동</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem16234&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16234&quot;&gt;백준 16234번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, l, r = map(int, input().split())
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y, visited):
    if visited[x][y]:
        return 0
    q = deque([(x, y)])
    visited[x][y] = True
    neighbors = [(x, y)]
    cnt = 0
    while q:
        x, y = q.popleft()
        cnt += 1
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and not visited[nx][ny]:
                diff = abs(graph[x][y]-graph[nx][ny])
                if l &amp;lt;= diff &amp;lt;= r:
                    visited[nx][ny] = True
                    q.append((nx, ny))
                    neighbors.append((nx, ny))
    # 연합을 맺지 못함
    if cnt == 1:
        return 0
    total = 0
    for x, y in neighbors:
        total += graph[x][y]
    for x, y in neighbors:
        graph[x][y] = total // len(neighbors)
    return cnt


res = 0
while True:
    cnt = 0
    visited = [[False] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            cnt += bfs(i, j, visited)
    if cnt == 0:
        print(res)
        break
    res += 1
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-16234.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-16234.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 연산자 끼워넣기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14888&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14888&quot;&gt;백준 14888번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))
ops = list(map(int, input().split()))
min_val = int(1e9)
max_val = -int(1e9)


def solution(idx, ops, val):
    global min_val, max_val
    if idx == n-1:
        min_val = min(min_val, val)
        max_val = max(max_val, val)
        return

    for i in range(4):
        if ops[i] &amp;lt;= 0:
            continue
        ops[i] -= 1
        if i == 0:
            solution(idx+1, ops, val+arr[idx+1])
        elif i == 1:
            solution(idx+1, ops, val-arr[idx+1])
        elif i == 2:
            solution(idx+1, ops, val*arr[idx+1])
        elif i == 3:
            if val &amp;lt; 0:
                solution(idx+1, ops, -(-val // arr[idx+1]))
            else:
                solution(idx+1, ops, val // arr[idx+1])
        ops[i] += 1


solution(0, ops, arr[0])

print(max_val)
print(min_val)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;완전 탐색/DFS를 통해 풀 수 있었다.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-14888.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-14888.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 괄호 변환</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons60058&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/60058&quot;&gt;프로그래머스 60058번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def is_right(p):
    stack = []
    for ch in p:
        if ch == '(':
            stack.append(ch)
        else:
            if len(stack) == 0 or stack.pop() != '(':
                return False
    return len(stack) == 0

def is_balanced(p):
    return p.count('(') == p.count(')')

def parse(p):
    u, v = p, ''
    for i in range(1, len(p)):
        u_, v_ = p[:i], p[i:]
        if is_balanced(u_) and is_balanced(v_):
            u, v = u_, v_
            break
    return u, v

def solution(p):
    answer = ''
    if is_right(p):
        return p
    u, v = parse(p)
    if is_right(u):
        answer = u + solution(v)
    else:
        answer += '('
        answer += solution(v)
        answer += ')'
        for ch in u[1:-1]:
            if ch == '(':
                answer += ')'
            else:
                answer += '('
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;문제 자체가 헷갈리게 서술되어 있어서 많이 헤맸다..&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/PR-60058.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/PR-60058.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv3 - 단어 변환</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons43163&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/43163&quot;&gt;프로그래머스 43163번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

def diff(word1, word2):
    cnt = 0
    for i in range(len(word1)):
        if word1[i] != word2[i]:
            cnt += 1
    return cnt

def solution(begin, target, words):
    answer = 0
    q = deque([(begin, answer)])
    visited = set()
    visited.add(begin)
    while q:
        now, ans = q.popleft()
        if now == target:
            return ans
        neighbors = [word for word in words if diff(now, word) == 1]
        for n in neighbors:
            if n not in visited:
                visited.add(n)
                q.append((n, ans+1))
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그래프인걸 알고 풀어서 쉬웠지만 몰랐다면 그래프/BFS를 생각해내기 쉽지 않았을 것 같은 문제.&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/PR-43163.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/PR-43163.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - 나이트의 이동</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem7562&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/7562&quot;&gt;백준 7562번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

t = int(input())
res = []

dx = [-2, -2, -1, -1, 1, 1, 2, 2]
dy = [-1, 1, -2, 2, -2, 2, -1, 1]


def solve(n, src, dest):
    cnt = 0
    q = deque([(src[0], src[1], cnt)])
    visited = set()
    visited.add(src)
    while q:
        x, y, cnt = q.popleft()
        if (x, y) == dest:
            return cnt
        for i in range(8):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and (nx, ny) not in visited:
                visited.add((nx, ny))
                q.append((nx, ny, cnt+1))
    return -1


for _ in range(t):
    n = int(input())
    src = tuple(map(int, input().split()))
    dest = tuple(map(int, input().split()))
    cnt = solve(n, src, dest)
    res.append(cnt)

print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전형적인 BFS 문제였다.&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/BOJ-7562.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/BOJ-7562.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 빙산</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2573&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2573&quot;&gt;백준 2573번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, m = map(int, input().split())
graph = []
for _ in range(n):
    tmp = map(int, input().split())
    graph.append(list(tmp))

ices = set()
for i in range(n):
    for j in range(m):
        if graph[i][j] &amp;gt; 0:
            ices.add((i, j))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def melt(ices):
    new_ices = set()
    dels = set()
    for x, y in ices:
        cnt = 0
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and graph[nx][ny] == 0:
                cnt += 1
        new_ices.add((x, y, graph[x][y]-cnt))
    # 빙산 녹이기
    for x, y, val in new_ices:
        graph[x][y] = max(0, val)
        if graph[x][y] == 0:
            dels.add((x, y))
    # 녹은 빙산은 제외
    ices = ices - dels
    return ices

def bfs(x, y):
    q = deque([(x, y)])
    visited = {(x, y)}
    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; m and graph[nx][ny] &amp;gt; 0 and (nx, ny) not in visited:
                visited.add((nx, ny))
                q.append((nx, ny))
    return len(visited)


res = 0
while True:
    res += 1
    ices = melt(ices)
    # 빙산이 다 녹아버린 상태
    if not ices:
        print(0)
        break
    # 임의의 점에서 BFS 수행
    for x, y in ices:
        cnt = bfs(x, y)
        break
    # 빙산이 두 덩어리 이상으로 나눠짐
    if cnt &amp;lt; len(ices):
        print(res)
        break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그래프 문제로 알고 풀었는데 사실은 구현에 더 초점이 맞춰진 문제였다. 그냥 문제에서 제시한 대로 빙산이 녹는 걸 구현한 후, BFS를 이용해서 연결된 빙산의 수를 구해 전체 빙산의 수보다 적다면 빙산이 나눠진 것이므로 위와 같은 방식으로 풀 수 있었다.&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/BOJ-2573.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/BOJ-2573.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - DFS 스페셜 저지</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem16964&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16964&quot;&gt;백준 16964번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;틀린 풀이(시간초과)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
graph = [set() for _ in range(n+1)]
for _ in range(n-1):
    i, j = map(int, input().split())
    graph[i].add(j)
    graph[j].add(i)
stack = list(map(int, input().split()))
my_stack = []
visited = [False] * len(graph)


def dfs(i, visited):
    global my_stack
    visited[i] = True
    my_stack.append(i)
    for j in range(len(stack)):
        if not visited[stack[j]] and stack[j] in graph[i]:
            dfs(stack[j], visited)


dfs(stack[0], visited)
if my_stack == stack:
    print(1)
else:
    print(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for j in range(len(stack))&lt;/code&gt; 이 부분이 $O(N)$이기 때문에 전체 시간복잡도가 $O(N^{2})$가 되서 시간초과로 틀렸다. 그래서 어떻게 해야할까 고민하다가 인접 리스트를 탐색의 순서대로 정렬해도 같은 결과가 아닌가??라는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;올바른 풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
graph = [[] for _ in range(n+1)]
for _ in range(n-1):
    i, j = map(int, input().split())
    graph[i].append(j)
    graph[j].append(i)
stack = list(map(int, input().split()))
d = {}
for i in range(len(stack)):
    d[stack[i]] = i
# 탐색해야 하는 순서대로 정렬
for g in graph:
    g.sort(key=lambda x: d[x])
my_stack = []
visited = [False] * len(graph)


def dfs(i, visited):
    global my_stack
    visited[i] = True
    my_stack.append(i)
    for j in graph[i]:
        if not visited[j]:
            dfs(j, visited)


dfs(1, visited)
if my_stack == stack:
    print(1)
else:
    print(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사실 이 문제에 좀 오류가 있는 것 같은게 &lt;code class=&quot;highlighter-rouge&quot;&gt;dfs(stack[0], visited)&lt;/code&gt;로 하면 100% 까지 맞다가 틀린다. 항상 1번부터 탐색을 하기 때문에 2번부터 탐색을 하면 올바른 DFS라도 틀려야한다는데 좀 억지스러웠다. 여튼 &lt;code class=&quot;highlighter-rouge&quot;&gt;dfs(1, visited)&lt;/code&gt;로 해야 맞는다.&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/16/BOJ-16964.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/16/BOJ-16964.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
