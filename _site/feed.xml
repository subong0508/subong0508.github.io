<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 20 Mar 2021 14:23:43 +0900</pubDate>
    <lastBuildDate>Sat, 20 Mar 2021 14:23:43 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>백준 Gold2 - 트리의 높이와 너비</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2250&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2250&quot;&gt;백준 2250번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import sys

input = sys.stdin.readline

n = int(input())
# 왼쪽, 오른쪽 노드를 저장해놓는 dict
tree = {i: [-1, -1] for i in range(1, n+1)}
# 부모를 저장해놓는 배열, root를 구하기 위함
parent = [i for i in range(n+1)]
for _ in range(n):
    par, a, b = map(int, input().split())
    if a != -1:
        parent[a] = par
        tree[par][0] = a
    if b != -1:
        parent[b] = par
        tree[par][1] = b

root = 1
for i in range(1, n+1):
    if parent[i] == i:
        root = i
        break
height = 1

def get_height(now, level): # 트리의 높이를 구한다
    global height
    height = max(height, level)
    if tree[now][0] != -1:
        get_height(tree[now][0], level+1)
    if tree[now][1] != -1:
        get_height(tree[now][1], level+1)

get_height(root, 1)

arr = [[-1] * (n+1) for _ in range(height+1)] # 트리 저장하는 배열
col = 0

def inorder(now, level): # 중위 탐색을 하면서 열번호 찾기
    global col
    if tree[now][0] != -1:
        inorder(tree[now][0], level+1)
    col += 1
    arr[level][col] = now
    if tree[now][1] != -1:
        inorder(tree[now][1], level+1)

inorder(root, 1)

max_width = 0
max_level = 1
for i in range(1, height+1):
    row = [j for j in range(1, n+1) if arr[i][j] != -1]
    tmp = max(row)-min(row)+1
    if tmp &amp;gt; max_width:
        max_width = tmp
        max_level = i

print(max_level, max_width)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 20 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/20/BOJ-2250.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/20/BOJ-2250.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold1 - 트리의 독립집합</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2213&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2213&quot;&gt;백준 2213번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import sys

input = sys.stdin.readline

n = int(input())
weights = [0] + list(map(int, input().split()))
graph = [[] for _ in range(n+1)]
for i in range(n-1):
    a, b = map(int, input().split())
    # 단방향 그래프로 만들어준다.
    if a &amp;lt; b:
        graph[a].append(b)
    else:
        graph[b].append(a)

dp1 = [[-1, -1] for _ in range(n+1)] # 첫번째 원소는 안넣었을 때, 두번째 원소는 넣었을 때
visited = [False] * (n+1)
dp2 = [[[], []] for _ in range(n+1)]

def solution(i, dp1, dp2):
    if visited[i]:
        return
    visited[i] = True
    dp1[i][0] = 0
    dp1[i][1] = weights[i]
    dp2[i][1].append(i)
    for j in graph[i]:
        solution(j, dp1, dp2)
        a, b = dp1[j]
        if a &amp;lt; b: # 더 큰걸 선택
            dp1[i][0] += b
            dp2[i][0] += dp2[j][1]
        else:
            dp1[i][0] += a
            dp2[i][0] += dp2[j][0]
        dp1[i][1] += a # i번째 원소를 넣을 거면 j번째 원소는 넣으면 안된다
        dp2[i][1] += dp2[j][0]

solution(1, dp1, dp2)

if dp1[1][0] &amp;lt; dp1[1][1]:
    print(dp1[1][1])
    dp2[1][1].sort()
    print(*dp2[1][1])
else:
    print(dp1[1][0])
    dp2[1][0].sort()
    print(*dp2[1][0])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 20 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/20/BOJ-2213.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/20/BOJ-2213.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 트리</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem4803&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/4803&quot;&gt;백준 4803번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import sys

input = sys.stdin.readline

def dfs(now, prev, graph, visited):
    visited[now] = True
    for next in graph[now]:
        if next == prev:
            continue
        if visited[next]:
            return False
        if not dfs(next, now, graph, visited):
            return False
    return True

def count_tree(n, graph, visited):
    cnt = 0
    for i in range(1, n+1):
        if not visited[i] and dfs(i, 0, graph, visited):
            cnt += 1
    return cnt

i = 0
res = []
while True:
    i += 1
    n, m = map(int, input().split())
    if n == 0 and m == 0:
        break
    graph = [[] for _ in range(n+1)]
    for _ in range(m):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)
    visited = [False] * (n+1)
    cnt = count_tree(n, graph, visited)
    if cnt == 0:
        res.append(&quot;Case %d: No trees.&quot; % i)
    elif cnt == 1:
        res.append(&quot;Case %d: There is one tree.&quot; % i)
    else:
        res.append(&quot;Case %d: A forest of %d trees.&quot; % (i, cnt))

print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 18 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/18/BOJ-4803.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/18/BOJ-4803.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold1 - 우수 마을</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1949&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1949&quot;&gt;백준 1949번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import sys

sys.setrecursionlimit(10 ** 5)

n = int(input())
arr = list(map(int, input().split()))
graph = [[] for _ in range(n+1)]
for _ in range(n-1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

dp = [[0, 0] for _ in range(n+1)]
visited = [False] * (n+1)

def dfs(i, dp, visited):
    dp[i][0] = 0 # 포함하지 않음
    dp[i][1] = arr[i-1]
    visited[i] = True
    for j in graph[i]:
        if not visited[j]:
            dfs(j, dp, visited)
            dp[i][0] = max(dp[i][0]+dp[j][0], dp[i][0]+dp[j][1])
            dp[i][1] += dp[j][0]

dfs(1, dp, visited)

print(max(dp[1]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;트리 DP 문제, 다시 풀어봐야 할 것 같다 ㅠ&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/18/BOJ-1949.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/18/BOJ-1949.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv3 - 길 찾기 게임</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42892&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42892&quot;&gt;프로그래머스 42892번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import sys

sys.setrecursionlimit(10 ** 5)

class Node:
    def __init__(self, data, x):
        self.data = data
        self.x = x
        self.l = None
        self.r = None
        
pre = []
post = []

def preorder(node):
    if node is None:
        return
    pre.append(node.data)
    preorder(node.l)
    preorder(node.r)
    
def postorder(node):
    if node is None:
        return
    postorder(node.l)
    postorder(node.r)
    post.append(node.data)
        
def solution(nodeinfo):
    answer = []
    nodeinfo = [[i+1] + node for i, node in enumerate(nodeinfo)]
    nodeinfo = sorted(nodeinfo, key=lambda x: (-x[2], x[1]))
    root = None
    for node in nodeinfo:
        if not root:
            root = Node(node[0], node[1])
        else:
            current = root
            while True:
                if node[1] &amp;lt; current.x:
                    if current.l:
                        current = current.l
                        continue
                    else:
                        current.l = Node(node[0], node[1])
                        break
                if node[1] &amp;gt; current.x:
                    if current.r:
                        current = current.r
                        continue
                    else:
                        current.r = Node(node[0], node[1])
                        break
    preorder(root)
    answer.append(pre)
    postorder(root)
    answer.append(post)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;직접 구현해야만 풀 수 있는 문제, 다시 풀어봐야지&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/17/PR-42892.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/17/PR-42892.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 트리 순회</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1991&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1991&quot;&gt;백준 1991번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())


class Node:
    def __init__(self, data, l=None, r=None):
        self.data = data
        self.l = l 
        self.r = r


def find_node(now, data):
    if now is None:
        return None
    if now.data == data:
        return now
    l = find_node(now.l, data)
    if l is None:
        return find_node(now.r, data)
    else:
        return l


root = None
for i in range(n):
    data, l, r = input().split()
    l = Node(l) if l != '.' else None
    r = Node(r) if r != '.' else None
    if i == 0:
        root = Node(data, l, r)
        continue
    now = find_node(root, data)
    now.l = l
    now.r = r


def preorder(node):
    if node is None:
        return
    print(node.data, sep='', end='')
    preorder(node.l)
    preorder(node.r)

def inorder(node):
    if node is None:
        return 
    inorder(node.l)
    print(node.data, sep='', end='')
    inorder(node.r)

def postorder(node):
    if node is None:
        return 
    postorder(node.l)
    postorder(node.r)
    print(node.data, sep='', end='')


funcs = [preorder, inorder, postorder]
for func in funcs:
    func(root)
    print()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 17 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/17/BOJ-1991.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/17/BOJ-1991.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - 병사 배치하기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18353&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18353&quot;&gt;백준 18353번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))

dp = [0] * n
for i in range(n):
    dp[i] = 1
    for j in range(i):
        if arr[i] &amp;lt; arr[j]:
            dp[i] = max(dp[i], dp[j]+1)

print(n-max(dp))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 15 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/15/BOJ-18353.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/15/BOJ-18353.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 1로 만들기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1463&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1463&quot;&gt;백준 1463번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
INF = int(1e9)
dp = [INF] * (n+1)
dp[1] = 0
for i in range(1, n+1):
    if i % 3 == 0 and 0 &amp;lt;= i // 3 &amp;lt;= n:
        dp[i] = min(dp[i], dp[i // 3]+1)
    if i % 2 == 0 and 0 &amp;lt;= i // 2 &amp;lt;= n:
        dp[i] = min(dp[i], dp[i // 2]+1)
    if 0 &amp;lt;= i-1 &amp;lt;= n:
        dp[i] = min(dp[i], dp[i-1]+1)

print(dp[n])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 15 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/15/BOJ-1463.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/15/BOJ-1463.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver4 - 퇴사</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14501&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14501&quot;&gt;백준 14501번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
ts = [0] * (n+1)
ps = [0] * (n+1)
for i in range(1, n+1):
    t, p = map(int, input().split())
    ts[i] = t
    ps[i] = p

dp = [0] * (n+1)
for i in range(1, n+1):
    tmp = i+ts[i]-1
    # i번째 일을 할 수 있는 경우에만
    if tmp &amp;lt;= n:
        dp[tmp] = max(dp[tmp], ps[i])
        for j in range(1, i):
            dp[tmp] = max(dp[tmp], dp[j]+ps[i])
        
print(max(dp))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 15 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/15/BOJ-14501.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/15/BOJ-14501.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 양팔저울</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2629&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2629&quot;&gt;백준 2629번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))
m = int(input())
ws = list(map(int, input().split()))

dp = [[False] * 40001 for _ in range(n+1)]
dp[0][0] = True

for i in range(1, n+1):
    now = arr[i-1] # 현재 추의 무게
    for j in range(40001):
        if dp[i-1][j]:
            dp[i][j] = True
            tmp = [j-now, j+now, now-j, now+j]
            for t in tmp:
                if 0 &amp;lt;= t &amp;lt;= 40000:
                    dp[i][t] = True
                    
res = ['N'] * m
for i in range(m):
    if dp[n][ws[i]]:
        res[i] = 'Y'

print(*res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국 구슬의 무게는 추들을 더하거나 빼서 만들어야 하기 때문에 위와 같은 점화식이 나온다.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/03/13/BOJ-2629.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/03/13/BOJ-2629.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
