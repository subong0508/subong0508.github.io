<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 22 Feb 2021 01:21:44 +0900</pubDate>
    <lastBuildDate>Mon, 22 Feb 2021 01:21:44 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>백준 Gold3 - 청소년 상어</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem19236&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19236&quot;&gt;백준 19236번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from copy import deepcopy

graph = [[-1] * 4 for _ in range(4)]
for i in range(4):
    tmp = list(map(int, input().split()))
    for j in range(0, 8, 2):
        graph[i][j // 2] = [tmp[j], tmp[j+1]]

moves = {1: [-1, 0], 2: [-1, -1], 3: [0, -1], 4: [1, -1],
         5: [1, 0], 6: [1, 1], 7: [0, 1], 8: [-1, 1]}
shark = [0, 0]
res = 0

def check_fish(x, y, d, shark):
    nx, ny = x+moves[d][0], y+moves[d][1]
    if nx &amp;lt; 0 or nx &amp;gt;= 4 or ny &amp;lt; 0 or ny &amp;gt;= 4 or [nx, ny] == shark:
        return [-1, -1]
    else:
        return [nx, ny]

def move_fish(graph, shark):
    order = {}
    for i in range(4):
        for j in range(4):
            if [i, j] != shark and graph[i][j][0] != 0:
                # 번호: 좌표
                order[graph[i][j][0]] = (i, j)
    order = sorted(order.items(), key=lambda x: x[0])
    order = dict(order)
    for o in order.keys():
        x, y = order[o]
        while True:
            nx, ny = check_fish(x, y, graph[x][y][1], shark)
            if nx != -1 and ny != -1:
                break
            # rotate
            graph[x][y][1] += 1
            if graph[x][y][1] &amp;gt; 8:
                graph[x][y][1] -= 8
        # 다른 물고기가 있는 칸이라면
        if graph[nx][ny][0] != 0:
            # swap
            order[graph[x][y][0]], order[graph[nx][ny][0]] = (nx, ny), (x, y)
            graph[x][y], graph[nx][ny] = graph[nx][ny], graph[x][y]
        else: # 비어있는 칸이라면
            order[graph[x][y][0]] = (nx, ny)
            graph[nx][ny] = graph[x][y]
            graph[x][y] = [0, 0]

def move_shark(now, graph, shark): # 지금까지 먹은 물고기수, 그래프, 상어 좌표
    global res
    move_fish(graph, shark)
    x, y = shark
    # 물고기 개수, 방향
    num, d = graph[x][y]
    dx, dy = moves[d]
    # 잡아 먹힘
    graph[x][y] = [0, 0]
    results = []
    for i in range(1, 4):
        nx, ny = x+dx*i, y+dy*i
        if 0 &amp;lt;= nx &amp;lt; 4 and 0 &amp;lt;= ny &amp;lt; 4 and graph[nx][ny][0] != 0:
            results.append((nx, ny))
    if results:
        for nx, ny in results:
            move_shark(now+num, deepcopy(graph), [nx, ny])
    else: # 더 이상 갈 곳이 없으므로 종료
        res = max(res, now+num)

move_shark(0, graph, shark)

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;구현이 굉장히 빡센 문제.. 연습이 많이 필요할 것 같다.&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/21/BOJ-19236.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/21/BOJ-19236.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold2 - 2048(Easy)</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem12100&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/12100&quot;&gt;백준 12100번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from copy import deepcopy
from collections import deque

n = int(input())
board = []
for _ in range(n):
    board.append(list(map(int, input().split())))


def go_up(board):
    for j in range(n):
        col = [board[i][j] for i in range(n) if board[i][j] &amp;gt; 0]
        col = col + [0] * (n-len(col))
        i = 0
        new_col = deque()
        while i &amp;lt; n-1:
            if col[i] == col[i+1]:
                new_col.append(col[i]+col[i+1])
                i += 2
            else:
                new_col.append(col[i])
                i += 1
        if i == n-1:
            new_col.append(col[i])
        new_col = list(new_col) + [0] * (n-len(new_col))
        for i in range(n):
            board[i][j] = new_col[i]
        

def go_down(board):
    for j in range(n):
        col = [board[i][j] for i in range(n) if board[i][j] &amp;gt; 0]
        col = [0] * (n-len(col)) + col
        i = n-1
        new_col = deque()
        while i &amp;gt; 0:
            if col[i] &amp;gt; 0:
                if col[i] == col[i-1]:
                    new_col.appendleft(col[i]+col[i-1])
                    i -= 2
                else:
                    new_col.appendleft(col[i])
                    i -= 1
            else:
                i -= 1
        if i == 0 and col[i] &amp;gt; 0:
            new_col.appendleft(col[i])
        new_col = [0] * (n-len(new_col)) + list(new_col)
        for i in range(n):
            board[i][j] = new_col[i]


def go_right(board):
    for i in range(n):
        row = [x for x in board[i] if x &amp;gt; 0]
        row = [0] * (n-len(row)) + row
        j = n-1
        new_row = deque()
        while j &amp;gt; 0:
            if row[j] &amp;gt; 0:
                if row[j] == row[j-1]:
                    new_row.appendleft(row[j]+row[j-1])
                    j -= 2
                else:
                    new_row.appendleft(row[j])
                    j -= 1
            else:
                j -= 1
        if j == 0 and row[j] &amp;gt; 0:
            new_row.appendleft(row[j])
        new_row = [0] * (n-len(new_row)) + list(new_row)
        for j in range(n):
            board[i][j] = new_row[j]


def go_left(board):
    for i in range(n):
        row = [x for x in board[i] if x &amp;gt; 0]
        row = row + [0] * (n-len(row))
        j = 0
        new_row = deque()
        while j &amp;lt; n-1:
            if row[j] &amp;gt; 0:
                if row[j] == row[j+1]:
                    new_row.append(row[j]+row[j+1])
                    j += 2
                else:
                    new_row.append(row[j])
                    j += 1
            else:
                j += 1
        if j == n-1 and row[j] &amp;gt; 0:
            new_row.append(row[j])
        new_row = list(new_row) + [0] * (n-len(new_row))
        for j in range(n):
            board[i][j] = new_row[j]

res = 0

def go(cnt, board):
    global res
    if cnt == 5:
        for i in range(n):
            for j in range(n):
                res = max(res, board[i][j])
        return
    for i in range(4):
        board_ = deepcopy(board)
        if i == 0:
            go_up(board_)
            go(cnt+1, board_)
        elif i == 1:
            go_down(board_)
            go(cnt+1, board_)
        elif i == 2:
            go_right(board_)
            go(cnt+1, board_)
        elif i == 3:
            go_left(board_)
            go(cnt+1, board_)

go(0, board)

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0인 것들은 제외하고 새로운 행/열을 만든 다음에 합쳐주는게 관건이었다. 그 와중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;deque&lt;/code&gt;를 적절히 사용해야 순서가 안바뀌고 제대로 된다. 구현은 언제 풀어도 어렵다ㅠ&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/21/BOJ-12100.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/21/BOJ-12100.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold3 - 독특한 계산기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem19591&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19591&quot;&gt;백준 19591번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

x = input()
n = len(x)
pr = {'+': 0, '-': 0, '*': 1, '/': 1}
nums = []
ops = []

i = 0
while i &amp;lt; n:
    j = i
    while j &amp;lt; n and (j == 0 or x[j] not in pr.keys()):
        j += 1
    nums.append(int(x[i:j]))
    if j &amp;lt; n:
        ops.append(x[j])
    i = j + 1

nums = deque(nums)
ops = deque(ops)

def calc(op, n1, n2):
    if op == '+':
        res = n1 + n2
    elif op == '-':
        res = n1 - n2
    elif op == '*':
        res = n1 * n2
    else:
        res = int(n1 / n2)
    return res

while ops:
    if len(ops) == 1:
        op = ops.popleft()
        n1, n2 = nums.popleft(), nums.popleft()
        nums.appendleft(calc(op, n1, n2))
    else:
        op1 = ops.popleft()
        op2 = ops.pop()
        if pr[op1] &amp;gt; pr[op2] or (pr[op1] == pr[op2] and calc(op1, nums[0], nums[1]) &amp;gt;= calc(op2, nums[-2], nums[-1])):
            n1, n2 = nums.popleft(), nums.popleft()
            nums.appendleft(calc(op1, n1, n2))
            ops.append(op2)
        else:
            n2, n1 = nums.pop(), nums.pop()
            nums.append(calc(op2, n1, n2))
            ops.appendleft(op1)

print(nums[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;별로 어려운 문제는 아니었는데 문제를 잘못이해해서 $\log (N)$으로 풀어야 하는 줄 알고 헤맸다.&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/20/BOJ-19591.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/20/BOJ-19591.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - ⚾</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem17281&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17281&quot;&gt;백준 17281번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이(시간초과)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import permutations

n = int(input())
players = list(range(1, 10))
order = permutations(players, len(players))
order = [o for o in order if o[3] == 1]
results = []
for _ in range(n):
    results.append([-1] + list(map(int, input().split())))

def baseball(c, results):
    score = 0
    idx = 0
    inning = 0
    while inning &amp;lt; n:
        # 홈, 1루, 2루, 3루
        cur = [0, 0, 0, 0]
        num_out = 0
        while num_out &amp;lt; 3:
            # 현재 점수
            now = results[inning][c[idx]]
            if now == 0:
                num_out += 1
            else:
                cur[0] += 1
                # 선수들의 이동을 저장하는 배열
                add = [0, 0, 0, 0]
                for i in range(4):
                    if i + now &amp;gt;= 4:
                        score += cur[i]
                    else:
                        add[i + now] += cur[i]
                    add[i] -= cur[i]
                for i in range(4):
                    cur[i] += add[i]
            idx = (idx + 1) % 9
        inning += 1
    return score

score = 0
for o in order:
    score = max(score, baseball(o, results))

print(score)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;분명히 맞는 알고리즘인데 왜 시간초과가 나지 하고 살펴보니 파이썬으로 풀면 시간초과가 날 수 밖에 없는 문제였다. 배열을 쓰지말고 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;를 사용해야 시간초과에 안걸린다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import permutations

n = int(input())
players = list(range(1, 10))
order = permutations(players, len(players))
order = [o for o in order if o[3] == 1]
results = []
for _ in range(n):
    results.append([-1] + list(map(int, input().split())))

def baseball(c, results):
    score = 0
    idx = 0
    inning = 0
    while inning &amp;lt; n:
        # 홈, 1루, 2루, 3루
        b0, b1, b2, b3 = 0, 0, 0, 0
        num_out = 0
        while num_out &amp;lt; 3:
            # 현재 점수
            now = results[inning][c[idx]]
            if now == 0:
                num_out += 1
            else:
                b0 += 1
                if now == 1:
                    score += b3
                    b0, b1, b2, b3 = 0, b0, b1, b2
                elif now == 2:
                    score += (b2 + b3)
                    b0, b1, b2, b3 = 0, 0, b0, b1
                elif now == 3:
                    score += (b1 + b2 + b3)
                    b0, b1, b2, b3 = 0, 0, 0, b0
                elif now == 4:
                    score += (b0 + b1 + b2 + b3)
                    b0 = b1 = b2 = b3 = 0
            idx = (idx + 1) % 9
        inning += 1
    return score

score = 0
for o in order:
    score = max(score, baseball(o, results))

print(score)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 20 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/20/BOJ-17281.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/20/BOJ-17281.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 프렌즈4블록</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons17679&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/17679&quot;&gt;프로그래머스 17679번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def erase(m, n, board):
    s = set()
    for i in range(m-1):
        for j in range(n-1):
            # 이미 빈 상태
            if board[i][j] == 0:
                continue
            if board[i][j] == board[i+1][j] == board[i][j+1] == board[i+1][j+1]:
                s |= {(i, j), (i+1, j), (i, j+1), (i+1, j+1)}
    for i, j in s:
        board[i][j] = 0
    return len(s)

def go_down(m, n, board):
    for j in range(n):
        for i in range(m-1, -1, -1):
            if board[i][j] != 0:
                continue
            k = i
            while k &amp;gt;= 0 and board[k][j] == 0:
                k -= 1
            if k &amp;gt;= 0:
                board[i][j], board[k][j] = board[k][j], board[i][j]

def solution(m, n, board):
    board = [list(b) for b in board]
    answer = 0
    while True:
        tmp = erase(m, n, board)
        # 새로 지울게 없다면
        if tmp == 0:
            break
        answer += tmp
        go_down(m, n, board)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;애니팡..&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/PR-17679.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/PR-17679.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 인내의 도미노 장인 호석</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem20165&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20165&quot;&gt;백준 20165번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m, r = map(int, input().split())
domino = [list(map(int, input().split())) for _ in range(n)]
domino_origin = [[-1] * m for _ in range(n)]
for i in range(n):
    for j in range(m):
        domino_origin[i][j] = domino[i][j]
attack = []
defence = []
for i in range(2*r):
    if i % 2 == 0:
        x, y, d = input().split()
        attack.append((int(x)-1, int(y)-1, d))
    else:
        x, y = map(int, input().split())
        defence.append((x-1, y-1))
        
direcs = {&quot;E&quot;: [0, 1], &quot;W&quot;: [0, -1], &quot;S&quot;: [1, 0], &quot;N&quot;: [-1, 0]}

def hit(x, y, d):
    global cnt
    if x &amp;lt; 0 or x &amp;gt;= n or y &amp;lt; 0 or y &amp;gt;= m:
        return
    k = domino[x][y]
    dx, dy = direcs[d]
    for i in range(1, k):
        nx, ny = x+i*dx, y+i*dy
        hit(nx, ny, d)
    # 도미노 쓰러뜨리기
    if domino[x][y] != 0:
        cnt += 1
        domino[x][y] = 0

def up(x, y):
    if x &amp;lt; 0 or x &amp;gt;= n or y &amp;lt; 0 or y &amp;gt;= m:
        return
    domino[x][y] = domino_origin[x][y]

cnt = 0
for i in range(r):
    hit(*attack[i])
    up(*defence[i])

for i in range(n):
    domino[i] = ['S' if e != 0 else 'F' for e in domino[i]]

print(cnt)
for i in range(n):
    print(*domino[i])
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/BOJ-20165.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/BOJ-20165.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 미세먼지 안녕!</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem17144&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17144&quot;&gt;백준 17144번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;r, c, t = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(r)]
c1 = -1
for i in range(r):
    if graph[i][0] == -1:
        c1 = i
        break
c2 = c1+1

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dust():
    q = []
    for i in range(r):
        for j in range(c):
            if graph[i][j] &amp;gt; 0:
                q.append((i, j))
    infected = dict()
    deleted = dict()
    for x, y in q:
        cnt = 0
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; r and 0 &amp;lt;= ny &amp;lt; c and graph[nx][ny] != -1:
                cnt += 1
                infected[(nx, ny)] = infected.get((nx, ny), 0) + graph[x][y] // 5
        deleted[(x, y)] = cnt * (graph[x][y] // 5)
    for x, y in infected:
        graph[x][y] += infected[(x, y)]
    for x, y in deleted:
        graph[x][y] -= deleted[(x, y)]

def clean(xc, up):
    # 공기청정기 위/아래
    if up:
        ds = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    else:
        ds = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    x, y = xc, 1
    i = 0
    s = set()
    while True:
        nx, ny = x+ds[i][0], y+ds[i][1]
        if nx == xc and y == 0:
            break
        # 가장자리라면
        if nx &amp;lt; 0 or nx &amp;gt;= r or ny &amp;lt; 0 or ny &amp;gt;= c:
            i += 1
        else:
            s.add((nx, ny, graph[x][y]))
            x, y = nx, ny
    graph[xc][1] = 0
    for x, y, val in s:
        graph[x][y] = val

for _ in range(t):
    dust()
    clean(c1, True)
    clean(c2, False)

res = 0
for i in range(r):
    for j in range(c):
        if graph[i][j] &amp;gt; 0:
            res += graph[i][j]

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;쉬울 것 같았는데 생각보다 구현이 빡셌다.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/BOJ-17144.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/BOJ-17144.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 치킨 배달</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem15686&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15686&quot;&gt;백준 15686번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

n, m = map(int, input().split())
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))
chickens = [(i, j) for j in range(n) for i in range(n) if graph[i][j] == 2]
houses = [(i, j) for j in range(n) for i in range(n) if graph[i][j] == 1]

def cal_dist(h: tuple, c: tuple):
    return abs(h[0]-c[0])+abs(h[1]-c[1])

def cal_min_dist(h: tuple, cs: list):
    min_dist = int(1e9)
    for c in cs:
        min_dist = min(min_dist, cal_dist(h, c))
    return min_dist

res = int(1e9)
combs = combinations(chickens, m)
for comb in combs:
    tmp = 0
    cs = list(comb)
    for h in houses:
        tmp += cal_min_dist(h, cs)
    res = min(res, tmp)

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 19 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/19/BOJ-15686.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/19/BOJ-15686.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 감시 피하기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18428&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18428&quot;&gt;백준 18428번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

n = int(input())
graph = []
for _ in range(n):
    graph.append(input().split())
# teachers
ts = set()
candidates = []
for i in range(n):
    for j in range(n):
        if graph[i][j] == 'T':
            ts.add((i, j))
        elif graph[i][j] == 'X':
            candidates.append((i, j))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
        
combs = combinations(candidates, 3)


def cctv(x, y, i, visited):
    global s
    visited.add((x, y))
    if graph[x][y] == 'S':
        s.add((x, y))
    nx, ny = x+dx[i], y+dy[i]
    if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and (nx, ny) not in visited and graph[nx][ny] != 'O':
        cctv(nx, ny, i, visited)


cnt = 36
for comb in combs:
    s = set()
    for i, j in comb:
        graph[i][j] = 'O'
    for t in ts:
        visited = set()
        for i in range(4):
            cctv(t[0], t[1], i, visited)
    for i, j in comb:
        graph[i][j] = 'X'
    cnt = min(cnt, len(s))

if not cnt:
    print(&quot;YES&quot;)
else:
    print(&quot;NO&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일반적인 DFS가 아니라 방향이 있는 DFS로 풀면 된다. 사실은 재귀가 아닌 단순 반복문으로도 풀 수 있는 문제다.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18428.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18428.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 경쟁적 전염</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem18405&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18405&quot;&gt;백준 18405번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque


n, k = map(int, input().split())
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))
s, x, y = map(int, input().split())

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(graph):
    cnt = 1
    q = []
    visited = [[False] * (1+n) for _ in range(1+n)]
    for i in range(n):
        for j in range(n):
            if graph[i][j] != 0:
                q.append((i, j, cnt))
                visited[i][j] = True
    # 1번 바이러스부터 순서대로 탐색
    q.sort(key=lambda x: graph[x[0]][x[1]])
    q = deque(q)
    while q:
        x, y, cnt = q.popleft()
        # s초가 지나면 종료
        if cnt &amp;gt; s:
            return
        for i in range(4):
            nx, ny = x+dx[i], y+dy[i]
            if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and not visited[nx][ny] and graph[nx][ny] == 0:
                visited[nx][ny] = True
                graph[nx][ny] = graph[x][y]
                q.append((nx, ny, cnt+1))


bfs(graph)
print(graph[x-1][y-1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1번부터 순서대로 탐색하도록 BFS를 구현하는게 조금 까다로운 문제였다.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18405.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/18/BOJ-18405.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
