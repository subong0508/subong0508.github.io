<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 31 Jan 2021 23:42:14 +0900</pubDate>
    <lastBuildDate>Sun, 31 Jan 2021 23:42:14 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>백준 Gold4 - 스도쿠</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2239&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2239&quot;&gt;백준 2239번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from copy import deepcopy

board = []
for _ in range(9):
    string = input()
    tmp = [int(x) for x in string]
    board.append(tmp)
res = []


def is_possible(board, x, y):
    num = board[x][y]
    for i in range(9):
        # 가로로 같은지
        if i != y and num == board[x][i]:
            return False
        # 세로로 같은지
        if i != x and num == board[i][y]:
            return False
    # 3x3 사각형을 본다.
    x_, y_ = x // 3, y // 3
    x_, y_ = 3*x_, 3*y_
    for i in range(3):
        for j in range(3):
            if x == x_+i and y == y_+j:
                continue
            if num == board[x_+i][y_+j]:
                return False
    return True

def sdoku(board, x, y):
    global res
    # 항상 사전순이므로 상관 없음
    if not res:
        if x == 9:
            res = deepcopy(board)
            return
        if board[x][y] != 0:
            if y+1 &amp;lt; 9:
                sdoku(board, x, y+1)
            else:
                sdoku(board, x+1, 0)
        else:
            for i in range(1, 10):
                board[x][y] = i
                if is_possible(board, x, y):
                    if y+1 &amp;lt; 9:
                        sdoku(board, x, y+1)
                    else:
                        sdoku(board, x+1, 0)
                board[x][y] = 0


sdoku(board, 0, 0)
for row in res:
    for col in row:
        print(col, end='')
    print()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에느 &lt;code class=&quot;highlighter-rouge&quot;&gt;res&lt;/code&gt;를 리스트 변수로 만들어서 가능한 순서대로 다 넣은 다음 sort를 했더니
시간초과가 떴다. 그런데 for문 돌아가는 걸 생각해보니 그냥 제일 첫번째 성공케이스가 그 답 자체이기 때문에 위처럼 풀 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/31/BOJ-2239.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/31/BOJ-2239.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - 계란으로 계란치기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem16987&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16987&quot;&gt;백준 16987번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
eggs = []
for _ in range(n):
    s, w = map(int, input().split())
    eggs.append([s, w])
cnt = 0


def crush(l, cur, eggs):
    global cnt
    # 가장 오른쪽 계란
    if l == n:
        cnt = max(cnt, cur)
        return
    
    if eggs[l][0] &amp;gt; 0:
        all_broken = True
        for r in range(n):
            # 손에 든 계란이거나 이미 깨진 계란
            if r == l or eggs[r][0] &amp;lt;= 0:
                continue
            all_broken = False
            eggs[l][0] -= eggs[r][1]
            eggs[r][0] -= eggs[l][1]
            cur_ = cur
            cur_ += 1 if eggs[l][0] &amp;lt;= 0 else 0
            cur_ += 1 if eggs[r][0] &amp;lt;= 0 else 0
            crush(l+1, cur_, eggs)
            eggs[l][0] += eggs[r][1]
            eggs[r][0] += eggs[l][1]
        # 다 깨진 계란
        if all_broken:
            crush(l+1, cur, eggs)
    # 손에 든 계란이 깨진 경우
    else:
        crush(l+1, cur, eggs)


crush(0, 0, eggs)
print(cnt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에 알고리즘은 맞게 짰는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;eggs&lt;/code&gt;를 deepcopy해서 처리하는 바람에 시간초과가
났었다. 코딩 테스트에서 파이썬을 쓸 때는 deepcopy는 피하도록 하자.&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/31/BOJ-16987.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/31/BOJ-16987.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 연산자 끼워넣기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14888&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14888&quot;&gt;백준 14888번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = list(map(int, input().split()))
ops = list(map(int, input().split()))
min_val = int(1e9)
max_val = -int(1e9)


def solution(idx, ops, val):
    global min_val, max_val
    if idx == n-1:
        min_val = min(min_val, val)
        max_val = max(max_val, val)
        return

    for i in range(4):
        if ops[i] &amp;lt;= 0:
            continue
        ops[i] -= 1
        if i == 0:
            solution(idx+1, ops, val+arr[idx+1])
        elif i == 1:
            solution(idx+1, ops, val-arr[idx+1])
        elif i == 2:
            solution(idx+1, ops, val*arr[idx+1])
        elif i == 3:
            if val &amp;lt; 0:
                solution(idx+1, ops, -(-val // arr[idx+1]))
            else:
                solution(idx+1, ops, val // arr[idx+1])
        ops[i] += 1


solution(0, ops, arr[0])
print(max_val, min_val, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/31/BOJ-14888.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/31/BOJ-14888.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>Itertools 정리</title>
        <description>&lt;p&gt;내장 라이브러리인 &lt;code class=&quot;highlighter-rouge&quot;&gt;itertools&lt;/code&gt;를 이용해서 조합, 순열, 중복순열, Cartesian Product 등을 손쉽게 구현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations, permutations, combinations_with_replacement, product

data = '123'
l = combinations(data, 2)
for e in l:
    print(*e) # 12 13 23

l = permutations(data, 2)
for e in l:
    print(*e) # 12 13 21 23 31 32

l = combinations_with_replacement(data, 2)
for e in l:
    print(*e) # 11 12 13 22 23 33

l = product(data, repeat=2)
for e in l:
    print(*e) # 11 12 13 21 22 23 31 32 33
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/python/2021/01/30/Itertools.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/python/2021/01/30/Itertools.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - N-Queen</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem9663&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9663&quot;&gt;백준 9663번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
cnt = 0


def nqueen(arr):
    global cnt
    # 새로운 행 번호
    row = len(arr)
    if row == n:
        cnt += 1
        return

    for i in range(n):
        # 이미 있는 열
        if i in arr:
            continue
        flag = True
        # j번째 행, j번째 행에 해당하는 열 번호는 item
        for j, item in enumerate(arr):
            # 대각선
            if abs(i-item) == abs(row-j):
                flag = False
                break
        if flag:
            arr.append(i)
            nqueen(arr)
            arr.pop()
        

nqueen([])

print(cnt)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-9663.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-9663.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - N과 M(1)(2)(3)</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem15649&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15649&quot;&gt;백준 15649번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = [i for i in range(1, n+1)]
answer = []


def combinations(arr, s):
    global answer
    if len(s) == m:
        # shallow copy
        answer.append(s[:])
        return

    for e in arr:
        if e not in s:
            s.append(e)
            combinations(arr, s)
            s.pop()


combinations(arr, [])

for a in answer:
    print(*a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전형적인 백트랙킹 문제라고 하는데 백트랙킹이 뭔지 몰라서 찾아보니 완전탐색처럼 모든 경우를 탐색하지만 중간 중간에 조건에 맞지 않는 케이스를 가지치기하여 탐색시간을 줄이는 기법이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem15650&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15650&quot;&gt;백준 15650번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = [i for i in range(1, n+1)]
answer = []


def combinations(arr, s):
    global answer
    if len(s) == m:
        # shallow copy
        answer.append(s[:])
        return

    for e in arr:
        if len(s) == 0 or (s and e &amp;gt; s[-1]):
            s.append(e)
            combinations(arr, s)
            s.pop()


combinations(arr, [])

for a in answer:
    print(*a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1)과 거의 유사하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;len(s) == 0 or (s and e &amp;gt; s[-1])&lt;/code&gt;의 조건을 추가해서 오름차순이라는 조건과 중복이 없다는 조건을 만족할 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;httpswwwacmicpcnetproblem15651&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15651&quot;&gt;백준 15651번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, m = map(int, input().split())
arr = [i for i in range(1, n+1)]
answer = []


def combinations(arr, s):
    global answer
    if len(s) == m:
        # shallow copy
        answer.append(s[:])
        return

    for e in arr:
        s.append(e)
        combinations(arr, s)
        s.pop()


combinations(arr, [])

for a in answer:
    print(*a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 조건도 넣어주지 않으면 중복수열을 구할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-15649.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-15649.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 스타트와 링크</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem14889&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14889&quot;&gt;백준 14889번&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import combinations

n = int(input())
arr = [[0] * (n+1)]
for _ in range(n):
    arr.append([0] + list(map(int, input().split())))
whole = set(range(1,  n+1))
comb = list(combinations(whole, n//2))
# 중복되는 경우 제외
comb = comb[:len(comb)//2]

res = int(1e9)
for start_ in comb:
    start = set(start_)
    link = whole - start
    val1 = 0
    val2 = 0
    # 스타트 팀원들에 대해서
    for m in start:
        # Sii는 항상 0이므로 상관 없음
        for e in start:
            val1 += arr[m][e]
    # 링크 팀원들에 대해서
    for m in link:
        for e in link:
            val2 += arr[m][e]
    res = min(res, abs(val1-val2))

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;combinations&lt;/code&gt;를 통해 팀을 두개로 가른 다음 모든 경우에 대해 완전 탐색을 하면 된다.&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/30/BOJ-14889.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/30/BOJ-14889.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 소수 찾기</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42839&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42839&quot;&gt;프로그래머스 42839번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from itertools import permutations

def is_prime(n):
    if n &amp;lt;= 1:
        return False
    i = 2
    while i*i &amp;lt;= n:
        if n % i == 0:
            return False
        i += 1
    return True

def solution(numbers):
    s = set()
    for i in range(1, len(numbers)+1):
        comb = permutations(numbers, i)
        for c in comb:
            n = int(''.join(list(c)))
            if is_prime(n):
                s.add(n)
    return len(s)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/PR-42839.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/PR-42839.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 카펫</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42842&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42842&quot;&gt;프로그래머스 42842번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def is_right(n, m , brown, yellow):
    # n: 세로, m: 가로
    brown_ = 2*m+2*(n-2)
    yellow_ = n*m-brown_
    return brown_ == brown and yellow_ == yellow

def solution(brown, yellow):
    # a: 세로, b: 가로
    total = brown+yellow
    arr = []
    answer = []
    # arr: total의 약수 페어를 모아놓은 배열
    for i in range(1, total//2):
        if total % i == 0:
            a, b = i, total // i
            arr.append((min(a, b), max(a, b)))
    for a, b in arr:
        if a*b == brown+yellow and is_right(a, b, brown, yellow):
            answer.extend([b, a])
            break
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에는 이중 for loop으로 코드를 짰는데 시간복잡도에서 걸리는 것을 보고 시간복잡도를 $O(n)$으로 짰다. 이 문제의 핵심은 &lt;code class=&quot;highlighter-rouge&quot;&gt;brown+yellow&lt;/code&gt;의 약수를 $O(n)$으로 짜는 알고리즘인듯하다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/PR-42842.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/PR-42842.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv2 - 기능개발</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42586&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42586&quot;&gt;프로그래머스 42586번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;문제 설명&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.&lt;/p&gt;

&lt;p&gt;먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;제한 사항&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.&lt;/li&gt;
  &lt;li&gt;작업 진도는 100 미만의 자연수입니다.&lt;/li&gt;
  &lt;li&gt;작업 속도는 100 이하의 자연수입니다.&lt;/li&gt;
  &lt;li&gt;배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;입출력 예&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;progresses&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;speeds&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;return&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[93, 30, 55]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[1, 30, 5]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[2, 1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[95, 90, 99, 99, 80, 99]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[1, 1, 1, 1, 1, 1]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[1, 3, 2]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예시설명&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;입출력 예 #1
첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.
두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.
세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.&lt;/p&gt;

&lt;p&gt;따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.&lt;/p&gt;

&lt;p&gt;입출력 예 #2
모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.&lt;/p&gt;

&lt;p&gt;따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

def solution(progresses, speeds):
    # popleft: O(1)를 위해 deque로 바꿔준다.
    progresses = deque(progresses)
    speeds = deque(speeds)
    answer = []
    while progresses:
        while progresses[0] &amp;lt; 100:
            progresses = deque(map(lambda x, y:  x+y, progresses,
                              speeds))
        cnt = 0
        # 배포가 가능한 것들을 차례대로 배포
        while progresses and progresses[0] &amp;gt;= 100:
            progresses.popleft()
            speeds.popleft()
            cnt += 1
        answer.append(cnt)
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;큐 구조를 이용해서 풀 수 있는 문제였다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/01/29/PR-42586.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/01/29/PR-42586.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
