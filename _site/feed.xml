<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Vision</title>
    <description>My personal blog for studying; mainly related to data
</description>
    <link>http://subong0508.github.io/</link>
    <atom:link href="http://subong0508.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 13 Feb 2021 23:40:30 +0900</pubDate>
    <lastBuildDate>Sat, 13 Feb 2021 23:40:30 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>프로그래머스 Lv4 - 무지의 먹방 라이브</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42891&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42891&quot;&gt;프로그래머스 42891번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(food_times, k):
    ft = [(i+1, t) for i, t in zip(range(len(food_times)), food_times)]
    # 음식 먹는 시간이 작은 순대로 뒤에 오게 정렬
    ft = sorted(ft, key=lambda x: -x[1])
    prev = 0
    time = 0
    answer = -1
    while ft:
        idx, now = ft.pop()
        # pop 연산을 했으므로 +1
        time += (now-prev) * (len(ft) + 1)
        # k분보다 시간이 더 지났다면 무효화
        if time &amp;gt; k:
            time -= (now-prev) * (len(ft) + 1)
            ft.append((idx, now))
            break
        prev = now
    if ft:
        ft = sorted(ft, key=lambda x: x[0])
        idx = 0
        answer = ft[(k-time) % len(ft)][0]
    return answer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 문제는 큐를 사용해서 풀었다간 효율성 테스트에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;가 2 x 10 ^ 13이므로 틀린다. 따라서 힙을 사용하거나 정렬을 사용해야한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/13/PR-42891.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/13/PR-42891.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>DFS, BFS with Python</title>
        <description>&lt;h1 id=&quot;dfs--&quot;&gt;DFS(깊이 우선 탐색)&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Depth-First Search&lt;/strong&gt;의 약자로, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;그래프는 노드(Node)/정점(Vertex)과 간선(Edge)로 구성되는데 그래프를 표현하는 방법으로는 &lt;strong&gt;인접 행렬, 인접 리스트&lt;/strong&gt;가 있다.
인접 행렬은 NxN 행렬을 만들어서 i번째 노드에서 j번째 노드로 갈 수 있다면 1을 표시, 갈 수 없다면 0을 표시하는 것이 일반적이다.
인접 리스트의 i번째 원소는 i번째 노드에서 갈 수 있는 노드들을 담고 있다.&lt;/p&gt;

&lt;p&gt;DFS를 파이썬으로 나타낸 코드는 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;# 인접 리스트
graph = [
    [1, 2],
    [0, 3],
    [0],
    [3]
]
# 방문 여부
visited = [False] * len(graph)
stack = []


def dfs(i, visited, stack):
    stack.append(i)
    visited[i] = True
    for j in graph[i]:
        if not visited[j]:
            dfs(j, visited, stack)


dfs(0, visited, stack)
print(*stack) # 0 1 3 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;bfs--&quot;&gt;BFS(너비 우선 탐색)&lt;/h1&gt;

&lt;p&gt;BFS를 수행할 때는 선입선출의 특성을 띠는 큐 자료구조를 사용한다. BFS의 중요한 특징은 한 노드에서 다른 노드로 가는 최단거리를 항상 구한다는 것이다.&lt;/p&gt;

&lt;p&gt;BFS를 파이썬으로 나타낸 코드는 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque


# 인접 리스트
graph = [
    [1, 2],
    [0, 3],
    [0],
    [3]
]
# 방문 여부
visited = [False] * len(graph)
stack = []


def bfs(start, visited, stack):
    q = deque([start])
    while q:
        now = q.popleft()
        visited[now] = True
        stack.append(now)
        for j in graph[now]:
            if not visited[j]:
                q.append(j)
    

bfs(0, visited, stack)
print(*stack) # 0 1 2 3
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 13 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/data-structure/2021/02/13/DFS,-BFS.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/data-structure/2021/02/13/DFS,-BFS.html</guid>
        
        <category>graph</category>
        
        <category>dfs</category>
        
        <category>bfs</category>
        
        <category>python</category>
        
        <category>data-structure</category>
        
        
        <category>Data-Structure</category>
        
      </item>
    
      <item>
        <title>백준 Silver5 - 문자열 뒤집기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1439&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1439&quot;&gt;백준 1439번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;s = input()
n = len(s)
d = {'0': 0, '1': 0}

i = 0
while i &amp;lt; n:
    j = i + 1
    while j &amp;lt; n and s[j] == s[i]:
        j += 1
    d[s[i]] += 1
    i = j

print(min(d['0'], d['1']))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;연속된 0이 몇 번 나오는지/연속된 1이 몇 번 나오는지 구한 다음에 더 작은 수에 대해서 뒤집으면 된다.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/13/BOJ-1439.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/13/BOJ-1439.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver2 - DFS와 BFS</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1260&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1260&quot;&gt;백준 1260번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;from collections import deque

n, m, v = map(int, input().split())
graph = [[0] * (n+1) for _ in range(n+1)]
for _ in range(m):
    i, j = map(int, input().split())
    graph[i][j] = 1
    graph[j][i] = 1
visited1 = [False] * (n+1)
visited2 = [False] * (n+1)
stack1 = []
stack2 = []

def dfs(i, visited, stack):
    stack.append(i)
    visited[i] = True
    for j in range(1, n+1):
        if graph[i][j] == 1 and not visited[j]:
            dfs(j, visited, stack)

def bfs(start, visited, stack):
    q = deque([start])
    visited[start] = True
    while q:
        i = q.popleft()
        stack.append(i)
        for j in range(1, n+1):
            if graph[i][j] == 1 and not visited[j]:
                visited[j] = True
                q.append(j)


dfs(v, visited1, stack1)
bfs(v, visited2, stack2)

print(*stack1)
print(*stack2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DFS, BFS의 간단한 구현 문제. &lt;em&gt;단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고&lt;/em&gt;라는 조건 때문에 인접 행렬로 풀었다.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/13/BOJ-1260.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/13/BOJ-1260.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>프로그래머스 Lv3 - 단속카메라</title>
        <description>&lt;h3 id=&quot;httpsprogrammerscokrlearncourses30lessons42884&quot;&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42884&quot;&gt;프로그래머스 42884번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;def solution(routes):
    answer = 0
    routes.sort(key=lambda x: x[0])
    routes.sort(key=lambda x: x[1])
    cameras = []
    for r in routes:
        s, e = r
        done = False
        # 거꾸로 보는 것이 더 빠름
        for c in cameras[::-1]:
            if s &amp;lt;= c &amp;lt;= e:
                done = True
                break
        if not done:
            cameras.append(e)
    return len(cameras)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;괜히 어렵게 꼬아서 생각해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;heapq&lt;/code&gt; 쓰고 그랬는데 그냥 간단하게 풀 수 있는 문제였다. 꼬아서 생각하는 버릇좀 고쳐야지..&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/11/PR-42884.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/11/PR-42884.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 순회강연</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem2109&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2109&quot;&gt;백준 2109번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
arr = [-1] * n
for i in range(n):
    p, d = map(int, input().split())
    arr[i] = (p, d)
# 강연비순으로 정렬
arr.sort(key=lambda x: x[0])
filled = [False] * 10001

res = 0
while arr:
    p, d = arr.pop()
    # 빈 날 있는지 찾아보기
    while d &amp;gt;= 1 and filled[d]:
        d -= 1
    # 순회강연을 할 수 있는 경우
    if d &amp;gt;= 1:
        filled[d] = True
        res += p

print(res)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 11 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/11/BOJ-1209.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/11/BOJ-1209.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver1 - 통나무 건너뛰기</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem11497&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/11497&quot;&gt;백준 11497번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;t = int(input())


def solution(n, arr):
    ans = [-1] * n
    arr.sort(reverse=True)
    l, r = 0, n-1
    i = 0
    while arr:
        x = arr.pop()
        if i % 2 == 0:
            ans[l] = x
            l += 1
        else:
            ans[r] = x 
            r -= 1
        i += 1
    max_len = 0
    for i in range(n):
        max_len = max(max_len, abs(ans[i]-ans[i-1]))
    return max_len   


res = [] 
for _ in range(t):
    n = int(input())
    arr = list(map(int, input().split()))
    res.append(solution(n, arr))

print(*res, sep='\n')
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 11 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/11/BOJ-11497.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/11/BOJ-11497.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold5 - 강의실 배정</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem11000&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/11000&quot;&gt;백준 11000번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;import heapq

n = int(input())
arr = [-1] * n
for i in range(n):
    s, t = map(int, input().split())
    arr[i] = (s, t)
heapq.heapify(arr)

# 강의가 끝나는 시간만 저장하는 heap
h = [heapq.heappop(arr)[1]]
while arr:
    s, t = heapq.heappop(arr)
    # 강의실을 이어서 쓸 수 있다면 pop 후 새로운 end 시간 넣기
    if s &amp;gt;= h[0]:
        heapq.heappop(h)
        heapq.heappush(h, t)
    # 아니라면 그냥 새로운 end 시간 넣기
    else:
        heapq.heappush(h, t)

print(len(h))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 11 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/11/BOJ-11000.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/11/BOJ-11000.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Silver3 - 수리공 항승</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1449&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1449&quot;&gt;백준 1449번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n, l = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort()

cnt = 1
start = arr[0]-0.5
for i in range(1, n):
    end = arr[i]+0.5
    # 돌려막기 가능
    if end &amp;lt;= start+l:
        continue
    else: # 새로 테이프를 붙여야 한다.
        cnt += 1
        start = arr[i]-0.5

print(cnt)
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 09 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/09/BOJ-1449.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/09/BOJ-1449.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
      <item>
        <title>백준 Gold4 - 단어 수학</title>
        <description>&lt;h3 id=&quot;httpswwwacmicpcnetproblem1339&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1339&quot;&gt;백준 1339번&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;풀이&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python3&quot;&gt;n = int(input())
d = {}
for _ in range(n):
    word = input()
    for i in range(len(word)-1, -1, -1):
        d[word[i]] = d.get(word[i], 0) + 10 ** (len(word)-i-1)

d = sorted(d.items(), key=lambda x: -x[1])
total = 0
num = 9
for ch, cnt in d:
    total += num * cnt
    num -= 1

print(total)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;십진법의 특성을 생각해서 풀면된다. 예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;GCF+ACDEB&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;100*G+10*C+1*F+10000*A+1000*C+100*D+10*E+1*B&lt;/code&gt;로 풀어서 쓸 수 있으니 곱해지는 계수가 큰 것부터 단어에 계수를 매겨주면 그게 바로 최적해에 해당한다.&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://subong0508.github.io/problem-solving/2021/02/09/BOJ-1339.html</link>
        <guid isPermaLink="true">http://subong0508.github.io/problem-solving/2021/02/09/BOJ-1339.html</guid>
        
        <category>python</category>
        
        <category>coding-test</category>
        
        <category>programmers</category>
        
        <category>boj</category>
        
        <category>baekjoon</category>
        
        
        <category>Problem-Solving</category>
        
      </item>
    
  </channel>
</rss>
